<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="http://www.vrjuggler.org/docbook_ab.css" type="text/css"?>
<?morphon-document-settings
  morphon.document.settings.whitespaces.amount="3"
  morphon.document.settings.print.fixed.attributes="true"
  morphon.document.settings.stylesheetpi.autoupdate="true"
  morphon.document.settings.print.defaultvalues.attributes="false"
  morphon.document.settings.relative.systemids="0"
  morphon.document.settings.endofline.type="2"
  morphon.document.settings.whitespaces.type="indent"
  morphon.document.settings.maxlinelength="0"
?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<book>
   <bookinfo>
      <title>Tweek</title>
      <subtitle>The Programmer's Guide</subtitle>
      <authorgroup>
         <author>
            <firstname>Patrick</firstname>
            <surname>Hartling</surname>
         </author>
      </authorgroup>
      <releaseinfo>0.13</releaseinfo>
      <pubdate>$Date$</pubdate>
   </bookinfo>
   <preface>
      <title>Preface</title>
      <para>This book is the programmer's guide for Tweek. The main focus is how to use the features and capabilities of Tweek to enable cross-platform Java graphical user interfaces (GUIs) to communicate with C++ applications.</para>
      <para>The history of Tweek dates back to April 2000, though the basis for its existence comes from circa 1997. At Iowa State University's Virtual Reality Applications Center, the idea of using a Java GUI to communicate with, and possibly perform manipulations on, C++ applications is the foundation for dynamic reconfiguration of VR Juggler. To that end, the Java application VjControl was developed specifically for that purpose. VjControl was started in 1997 and has been under development ever since.</para>
      <para>Building on the basic idea of a Java GUI that could communicate with a C++ application, a viewer was written for the Distributed Shared Object (DSO) software system written in April 2000. This iteration of DSO was for a class project (Computer Science 552 taught by Dr. Johnny Wong). At the time, we (Allen Bierbaum and I) felt that CORBA could be used as a way to share arbitrary object-based information between applications on a network. The Java GUI was used to visualize the network of CORBA-connected nodes and to manipulate the network by disconnecting and reconnecting the nodes. In the end, CORBA was not the right solution to this problem, but the basis for network visualization was founded. Using CORBA for communication between the C++ code and Java code was relatively easy, however.</para>
      <para>In April 2001, we were again faced with a class project. Based on the results of the CORBA-based DSO, we felt that it would be best to implement a peer-to-peer software multicasting system that would be more efficient than CORBA. This new system, called Plexus, would still offer the same capabilities of cross-platform data distribution, but we had to give up the inherent cross-language support offered by CORBA. Again, we wanted a Java GUI for visualizing the network, and we started with the DSO viewer code. Instead of using CORBA, which we had had some difficulties with the previous year, we chose to use Java's built-in Remote Method Invocation (RMI) system. While RMI is very easy to use between two Java applications, Java to C++ communication is difficult. It requires the use of the Java Native Interface (JNI) so that natively compiled C++ code can communicate in memory with a loaded Java virtual machine (JVM). All of the Java code and RMI was collected into a package called PlxView (<quote>plex-view</quote>).</para>
      <para>Despite the difficulty of writing JNI code, the RMI solution was effective, for the most part. In September 2001, yet another project loomed. By this time, we were fed up with RMI, and we decided to go back to CORBA solely for communicating between Java and C++. Indeed, by using CORBA, we could write network visualization software in <emphasis>any</emphasis> language and communicate through the same channels.</para>
      <para>Beyond just communicating with the C++ applications, we had high hopes for using RMI to download Java code at run time to add custom visualization panels to the Java GUI dynamically. The Java code would come in the form of JavaBeans. While PlxView was designed to be modular from the start, we had not implemented the code for downloading the JavaBeans. To begin that work, I started writing code on a flight from Dallas/Ft. Worth to London, England, the evening of October 1, 2001. While at a CAVE workshop in Stockholm, Sweden, I took advantage of down time and late nights to extend PlxView to load and use JavaBeans.</para>
      <para>When I returned to the United States after the week in Stockholm, PlxView had evolved into what could be called version 0.0.0 of the Tweek Java GUI (sans CORBA, however). Its primary purpose was still Plexus network visualization. Design discussions with other members of the Juggler Team evolved the code into what is now the Tweek Java API. The Plexus-specific parts were separated into what is now the PlxView Bean, and the remaining code was moved into the new Tweek source tree.</para>
      <para>The only remaining piece was CORBA support. Another student, Andrew Schwantes, had been experimenting with CORBA in a smaller system, and his C++ CORBA code was used as a starting point for the Tweek C++ API. After much discussion with Allen Bierbaum, the code was re-implemented to make use of the Observer design pattern, and the Subject Manager was added. After all of that, the Java CORBA code was relatively trivial to add. And thus, the foundation for Tweek was in place by November 2001. By this time, it was already in use by the Fall 2001 Plexus class project.</para>
   </preface>
   <part>
      <title>Introduction</title>
      <chapter id="intro.tweek.chapter">
         <title>Tweek</title>
         <para>Programmers using Tweek must first understand what it is and what at does, at least at a conceptual level. Tweek has two parts: a Java <glossterm linkend="gloss.api">API</glossterm> and a C++ API. The two provide very distinct functionality, but they share a common bond through the use of remote method calls on shared objects. Objects defined in the C++ programming language can be accessed by objects defined in the Java programming language. Similarly, objects defined in Java can be accessed by C++ code. The C++ objects may be visualized and manipulated using the Tweek Java <glossterm linkend="gloss.gui">graphical user interface</glossterm> (GUI), a tool written using the Tweek Java API. This cross-language functionality is achieved through the use of remote method calls.</para>
         <para>Some readers may be familiar with remote procedure calls (RPC), a remote programming system first introduced by Sun Microsystems that uses the procedural programming paradigm. Remote method calls differ primarily through the use of the object-oriented programming paradigm. Tweek is implemented in two object-oriented languages and thus lends itself very well to a system implementing remote method calls.</para>
         <para>In the remainder of this chapter, we present a high-level description of the Tweek C++ API. The Java API design is much more complex and is not included in this chapter. (Refer to <xref linkend="prog.java.chapter"/> for details on using the Java API.) Most users of Tweek need to know more about the C++ side of Tweek than the Java side. This is because Tweek is designed around the philosophy of a simple Java GUI interacting with a potentially complex C++ application.</para>
         <section id="intro.design.section">
            <title>C++ API Design Overview</title>
            <para>The heart of the Tweek software system implements the Observer pattern <xref linkend="Gam95"/>. This design pattern is used to define the relationship between the Java GUI (observer) and the C++ application (subject). Within this section, we explain how the subject and observer are used. Moving beyond the subject/observer pattern, we also explain the <firstterm>Subject Manager</firstterm><indexterm>
                  <primary>Subject Manager</primary>
               </indexterm> and the <firstterm>CORBA Manager</firstterm><indexterm>
                  <primary>CORBA Manager</primary>
               </indexterm>. These four components make up the entirety of the C++ design.</para>
            <section>
               <title>Subject</title>
               <indexterm>
                  <primary>subject</primary>
                  <secondary>design and use</secondary>
               </indexterm>
               <para>The subjects in Tweek are part of the C++ applications. The communication <quote>channels</quote> are defined by the subjects' interfaces. An observer is attached to a subject, and whenever the state of a subject changes, it notifies all of its attached observers.</para>
               <para>The Tweek C++ API defines the basic subject interface (<interfacename>tweek::Subject</interfacename><indexterm>
                     <primary>interfaces</primary>
                     <secondary>tweek::Subject</secondary>
                  </indexterm>) that implements the subject pattern <xref linkend="Gam95"/>. Users of the Tweek C++ API derive from the base subject implementation (<classname>tweek::SubjectImpl</classname><indexterm>
                     <primary>classes</primary>
                     <secondary>tweek::SubjectImpl</secondary>
                  </indexterm>) and extend it by adding their own interface methods. This extension is twofold. First, an interface must be defined using the <glossterm linkend="gloss.idl">Interface Definition Language</glossterm> (IDL)<indexterm>
                     <primary>IDL</primary>
                  </indexterm>. Then, the interface must be implemented in C++ code. (Refer to <xref linkend="intro.corba.idl.section"/> for more information about IDL in Tweek.)</para>
            </section>
            <section>
               <title>Observer</title>
               <indexterm>
                  <primary>observer</primary>
                  <secondary>design and use</secondary>
               </indexterm>
               <para>The observers in Tweek are (traditionally) part of the Java GUI<footnote>
                     <para>Beginning with Tweek 0.13, helper classes for writing C++ observers are included with the C++ API. Users of older versions can make use of observers written in C++ (or any other programming language with a CORBA implementation), but the application developers will have to write the CORBA client code entirely from scratch.</para>
                  </footnote>. They observe the state of the remote subjects and can provide a visual rendering of that state.</para>
               <para>Programmers <emphasis>do not</emphasis> define interfaces for the observers. Instead, the Tweek C++ API defines a basic observer interface called <interfacename>tweek::Observer</interfacename><indexterm>
                     <primary>interfaces</primary>
                     <secondary>tweek::Observer</secondary>
                  </indexterm>. There is no <quote>standard</quote> observer implementation that corresponds to <classname>tweek::SubjectImpl</classname><indexterm>
                     <primary>classes</primary>
                     <secondary>tweek::SubjectImpl</secondary>
                  </indexterm>. By design, observers must correspond directly with subjects, but there is no need to extend the basic observer interface using IDL. Observer implementations simply inherit from the basic observer class (<classname>tweek.ObserverPOA</classname><indexterm>
                     <primary>classes</primary>
                     <secondary>tweek.ObserverPOA</secondary>
                  </indexterm> in Java or <classname>POA_tweek::Observer</classname><indexterm>
                     <primary>classes</primary>
                     <secondary>POA_tweek::Observer</secondary>
                  </indexterm> in C++) and implement the <methodname>update()</methodname> method. Other extensions can be added in the custom observer class, of course, but an implementation of <methodname>update()</methodname> is always required.</para>
            </section>
            <section>
               <title>CORBA Manager</title>
               <indexterm>
                  <primary>CORBA Manager</primary>
                  <secondary>design and use</secondary>
               </indexterm>
               <para><glossterm linkend="gloss.corba">CORBA</glossterm> tends to have a high learning curve. It is a very powerful system, but that power leads to a lot of complexity. To reduce the complexity of starting and using an <glossterm linkend="gloss.orb">ORB</glossterm>, Tweek provides a CORBA Manager. Its primary function is to initialize a local ORB. It does this by creating the <glossterm linkend="gloss.poa">Portable Object Adapter</glossterm> (POA), resolving the initial reference to the Naming Service, and starting a thread for the ORB to handle requests.</para>
               <note>
                  <para>An explanation of the POA is beyond the scope of this book. Users of Tweek do not have to use the POA directly because the CORBA Manager and Subject Manager hide these details. Interested readers are referred to <xref linkend="Hen99"/> for more information about the POA and CORBA in general.</para>
               </note>
               <para>Once the local ORB is initialized, the Subject Manager (discussed next) must be created. This is also done through the CORBA Manager because the Subject Manager is a CORBA object. The newly created Subject Manager will be a <glossterm linkend="gloss.servant">servant</glossterm> object to which CORBA references can be created.</para>
               <para>Refer to <xref linkend="intro.corba.section"/> for more information about CORBA and its use in Tweek. For the most part, the use of CORBA is an implementation detail. Users of the Tweek C++ API must initialize the CORBA Manager, however, and it is important to understand its place in the overall system.</para>
            </section>
            <section>
               <title>Subject Manager</title>
               <indexterm>
                  <primary>Subject Manager</primary>
                  <secondary>design and use</secondary>
               </indexterm>
               <para>The Tweek Subject Manager exists to simplify the use of CORBA further. At a very high level, it acts as a simplified, specialized CORBA Naming Service. Users of Tweek register subject servants with the Subject Manager. The Subject Manager handles the CORBA registration and activation of the servants. After being registered, subjects are accessed using symbolic strings. The strings are user-defined and do not necessarily conform to any CORBA-related standard. They are, in essence, identifiers used to look up the subject within the Subject Manager's collection of known subjects.</para>
            </section>
         </section>
         <section id="intro.corba.section">
            <title>CORBA</title>
            <indexterm>
               <primary>CORBA</primary>
               <secondary>use in Tweek</secondary>
            </indexterm>
            <para>CORBA, the <glossterm linkend="gloss.corba">Common Object Request Broker Architecture</glossterm>, is a powerful tool for <glossterm linkend="gloss.distrib-programming">distributed programming</glossterm>. It is a <emphasis>language-independent</emphasis> standard specified by the <ulink url="http://www.omg.org/">Object Management Group</ulink> (OMG). Many CORBA implementations, both free and commercial, exist for a wide variety of languages (e.g., C, C++, Java, Perl, Python, and Smalltalk). CORBA allows communication between software written in any programming language running on any operating system on any hardware architecture. It handles all serialization and de-serialization of objects and method parameters so that programmers do not have to worry about endian issues and other system incompatibilities.</para>
            <para>Before going further with the discussion of CORBA in Tweek, readers must be familiar with some terminology. In CORBA, the physical object to which references are made is called a <glossterm linkend="gloss.servant"><firstterm>servant</firstterm></glossterm>. The servant is an instance of some class that implements an interface and derives from <classname>CORBA::Object</classname> (or <classname>org.omg.CORBA.Object</classname> in Java). The actual details of servant implementations are postponed for later sections. For now, it is important to remember that there will be an object located in physical memory on some machine, and <emphasis>references</emphasis> will be made to that object through CORBA. Users acquire references by looking up the object by name in what is known as the CORBA <firstterm>Naming Service</firstterm>. The Naming Service has objects registered within its database, and clients request references from the database. When the reference is made available, methods may be invoked on it. Since the physical object resides in another memory space, this will create network traffic, though it is entirely transparent to the programmer.</para>
            <para>CORBA uses <glossterm linkend="gloss.orb">Object Request Brokers</glossterm> (ORBs) to manage locally registered objects and to communicate with remote objects. The remote objects are managed by ORBs that reside locally on the machines that have the servants. Two ORBs communicate with each other using a standard protocol. In this case, that protocol is the <glossterm linkend="gloss.iiop">Internet Inter-ORB Protocol</glossterm> (IIOP). IIOP is a new addition to Version 2.3 of the CORBA standard. It allows two ORBs written by different vendors to communicate and inter-operate. This capability is crucial to the correct functionality of Tweek and many other CORBA-based software systems.</para>
            <para>Within the scope of Tweek, CORBA is used to enable transparent communication between C++ applications and the Tweek Java GUI. C++ objects registered with a local ORB are made available to the Java GUI through the Subject Manager. Beyond this, CORBA exists mostly "behind the scenes" so that developers of Tweek-based software do not have to learn very much about CORBA. Programmers must understand the Interface Definition Language, however, and this is explained next.</para>
            <section id="intro.corba.idl.section">
               <title>Interface Definition Language</title>
               <para>The <glossterm linkend="gloss.idl">Interface Definition Language</glossterm> (IDL)<indexterm>
                     <primary>IDL</primary>
                  </indexterm> is used by the CORBA standard to define the <emphasis>interfaces</emphasis> for remotely accessible objects. An IDL file looks very much like a simple C++ class declaration in a header file, though data members are not allowed in the interface. Thus, IDL is used exclusively to define the methods of the objects and external data structures that may be passed as arguments to those methods.</para>
               <para>The interfaces alone are not sufficient to implement objects that may be handled by CORBA. A language-specific implementation must be written so that servants can be instantiated and registered with an ORB. To implement an interface, an <glossterm linkend="gloss.idl-compiler">IDL compiler</glossterm> must first be used to generate skeleton code for a specific language from the IDL file. Using the generated code, an implementation is then written. In <xref linkend="prog.idl.chapter"/>, we explain in more detail how to use IDL to define interfaces.</para>
            </section>
            <section>
               <title>Supported Languages</title>
               <para>As discussed above, a very powerful feature of CORBA is its language independence. Tweek itself supports only C++ and Java as of this writing. There is no restriction, other than time and resources, that prevents the addition of support for other languages. In this section, we explain how C++ and Java are used in Tweek.</para>
               <section>
                  <title>C++</title>
                  <para>A key part of the overall Tweek design is that complex, high-performance applications will be written in C++. While this may not necessarily be the case in every situation, this is the assumption made for the design and implementation of the Tweek C++ API. As mentioned previously, support could be added for other languages so that they too may fulfill the role of C++ in Tweek.</para>
                  <section>
                     <title>C++ Subjects</title>
                     <para>Using the C++ API on the server side to create subjects, programmers activate a local ORB using the CORBA Manager. Once an ORB is available, servants that will act as subjects can be registered with the Subject Manager. The subjects are activated within the local POA by the Subject Manager, thus alleviating some work for programmers. Once activated, the subjects may be accessed remotely through CORBA by code written in any language&mdash;including C++.</para>
                  </section>
                  <section>
                     <title>C++ Observers</title>
                     <para>Using the C++ API on the client side to create observers, programmers again activate a local ORB using the CORBA Service. Once an ORB is available, servants that will act as observers can be registered with the local POA via the CORBA Service. Once activated, the observers can be attached to remote subjects that may be written in any langauge. C++ observer code is very similar to Java observer code.</para>
                  </section>
               </section>
               <section>
                  <title>Java</title>
                  <para>In the Java programming language, the Swing API provides developers with a very nice suite of classes for writing cross-platform GUIs. When developing Tweek, we took advantage of Swing and JavaBeans technology <xref linkend="Jbe02"/> to write a generalized GUI framework. Users can plug components (Beans) into this framework at runtime to extend its functionality. The Beans can get access to remote C++ objects through the CORBA services provided by the Tweek Java API. Similar to the C++ API, the use of CORBA in Java has been simplified so that programmers can use it with little effort and without a comprehensive understanding of CORBA in general.</para>
                  <para>Programmers will use Java as part of their Tweek programming to write JavaBeans. Compared to the potential complexity of the GUI code for Beans, little CORBA programming must be done in Java. Beans may be as simple or as complex as necessary to meet the needs of individual projects. More information about JavaBeans is provided in <xref linkend="intro.javabeans.chapter"/>.</para>
               </section>
            </section>
         </section>
      </chapter>
      <chapter id="intro.javabeans.chapter">
         <title>JavaBeans</title>
         <para>The Tweek Java GUI uses JavaBeans to be more flexible and accessible to programmers. The GUI is a framework into which graphical and non-graphical components may be <quote>plugged</quote>. Graphical components add interaction functionality. Non-graphical components extend internal functionality, oftentimes needed by the graphical components. Conceptually, this follows the traditional use of plug-in architectures wherein the components are discovered dynamically and added into the larger framework. In the case of the Tweek Java GUI, the plug-ins will fit into one of four categories, the most important of which is <firstterm>Panel Bean</firstterm>.</para>
         <section>
            <title>Bean Categories</title>
            <para>There are four types of Beans that may be loaded by the Tweek Java GUI. They are categorized based on functionality and what is known about them in advance. The following lists the four categories in order of decreasing <foreignphrase>a priori</foreignphrase> knowledge.</para>
            <orderedlist>
               <listitem>
                  <para>Service Beans</para>
               </listitem>
               <listitem>
                  <para>Viewer Beans</para>
               </listitem>
               <listitem>
                  <para>Panel Beans</para>
               </listitem>
               <listitem>
                  <para>Generic Beans</para>
               </listitem>
            </orderedlist>
            <section>
               <title>Service Beans</title>
               <indexterm>
                  <primary>Service Beans</primary>
               </indexterm>
               <para>Services encapsulate functionality that may be useful to other parts of the Tweek system or dynamically loaded code. The entire interface for Service Beans must be known when the code using the service is compiled. This is because the using code needs to be able to take advantage of the service. Because Service Beans may be loaded dynamically, using code must be prepared for the case when the Bean containing the service was not found. In other words, code that uses services cannot necessarily assume that the service will be available.</para>
               <para>Not all services are loaded dynamically as Beans. Some services are loaded statically because they are needed by core components. These include the Environment Service and the Global Preferences Service. There is a guarantee that the code for these services will always be available. This guarantee is especially important because the Tweek core needs to add information to the Environment Service at startup. The Global Preferences Service is needed to configure the overall behavior of the Tweek GUI.</para>
            </section>
            <section>
               <title>Viewer Beans</title>
               <indexterm>
                  <primary>Viewer Beans</primary>
               </indexterm>
               <para>Viewer Beans provide a rendering of the tree of Panel Beans (discussed next). They provide the viewer component of the model/view pattern <xref linkend="Gam95"/>. All Viewer Beans are loaded dynamically, and the active viewer can be changed at runtime by editing the global preferences. This feature is realized through the flexibility of the model/view pattern.</para>
               <para>Viewer Beans must implement the <interfacename>org.vrjuggler.tweek.beans.BeanModelViewer</interfacename> interface. To simplify implementation, they may be derived from <classname>org.vrjuggler.tweek.beans.DefaultBeanModelViewer</classname>, a class that implements aspects of the interface that are unlikely to vary between viewer implementations. The use of the interface is needed so that the GUI frame can assume certain behaviors about the viewer.</para>
            </section>
            <section>
               <title>Panel Beans</title>
               <indexterm>
                  <primary>Panel Beans</primary>
               </indexterm>
               <para>Most programmers using Tweek will write Panel Beans. These provide custom interfaces for whatever users need. In most cases, a Panel Bean will provide a graphical interface that can manipulate and/or control a C++ application, but developers are not strictly limited to this use.</para>
               <para>Only one assumption is made about Panel Beans: the primary class for the Bean must be a subclass of <classname>javax.swing.JComponent</classname>. Optionally, the primary class may implement one or more publicly provided interfaces that provide the Java GUI with more information about the capabilities of the Bean. When loaded, the GUI checks to see what, if any, interfaces are implemented by the Bean. Based on the results, special actions may be taken to provide the Bean with extended functionality.</para>
               <para>For example, Beans that can load files should implement <interfacename>org.vrjuggler.tweek.beans.FileLoader</interfacename>. When the Bean is focused in the viewer, the <guimenu>File</guimenu> menu will be modified to enable the <guimenuitem>Open</guimenuitem>, <guimenuitem>Save</guimenuitem>, and <guimenuitem>Close</guimenuitem> items. If the user selects one of these items, the Bean is informed and can take appropriate customized actions. The result in this case is context-specific loading and unloading of files.</para>
            </section>
            <section>
               <title>Generic Beans</title>
               <indexterm>
                  <primary>Generic Beans</primary>
               </indexterm>
               <para>Nothing at all is assumed about Generic Beans. This Bean category is provided so that other Beans can do their own dynamic code loading. For example, a Bean that uses a factory pattern may want to have the <quote>workers</quote> loaded dynamically based on some criteria. Thus, the functionality of the factory can be changed dynamically.</para>
               <para>The Tweek Java GUI does not use Generic Beans itself. These are provided more for users of the Tweek Java API. It is up to those programmers to decide how to handle the Generic Beans on a case-by-case basis.</para>
            </section>
         </section>
         <section>
            <title>XML</title>
            <indexterm>
               <primary>Bean descriptions</primary>
               <secondary>using XML</secondary>
            </indexterm>
            <para>All JavaBeans loaded by the Tweek Java GUI are describe by at least one <glossterm linkend="gloss.xml.main">XML</glossterm> file<indexterm>
                  <primary>XML</primary>
               </indexterm>. The XML file can contain information about many Beans or about a single Bean. The XML file itself is a <quote>beanlist</quote> document. The four Bean categories, described above, each have an XML element that has children giving information about the specific Bean. The elements are <sgmltag>&lt;service&gt;</sgmltag>, <sgmltag>&lt;viewer&gt;</sgmltag>, <sgmltag>&lt;guipanel&gt;</sgmltag>, and <sgmltag>&lt;generic&gt;</sgmltag>.</para>
            <para>All Bean XML entries must contain a <sgmltag>&lt;file&gt;</sgmltag> element. Through its <literal>source</literal> attribute, this element provides the path to the JAR file that contains the full Bean code. When specifying the JAR file path, environment variables may be used. They must use the syntax <envar>${ENV_VAR}</envar> (the curly braces are required). The <literal>class</literal> element gives the fully qualified name of the class stored within the JAR file that will be instantiated. The extension <filename>.class</filename> must not be specified. This is to allow the use of serialized classes which have the extension <filename>.ser</filename>. The Tweek Bean-loading code will figure out what is available and take the right actions.</para>
            <para>In addition to the <sgmltag>&lt;file&gt;</sgmltag> element, a &lt;dependencies&gt; element may be specified. Dependencies of the Bean may be named as external JAR files or other Beans may be listed therein. The &lt;dependencies&gt; element may contain zero of more elements of type &lt;jar&gt; and/or &lt;bean&gt;. The &lt;jar&gt; element has a single attribute, <literal>path</literal>, which gives the path (a semi-colon separated list of directories) where the JAR file may be found. The contents of the &lt;jar&gt; element defines the name of the JAR file. The &lt;bean&gt; element's contents defines the name of the Bean that the current Bean depends on.</para>
            <para>Of the four Bean categories, the XML for Panel Beans can contain the most information. In addition to the previously mentioned elements, Panel Bean entries may have two optional elements: <sgmltag>&lt;tree&gt;</sgmltag> and <sgmltag>&lt;icon&gt;</sgmltag>. The element <sgmltag>&lt;tree&gt;</sgmltag> specifies the path within the Bean tree hierarchy where the Panel Bean will be placed. The path is given as a /-separated list of directories. If the named path does not exist when the Bean is loaded, it will be created. The element <sgmltag>&lt;icon&gt;</sgmltag> names a custom icon for the Bean and a tool-tip. An example of a Panel Bean XML entry is shown in <xref linkend="PlexusGraphView.xml.example"/>. Note that this is not the full file&mdash;it is only the <sgmltag>&lt;guipanel&gt;</sgmltag> element for a single Bean.</para>
            <example id="PlexusGraphView.xml.example">
               <title>PlexusGraphView.xml snippet</title>
               <programlisting>&lt;guipanel name="Graph View"&gt;
  &lt;file name="${PLX_BASE_DIR}/bin/beans/PlexusGraphView.jar" 
        class="plx.graphview.GraphView" /&gt;
  &lt;tree path="/" /&gt;
  &lt;dependencies&gt;
    &lt;jar path="${PLX_BASE_DIR}/bin"&gt;openjgraph.jar&lt;/jar&gt;
    &lt;jar path="${PLX_BASE_DIR}/bin"&gt;jgraph.jar&lt;/jar&gt;
    &lt;jar path="${PLX_BASE_DIR}/bin"&gt;PlexusComm.jar&lt;/jar&gt;
  &lt;/dependencies&gt;
  &lt;icon source="jar:file:${PLX_BASE_DIR}/bin/beans/PlexusGraphView.jar!/plx/graphview/icon.gif"
        tooltip="Plexus Network Graph Visualization" /&gt;
&lt;/guipanel&gt;</programlisting>
            </example>
            <para>This shows the use of all the elements that may be children of <sgmltag>&lt;guipanel&gt;</sgmltag>. Note that the <literal>source</literal> attribute of <sgmltag>&lt;icon&gt;</sgmltag> gets its icon image using a JAR URL.</para>
            <para>Another example XML file is shown in <xref linkend="Viewers.xml.example"/>. This is the actual file used to load the two Viewer Beans that come with the Tweek distribution. This is a complete file containing two Viewer Bean entries.</para>
            <example id="Viewers.xml.example">
               <title>Viewers.xml</title>
               <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beanlist xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:noNamespaceSchemaLocation="http://www.vrjuggler.org/tweek/xsd/1.1/beanlist.xsd"&gt;
  &lt;viewer name="Tree Viewer"&gt;
    &lt;file name="${TWEEK_BASE_DIR}/bin/beans/Viewers.jar" 
          class="org.vrjuggler.tweek.treeviewer.BeanTreeViewer" /&gt;
  &lt;/viewer&gt;
  &lt;viewer name="Icon Viewer"&gt;
    &lt;file name="${TWEEK_BASE_DIR}/bin/beans/Viewers.jar" 
          class="org.vrjuggler.tweek.iconviewer.BeanIconViewer" /&gt;
  &lt;/viewer&gt;
&lt;/beanlist&gt;</programlisting>
            </example>
         </section>
      </chapter>
   </part>
   <part>
      <title>Programming</title>
      <partintro>
         <para>In the following chapters, we present the basic information needed to start programming with Tweek. There will be discussion covering IDL, C++, Java, and CORBA. To use Tweek effectively, a good understanding of C++ and Java is required. The IDL aspect of Tweek is minimal, and programmers familiar with basic object-oriented concepts should be able to understand IDL code easily. Discussion related to CORBA is based on the brief introduction given in <xref linkend="intro.corba.section"/>. The Tweek Java and C++ APIs are designed to hide most CORBA details. Whenever possible, references are given to good sources of information on all of the aforementioned topics.</para>
         <para>Before proceeding, it is important to know that Tweek is designed and implemented to work with VR Juggler 1.1 and 2.0. It can be used with VR Juggler 1.0, but there have been reports of conflicts occurring between VR Juggler 1.0 and the VR Juggler Portable Runtime (VPR) that is part of VR Juggler 1.1. The Tweek C++ code uses VPR for threading, but it is possible to replace the VPR objects with VR Juggler 1.0 thread objects.</para>
      </partintro>
      <chapter id="prog.idl.chapter">
         <title>IDL</title>
         <para>In this chapter, we present the basic information needed to define interfaces that will be used by Tweek. This is not a detailed introduction to IDL programming. Readers are referred to <xref linkend="Hen99"/>.</para>
         <para>IDL <quote>programming</quote> means defining <glossterm linkend="gloss.interface">interfaces</glossterm>. In the scope of Tweek and CORBA, the interfaces declare what operations may be performed on CORBA references. The arguments and return values may be of several basic types including, but not limited to, <type>string</type>, <type>int</type>, <type>long</type>, and <type>float</type>. These types are specified in a language-independent manner. When the IDL compiler generates the code for a specific language, the language-specific types that correspond to the IDL types are used.</para>
         <para>In <xref linkend="Subject.idl.example"/>, we show the Tweek <interfacename>Subject</interfacename><indexterm>
               <primary>interfaces</primary>
               <secondary>tweek::Subject</secondary>
            </indexterm> interface. Note the similarity to a C++ header file. The IDL file can be included by other IDL files, and thus it must <quote>protect</quote> the contents in the same manner as a header file. The actual <interfacename>Subject</interfacename> interface is defined within the <literal>tweek</literal> module. An IDL module corresponds to a C++ namespace or to a Java package. The interface itself has three methods: <methodname>attach()</methodname>, <methodname>detach()</methodname>, and <methodname>notify()</methodname>. The first two take a read-only argument of type <interfacename>Observer</interfacename>. The fact that the argument is read-only (to the server) is specified by the <literal>in</literal> modifier. Other modifiers are <literal>out</literal> (sent from server to client) and <literal>inout</literal> (initialized by the client, writable by the server). The third method, <methodname>notify()</methodname>, takes no arguments, and none of the methods have a return type.</para>
         <example id="Subject.idl.example">
            <title>Subject.idl</title>
            <indexterm>
               <primary>tweek::Subject</primary>
               <secondary>IDL definition</secondary>
            </indexterm>
            <programlisting>#ifndef _TWEEK_SUBJECT_IDL_
#define _TWEEK_SUBJECT_IDL_

#include &lt;tweek/idl/Observer.idl&gt;


module tweek
{

interface Subject
{
   void attach(in Observer o);
   void detach(in Observer o);
   void notify();
};

};

#endif</programlisting>
         </example>
         <para>By definition, all objects are passed by reference in CORBA. The modifier stating the readability and/or writability in the IDL file determines how the referenced object may be modified, if at all, within the method.</para>
         <para>Applications that make use of Tweek will define custom interfaces that extend the <interfacename>Subject</interfacename> interface. For example, consider a custom subject that maintains a floating-point value. It could have the following interface:</para>
         <example id="CustomSubject.idl.example">
            <title>CustomSubject.idl</title>
            <programlisting>#ifndef _CUSTOM_SUBJECT_IDL_
#define _CUSTOM_SUBJECT_IDL_

#include &lt;tweek/idl/Subject.idl&gt;

module mymod
{

interface CustomSubject : tweek::Subject
{
   float getValue();
   void setValue(in float v);
};

};

#endif</programlisting>
         </example>
         <para>In this interface, we define two methods: <methodname>getValue()</methodname> and <methodname>setValue()</methodname>. The implementation of this interface would of course include these methods and would derive from the implementation of the <interfacename>Subject</interfacename> interface.</para>
      </chapter>
      <chapter id="prog.cplusplus.chapter">
         <title>C++</title>
         <indexterm>
            <primary>C++ server API</primary>
         </indexterm>
         <para>Writing C++ code that makes use of Tweek is not difficult, though it often requires some good planning. With the current code base, the C++ side of things maintains the state information through an implementation of the Tweek <interfacename>Subject</interfacename><indexterm>
               <primary>interfaces</primary>
               <secondary>tweek::Subject</secondary>
            </indexterm> interface. Instances of such an implementation may need to communicate with other parts of a given application, and it is important to define these relationships well. In other words, as a maintainer of application state information, the subject implementation should have easy access to that state information.</para>
         <para>Furthermore, developers must keep in mind that there may be asynchronous execution of application code as a result of using Tweek. The local ORB runs in its own thread, and as such, it executes methods of <glossterm linkend="gloss.servant">servants</glossterm> from that thread. Whatever the servant does, it should be thread-safe with respect to the rest of the application.</para>
         <para>In this chapter, we cover each aspect of writing C++ code that uses the Tweek API. We begin by explaining how to make a custom subject implementation. Then, we discuss the use of the CORBA Manager from user-level code. We conclude the chapter with an overview of using the Subject Manager.</para>
         <section>
            <title>Deriving from <classname>tweek::SubjectImpl</classname></title>
            <indexterm>
               <primary>tweek::SubjectImpl</primary>
               <secondary>deriving from</secondary>
            </indexterm>
            <para>To create a custom subject implementation, you must derive from two classes: the abstract class that defines the custom interface and <classname>tweek::SubjectImpl</classname>. Referring back to the interface shown in <xref linkend="CustomSubject.idl.example"/>, the basic C++ class declaration would appear as follows:</para>
            <example id="CustomSubjectImpl.h.example">
               <title>CustomSubjectImpl.h</title>
               <programlisting linenumbering="numbered">#ifndef _CUSTOM_SUBJECT_IMPL_H_
#define _CUSTOM_SUBJECT_IMPL_H_

#include &lt;tweek/CORBA/SubjectImpl.h&gt;
#include &lt;CustomSubject.h&gt;


namespace mymod
{

class CustomSubjectImpl : public POA_mymod::CustomSubject,      <co linkends="CustomSubjectImpl.superclass.co" id="CustomSubjectImpl.interface.line"/>
                          public tweek::SubjectImpl             <co linkends="CustomSubjectImpl.superclass.co" id="CustomSubjectImpl.SubjectImpl.line"/>
public:
   CustomSubjectImpl() : mValue(0.0f)
   {
      ;
   }

   virtual ~CustomSubjectImpl()
   {
      ;
   }

   virtual float getValue();                                    <co linkends="CustomSubjectImpl.interface.methods.co" id="CustomSubjectImpl.setValue.decl"/>

   virtual void setValue(float v);                              <co linkends="CustomSubjectImpl.interface.methods.co" id="CustomSubjectImpl.getValue.decl"/>

   mymod::CustomSubject_ptr _this()                             <co linkends="CustomSubjectImpl._this.hack.co" id="CustomSubjectImpl._this.decl"/>
   {
      return POA_mymod::CustomSubject::_this();
   }

private:
   float mValue;
};

}

#endif</programlisting>
               <calloutlist>
                  <callout arearefs="CustomSubjectImpl.interface.line CustomSubjectImpl.SubjectImpl.line" id="CustomSubjectImpl.superclass.co">
                     <para>Here we declare our parent classes, <classname>POA_mymod::CustomSubject</classname> and <classname>tweek::SubjectImpl</classname>. The first is code generated by the IDL compiler, and the second is included as part of the Tweek C++ API. Both are necessary for this custom interface to work correctly as a Tweek subject.</para>
                  </callout>
                  <callout arearefs="CustomSubjectImpl.setValue.decl CustomSubjectImpl.getValue.decl" id="CustomSubjectImpl.interface.methods.co">
                     <para>These two declarations correspond to the <interfacename>CustomSubject</interfacename> interface defined in <xref linkend="CustomSubject.idl.example"/>. The implementations of these methods are not shown here, but they are required for the code to compile. That is, the declarations in <classname>POA_mymod::CustomSubject</classname> are pure virtual methods, and an instance of <classname>mymod::CustomSubjectImpl</classname> cannot be created unless these methods are implemented.</para>
                  </callout>
                  <callout arearefs="CustomSubjectImpl._this.decl" id="CustomSubjectImpl._this.hack.co">
                     <para>Overriding the method named <methodname>_this()</methodname> is required due to the diamond inheritance tree created by deriving from <classname>POA_mymod::CustomSubject</classname> and <classname>tweek::SubjectImpl</classname>. Both of these classes derive from <classname>tweek::Subject</classname>. The <methodname>_this()</methodname> method plays a critical role in the CORBA communication, and it is imperative that it return the correct type to the caller when invoked on a servant instance. Without this override, the returned type will be <classname>tweek::Subject_ptr</classname>, and attempts to narrow to <classname>mymod::CustomSubject_ptr</classname> will fail.</para>
                     <para>Note the namespaces used on this method. The return type is <classname>mymod::CustomSubject_ptr</classname>, which corresponds to the namespace in which the classes <classname>CustomSubjectImpl</classname> and <classname>CustomSubject</classname> are defined. To get the actual value to return, <classname>POA_mymod::CustomSubject</classname> (one of the two parent classes) is used.</para>
                  </callout>
               </calloutlist>
            </example>
            <para>The implementations of <methodname>getValue()</methodname> and <methodname>setValue()</methodname> are fairly obvious, though they are presented here for the sake of completeness. Note, however, that <methodname>setValue()</methodname> changes the state of the subject, and thus any observers must be notified of the change. The implementations are shown in the following example.</para>
            <example>
               <title>CustomSubjectImpl.cpp</title>
               <programlisting>#include &lt;CustomSubjectImpl.h&gt;

namespace mymod
{

float CustomSubjectImpl::getValue()
{
   return mValue;
}

void CustomSubjectImpl::setValue(float v)
{
   mValue = v;
   tweek::SubjectImpl::notify();
}

}</programlisting>
            </example>
            <para>The key point to note is the call to <methodname>tweek::SubjectImpl::notify()</methodname> in the <methodname>setValue()</methodname> implementation. In general, anything that modifies the state of the subject requires that this method be invoked. Note also that the method is fully qualified so that we are sure to call the correct implementation.</para>
         </section>
         <section>
            <title>Using the CORBA Manager</title>
            <indexterm>
               <primary>CORBA Manager</primary>
               <secondary>use of</secondary>
            </indexterm>
            <para>Initializing the CORBA Manager is straightforward, but it does require exception handling. If the exceptions are not handled correctly, applications will abort if an exception is thrown but not caught. Refer to a C++ reference for more information about exceptions and exception handling in C++.</para>
            <para>The following example shows a <function>main()</function> function for an application that performs all the Tweek initialization steps. We separate the discussion into two parts: one part for the CORBA Manager and one part for the Subject Manager (discussed in the next section).</para>
            <example id="TweekApp.cpp.CORBA-Manager.example">
               <title>TweekApp.cpp</title>
               <programlisting linenumbering="numbered">#include &lt;vpr/vpr.h&gt;
#include &lt;vpr/Thread/Thread.h&gt;
#include &lt;vpr/Util/Debug.h&gt;
#include &lt;tweek/CORBA/CorbaManager.h&gt;                                        <co linkends="TweekApp.cpp.includes.co" id="TweekApp.cpp.includes.tweek"/>

#include &lt;CustomSubjectImpl.h&gt;                                               <co linkends="TweekApp.cpp.includes.co" id="TweekApp.cpp.includes.gen"/>


/**
 * This application starts the CORBA server for the C++ side of the test.
 */
int main(int argc, char* argv[])
{
   tweek::CorbaManager mgr;                                                  <co linkends="TweekApp.cpp.corbamgr.decl.co" id="TweekApp.cpp.corbamgr.decl"/>

   // The first thing we have to do is initialize the Tweek CORBA Manager.
   // If this fails, we're out of luck.
   try                                                                       <co linkends="TweekApp.cpp.big-try-catch.co" id="TweekApp.cpp.big-try-catch.try"/>
   {
      if ( mgr.init("example", argc, argv).success() )                       <co linkends="TweekApp.cpp.corbamgr.init.co" id="TweekApp.cpp.corbamgr.init"/>
      {
         vpr::ReturnStatus status;

         // Once the CORBA Manager is initialized, we need to create a
         // Subject Manager.  This will hold our CustomSubject object.
         try
         {
            status = mgr.createSubjectManager();

            // If we were able to create the Subject Manager, now we register
            // our objects with it.
            if ( status.success() )
            {
               // First, create real instances of the C++ object that will
               // be the CORBA servant.  This must be allocated on the heap.
               mymod::CustomubjectImpl* custom_subj =
                  new mymod::CustomSubjectImpl();

               // Now we try to register the subject and give it a symbolic,
               // easy-to-remember name.
               try
               {
                  mgr.getSubjectManager()-&gt;registerSubject(slider_subj,
                                                           "CustomSubject");
               }
               catch (...)
               {
                  vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
                     &lt;&lt; "Failed to register subject\n" &lt;&lt; vprDEBUG_FLUSH;
               }
            }
         }
         catch (CORBA::Exception&amp; ex)
         {
            vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
               &lt;&lt; "Caught an unknown CORBA exception when trying to register!\n"
               &lt;&lt; vprDEBUG_FLUSH;
         }

         if ( ! status.success() )
         {
            vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
               &lt;&lt; "Failed to register Subject Manager instance\n"
               &lt;&lt; vprDEBUG_FLUSH;
         }

         std::cout &lt;&lt; "Press 'x' to exit" &lt;&lt; std::endl;
         char input;

         // Loop forever so that we can act sort of like a server.
         while ( 1 )
         {
            std::cin &gt;&gt; input;
            if ( input == 'x' )
            {
               break;
            }
            else
            {
               vpr::System::msleep(100);
            }
         }
      }
      else
      {
         vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
            &lt;&lt; "CORBA failed to initialize\n" &lt;&lt; vprDEBUG_FLUSH;
      }
   }
   catch (...)                                                               <co linkends="TweekApp.cpp.big-try-catch.co" id="TweekApp.cpp.big-try-catch.catch"/>
   {
      vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
         &lt;&lt; "Caught an unknown exception!\n" &lt;&lt; vprDEBUG_FLUSH;
   }

   vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL) &lt;&lt; "Exiting\n" &lt;&lt; vprDEBUG_FLUSH;

   return 0;
}</programlisting>
               <calloutlist>
                  <callout arearefs="TweekApp.cpp.includes.tweek TweekApp.cpp.includes.gen" id="TweekApp.cpp.includes.co">
                     <para>These two headers are typically needed. The first includes the declaration of the Tweek CORBA Manager, and the second is the subject implementation declaration, shown in <xref linkend="CustomSubjectImpl.h.example"/>.</para>
                  </callout>
                  <callout arearefs="TweekApp.cpp.corbamgr.decl" id="TweekApp.cpp.corbamgr.decl.co">
                     <para>In order to use CORBA through Tweek, the CORBA Manager must be created and initialized. Any number of these may be created, but in general, only one is needed per application. Here, we declare an instance of <classname>tweek::CorbaManager</classname> on the stack.</para>
                  </callout>
                  <callout arearefs="TweekApp.cpp.corbamgr.init" id="TweekApp.cpp.corbamgr.init.co">
                     <para>Next, we must initialize the CORBA Manager using the method <methodname>tweek::CorbaManager::init()</methodname>. The first argument provides a unique (ideally) identifier for the local Portable Object Adapter (POA). The second and third arguments are <varname>argc</varname> and <varname>argv</varname> respectively. They come in through the argument list of <function>main()</function> and represent the command-line arguments. Any arguments relevant to ORB initialization are removed from <varname>argv</varname>, and <varname>argc</varname> is decremented accordingly (it is passed by reference).</para>
                  </callout>
                  <callout arearefs="TweekApp.cpp.big-try-catch.try TweekApp.cpp.big-try-catch.catch" id="TweekApp.cpp.big-try-catch.co">
                     <para>To ensure that no exceptions go uncaught, we enclose the bulk of <function>main()</function> in a try/catch block that catches any exception. This is handled by the argument list passed to the catch block, <literal>(...)</literal>. This is the equivalent of catching <classname>java.lang.Exception</classname> in Java.</para>
                  </callout>
               </calloutlist>
            </example>
         </section>
         <section>
            <title>Using the Subject Manager</title>
            <indexterm>
               <primary>Subject Manager</primary>
               <secondary>use of</secondary>
            </indexterm>
            <para>To demonstrate use of the Subject Manager, we begin by revisiting the <function>main()</function> function examined in the previous section. This time, we will focus our attention on the code related to the Subject Manager only. We will also explain how to use the extended API of the Subject Manager implementation.</para>
            <para>It is important to know that the Subject Manager is a CORBA object that can be accessed by remote code. In the following example, the methods used are defined in the class <classname>tweek::SubjectManagerImpl</classname>, the C++ implementation of the <interfacename>tweek::SubjectManager</interfacename> interface. The details of how the Subject Manager is handled through CORBA are largely irrelevant for most users of Tweek. Simply bear in mind that the Subject Manager is accessibly remotely and that it simplifies the use of CORBA in general.</para>
            <section>
               <title>Subject Manager Initialization</title>
               <para>In order to use the Tweek Subject Manager, it must be initialized. Each CORBA Manager should have a single Subject Manager associated with it. If not, use of Tweek will be much more difficult because the CORBA Manager and the Subject Manager together hide most of the details relating to the use of CORBA. The following example shows how to initialize the Subject Manager using the CORBA Manager object created earlier.</para>
               <example id="TweekApp.cpp.Subject-Manager.example">
                  <title>TweekApp.cpp</title>
                  <programlisting linenumbering="numbered">#include &lt;vpr/vpr.h&gt;
#include &lt;vpr/Thread/Thread.h&gt;
#include &lt;vpr/Util/Debug.h&gt;
#include &lt;tweek/CORBA/CorbaManager.h&gt;

#include &lt;CustomSubjectImpl.h&gt;


/**
 * This application starts the CORBA server for the C++ side of the test.
 */
int main(int argc, char* argv[])
{
   tweek::CorbaManager mgr;

   // The first thing we have to do is initialize the Tweek CORBA Manager.
   // If this fails, we're out of luck.
   try
   {
      if ( mgr.init("corba_test", argc, argv).success() )
      {
         vpr::ReturnStatus status;

         // Once the CORBA Manager is initialized, we need to create a
         // Subject Manager.  This will hold our CustomSubject object.
         try
         {
            status = mgr.createSubjectManager();                             <co linkends="TweekApp.cpp.subjectmgr.create.co" id="TweekApp.cpp.subjectmgr.create"/>

            // If we were able to create the Subject Manager, now we register
            // our objects with it.
            if ( status.success() )
            {
               // First, create real instances of the C++ object that will
               // be the CORBA servant.  This must be allocated on the heap.
               mymod::CustomubjectImpl* custom_subj =
                  new mymod::CustomSubjectImpl();                            <co linkends="TweekApp.cpp.subject.create.co" id="TweekApp.cpp.subject.create"/>

               // Now we try to register the subject and give it a symbolic,
               // easy-to-remember name.
               try
               {
                  mgr.getSubjectManager()-&gt;registerSubject(custom_subj,
                                                           "CustomSubject"); <co linkends="TweekApp.cpp.subject.register.co" id="TweekApp.cpp.subject.register"/>
               }
               catch (...)
               {
                  vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
                     &lt;&lt; "Failed to register subject\n" &lt;&lt; vprDEBUG_FLUSH;
               }
            }
         }
         catch (CORBA::Exception&amp; ex)
         {
            vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
               &lt;&lt; "Caught an unknown CORBA exception when trying to register!\n"
               &lt;&lt; vprDEBUG_FLUSH;
         }

         if ( ! status.success() )
         {
            vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
               &lt;&lt; "Failed to register Subject Manager instance\n"
               &lt;&lt; vprDEBUG_FLUSH;
         }

         std::cout &lt;&lt; "Press 'x' to exit" &lt;&lt; std::endl;
         char input;

         // Loop forever so that we can act sort of like a server.
         while ( 1 )                                                         <co linkends="TweekApp.cpp.loop.co" id="TweekApp.cpp.loop"/>
         {
            std::cin &gt;&gt; input;
            if ( input == 'x' )
            {
               break;
            }
            else
            {
               vpr::System::msleep(100);
            }
         }
      }
      else
      {
         vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
            &lt;&lt; "CORBA failed to initialize\n" &lt;&lt; vprDEBUG_FLUSH;
      }
   }
   catch (...)
   {
      vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
         &lt;&lt; "Caught an unknown exception!\n" &lt;&lt; vprDEBUG_FLUSH;
   }

   vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL) &lt;&lt; "Exiting\n" &lt;&lt; vprDEBUG_FLUSH;

   return 0;
}</programlisting>
                  <calloutlist>
                     <callout arearefs="TweekApp.cpp.subjectmgr.create" id="TweekApp.cpp.subjectmgr.create.co">
                        <para>After the COBRA Manager has been initialized successfully, the Tweek Subject Manager must be created. We do this by invoking the method <methodname>tweek::CorbaManager::createSubjectManager()</methodname> on our <methodname>tweek::CorbaManager</methodname> instance.</para>
                     </callout>
                     <callout arearefs="TweekApp.cpp.subject.create" id="TweekApp.cpp.subject.create.co">
                        <para>Once we have a valid Subject Manager, we must register subjects with it in order for object references to be passed out by CORBA. This creates the <glossterm linkend="gloss.servant">servant</glossterm> to which <interfacename>mymod::CustomSubject</interfacename> references will be made.</para>
                     </callout>
                     <callout arearefs="TweekApp.cpp.subject.register" id="TweekApp.cpp.subject.register.co">
                        <para>Once the servant is created, it is registered with the Subject Manager. The Subject Manager will activate the servant within the POA so that references to it can be created and returned to clients. We register it with the symbolic name <quote>CustomSubject</quote> that can be referenced later by remote objects.</para>
                     </callout>
                     <callout arearefs="TweekApp.cpp.loop" id="TweekApp.cpp.loop.co">
                        <para>After the subject is registered, all the work is done. This simple application now just waits for clients to request references. It will exit when the user enters '<literal>x</literal>'.</para>
                     </callout>
                  </calloutlist>
               </example>
               <para>Note that all the code relating to the Subject Manager is enclosed within another try/catch block. This block only catches exceptions of type <classname>CORBA::Exception</classname>. Anything more general is caught by the larger try/catch block.</para>
            </section>
            <section>
               <title>tweek::SubjectManagerImpl API</title>
               <para>The class <classname>tweek::SubjectManagerImpl</classname> has some methods that are not part of the IDL-specified interface. One such method is <methodname>registerSubject()</methodname>, which was used in the preceding example. Some other methods that may be of interest to users are described in the following subsections.</para>
               <section>
                  <title><methodname>setApplicationName()</methodname></title>
                  <indexterm>
                     <primary>tweek::SubjectManagerImpl</primary>
                     <secondary>setApplicationName() method</secondary>
                  </indexterm>
                  <methodsynopsis>
                     <modifier>public</modifier>
                     <type>void</type>
                     <methodname>setApplicationName</methodname>
                     <methodparam>
                        <type>const std::string&amp;</type>
                        <parameter>appName</parameter>
                     </methodparam>
                  </methodsynopsis>
                  <para>This method can be used to set one of the application-specific identifiers within the Subject Manager. Namely, it sets the application name identifier. These identifiers are used to aid users in choosing a Subject Manager instance when making remote connections to applications.</para>
               </section>
               <section>
                  <title><methodname>setUserName()</methodname></title>
                  <indexterm>
                     <primary>tweek::SubjectManagerImpl</primary>
                     <secondary>setUserName() method</secondary>
                  </indexterm>
                  <methodsynopsis>
                     <modifier>public</modifier>
                     <type>void</type>
                     <methodname>setUserName</methodname>
                     <methodparam>
                        <type>const std::string&amp;</type>
                        <parameter>userName</parameter>
                     </methodparam>
                  </methodsynopsis>
                  <para>Similar to <methodname>setApplicationName()</methodname>, this method allows users to tell the Subject Manager their user name. When multiple users are all running the same application (and are thus using the same parameter to <methodname>setApplicationName()</methodname>), this provides another level of uniqueness. If this method is not used, the Subject Manager will try to get the user name through the <envar>$USER</envar> environment variable.</para>
               </section>
               <section>
                  <title><methodname>addInfoItem()</methodname></title>
                  <indexterm>
                     <primary>tweek::SubjectManagerImpl</primary>
                     <secondary>addInfoItem() method</secondary>
                  </indexterm>
                  <methodsynopsis>
                     <modifier>public</modifier>
                     <type>void</type>
                     <methodname>addInfoItem</methodname>
                     <methodparam>
                        <type>const std::string&amp;</type>
                        <parameter>key</parameter>
                     </methodparam>
                     <methodparam>
                        <type>const std::string&amp;</type>
                        <parameter>value</parameter>
                     </methodparam>
                  </methodsynopsis>
                  <para>If the previous two built-in Subject Manager identifiers are not enough, the method <methodname>addInfoItem()</methodname> allows users to define their own unique identifiers. The first parameter is the identifier, and the second is its (ideally) unique value. Users are free to add any key/value pairs they need in order to aid in the selection of a Subject Manager at runtime.</para>
               </section>
            </section>
         </section>
      </chapter>
      <chapter id="prog.java.chapter">
         <title>Java</title>
         <indexterm>
            <primary>Java client API</primary>
         </indexterm>
         <para></para>
         <section>
            <title>Java Libraries</title>
            <para>The Tweek Java API is broken up into a collection of Java class libraries, each packaged in a unique JAR file. Programmers can choose the library or libraries they need when writing Java code that uses Tweek. It is possible to write JavaBeans that do not use any of the Tweek Java libraries, but such Beans may not be very full-featured. On the other hand, because the Tweek Java GUI is capable of loading any JavaBean, there is no reason that a fully functional Bean must be written to take advantage of Tweek services and utilities.</para>
            <section id="bean.library.section">
               <title>Bean Library</title>
               <indexterm>
                  <primary>Java libraries</primary>
                  <secondary>Bean</secondary>
               </indexterm>
               <para></para>
            </section>
            <section id="event.library.section">
               <title>Event Library</title>
               <indexterm>
                  <primary>Java libraries</primary>
                  <secondary>Event</secondary>
               </indexterm>
               <para></para>
            </section>
            <section id="gui.library.section">
               <title>GUI Library</title>
               <indexterm>
                  <primary>Java libraries</primary>
                  <secondary>GUI</secondary>
               </indexterm>
               <para></para>
            </section>
            <section id="network.library.section">
               <title>Network Library</title>
               <indexterm>
                  <primary>Java libraries</primary>
                  <secondary>Network</secondary>
               </indexterm>
               <para></para>
            </section>
            <section id="beandelivery.library.section">
               <title>Bean Delivery Library</title>
               <indexterm>
                  <primary>Java libraries</primary>
                  <secondary>Bean Delivery</secondary>
               </indexterm>
               <para>The Bean Delivery Library makes use of the Bean Library and the Network Library to allow JavaBeans to be transferred across the network. More specifically, a remote subject, most likely written in C++, can <quote>push</quote> JavaBeans to the Tweek GUI where they can be handled as though they were loaded from the local disk.</para>
            </section>
         </section>
      </chapter>
      <chapter id="prog.all.chapter">
         <title>Putting It All Together</title>
         <para>Based on the information presented in the previous chapters, we can combine everything into an examples. In this chapter, we present the step-by-step process for using the Tweek Java and C++ APIs.</para>
         <section id="collab.slider.section">
            <title>Collaborative Slider</title>
            <para>In this example, we explain how to develop a simple Tweek interface. The goal is to have a <quote>collaborative</quote> slider in a Java GUI component. The value displayed by the slider is retained by a C++ application so that multiple independent sliders can show the same value. The steps explained here are highly representative of the normal steps to be followed when using the Tweek Java and C++ APIs. The structure of the following sections lays out the order of the steps taken. An example makefile that goes along with the code presented can be found in <xref linkend="SliderSubject.makefile.section"/> of <xref linkend="makefile.appendix"/>. The full source for the examples presented in this section can be found in <filename>$TWEEK_BASE_DIR/share/test/NetworkTestBean</filename>.</para>
            <section>
               <title>The Subject</title>
               <para>To begin, the subject interface must be defined in IDL and implemented in C++. The interface itself will be <quote>compiled</quote> into Java and C++ code. Both ends of the communication channels must know the interface in order for the references to be used, thus requiring the generation of code for both languages.</para>
               <section>
                  <title>Creating the Interface</title>
                  <para>Creating an IDL interface involves writing an IDL file. For this example, we will be storing an integer variable in a C++ servant. The Java GUIs will need to read and write the value, so we need two methods: <methodname>getValue()</methodname> and <methodname>setValue()</methodname>. The type being passed between <glossterm linkend="gloss.orb">ORBs</glossterm> will be <type>long</type>, a 32-bit integer. Depending on the target language, this will map to the corresponding type of the same size.</para>
                  <example id="SliderSubject.idl.example">
                     <title>SliderSubject.idl</title>
                     <programlisting linenumbering="numbered">#ifndef _NETWORK_TEST_SLIDER_SUBJECT_IDL_    <co linkends="cpp.protection.co" id="cpp.ifndef.line"/>
#define _NETWORK_TEST_SLIDER_SUBJECT_IDL_    <co linkends="cpp.protection.co" id="cpp.define.line"/>

#include &lt;tweek/idl/Subject.idl&gt;             <co linkends="tweek.subject.idl.include.co" id="tweek.subject.idl.include"/>

module networktest                           <co linkends="idl.module.block.co" id="idl.module.block"/>
{
   interface SliderSubject : tweek::Subject  <co linkends="idl.interface.decl.co" id="idl.interface.decl"/>
   {
      void setValue(in long val);            <co linkends="SliderSubject.methods.co" id="SliderSubject.setValue.decl"/>
      long getValue();                       <co linkends="SliderSubject.methods.co" id="SliderSubject.getValue.decl"/>
   };
};

#endif                                       <co linkends="cpp.protection.co" id="cpp.endif.line"/>
</programlisting>
                     <calloutlist>
                        <callout arearefs="cpp.ifndef.line cpp.define.line cpp.endif.line" id="cpp.protection.co">
                           <para>IDL files are run through the C preprocessor so that they may include external files. To prevent including the same source multiple times, the file must be enclosed in the traditional preprocessor protection block. This is exactly what is done in C/C++ header files.</para>
                        </callout>
                        <callout arearefs="tweek.subject.idl.include" id="tweek.subject.idl.include.co">
                           <para>All Tweek subject IDL files must include <filename>tweek/idl/Subject.idl</filename>. This is required so that the interface being defined can inherit from <interfacename>tweek::Subject</interfacename>.</para>
                        </callout>
                        <callout arearefs="idl.module.block" id="idl.module.block.co">
                           <para>Typically, using a module to contain the interface is recommended. Using a module defines a Java package and a C++ namespace (named <literal>networktest</literal> in this case).</para>
                        </callout>
                        <callout arearefs="idl.interface.decl" id="idl.interface.decl.co">
                           <para>The definition of the subject interface must inherit from <interfacename>tweek::Subject</interfacename>. If this is not done, there is no way that the subject interface will plug into the Subject Manager.</para>
                        </callout>
                        <callout arearefs="SliderSubject.setValue.decl SliderSubject.getValue.decl" id="SliderSubject.methods.co">
                           <para>This simple interface has only two functions: <methodname>setValue()</methodname> and <methodname>getValue()</methodname>. The method getValue() takes a single read-only parameter of type <type>long</type>; <methodname>getValue()</methodname> returns a value of the same type.</para>
                        </callout>
                     </calloutlist>
                  </example>
                  <para>The file <filename>SliderSubject.idl</filename> must be <quote>compiled</quote> by an <glossterm linkend="gloss.idl-compiler">IDL compiler</glossterm>. For use with Tweek, the interface must be compiled into Java and C++ code. The generated Java code will be used solely for communicating with CORBA <interfacename>networktest.SliderSubject</interfacename> references. The generated C++ code will be extended to provide an implementation of the <interfacename>networktest::SliderSubject</interfacename> interface. (The implementation will be a CORBA <glossterm linkend="gloss.servant">servant</glossterm> object to which references will be made by remote Java code.)</para>
               </section>
               <section>
                  <title>Implementing the Interface in C++</title>
                  <para>After running an IDL compiler to generate the stub CORBA code, the interface must be implemented. In particular, there will be pure virtual methods in <filename>SliderSubject.h</filename> that must be implemented. The implementing class will be the CORBA <glossterm linkend="gloss.servant">servant</glossterm> holding the actual data visualized in the Java GUI slider.</para>
                  <example id="SliderSubjectImpl.h.example">
                     <title>SliderSubjectImpl.h</title>
                     <programlisting linenumbering="numbered">#ifndef _SLIDER_SUBJECT_IMPL_H_
#define _SLIDER_SUBJECT_IMPL_H_

#include &lt;tweek/tweekConfig.h&gt;

#include &lt;vector&gt;

#include &lt;tweek/CORBA/SubjectImpl.h&gt;                               <co linkends="SliderSubjectImpl.h.includes.co" id="SliderSubjectImpl.h.includes.subjimpl"/>
#include &lt;SliderSubject.h&gt;                                         <co linkends="SliderSubjectImpl.h.include.subj.co" id="SliderSubjectImpl.h.include.subj"/>


namespace networktest                                              <co linkends="SliderSubjectImpl.h.namespace.co" id="SliderSubjectImpl.h.namespace"/>
{

/**
 * This class is an extension to the base Tweek SubjectImpl class.  It uses
 * multiple inheritance with that class and with the generated CORBA class
 * corresponding to the IDL for SliderSubject.
 */
class SliderSubjectImpl : public POA_networktest::SliderSubject,   <co linkends="SliderSubjectImpl.h.class.decl.co" id="SliderSubjectImpl.h.class.decl"/>
                          public tweek::SubjectImpl
{
public:
   SliderSubjectImpl()
      : tweek::SubjectImpl(), mValue(0)
   {
      /* Do nothing. */ ;
   }

   virtual ~SliderSubjectImpl()
   {
      /* Do nothing. */ ;
   }

   /**
    * Sets this subject's internal value.
    */
   virtual void setValue(long value);                              <co linkends="SliderSubjectImpl.h.virtuals.co" id="SliderSubjectImpl.h.setValue"/>

   /**
    * Returns this subject's internal value.
    */
   virtual long getValue();                                        <co linkends="SliderSubjectImpl.h.virtuals.co" id="SliderSubjectImpl.h.getValue"/>

   /**
    * This overriding method is needed so that the correct type is returned
    * when the _this() method is invoked.  Without this method, an object of
    * type tweek::Subject_ptr would be returned.
    *
    * XXX: It may be possible to remove this requirement in the future.
    */  
   networktest::SliderSubject_ptr _this()                          <co linkends="SliderSubjectImpl.h.hack.co" id="SliderSubjectImpl.h.hack"/>
   {
      return POA_networktest::SliderSubject::_this();
   }

private:
   long mValue;   /**&lt; Our value */                                <co linkends="SliderSubjectImpl.h.mValue.co" id="SliderSubjectImpl.h.mValue"/>
};

} // End of networktest namespace


#endif /* _SLIDER_SUBJECT_IMPL_H_ */</programlisting>
                     <calloutlist>
                        <callout arearefs="SliderSubjectImpl.h.includes.subjimpl" id="SliderSubjectImpl.h.includes.co">
                           <para>These files will always be included by implementations of Tweek subject derived classes. The first contains the declaration for the basic Tweek subject implementation. The second contains the C++ code generated from the Tweek <filename>Observer.idl</filename> file.</para>
                        </callout>
                        <callout arearefs="SliderSubjectImpl.h.include.subj" id="SliderSubjectImpl.h.include.subj.co">
                           <para>This header is generated by the IDL compiler from <filename>SliderSubject.idl</filename>. In particular, it defines the class from which <classname>networktest::SliderSubjectImpl</classname> must inherit.</para>
                        </callout>
                        <callout arearefs="SliderSubjectImpl.h.namespace" id="SliderSubjectImpl.h.namespace.co">
                           <para>In <filename>SliderSubject.idl</filename>, shown in <xref linkend="SliderSubject.idl.example"/>, the interface is in the <literal>networktest</literal> module. In the C++ implementation code, the module name corresponds to a namespace.</para>
                        </callout>
                        <callout arearefs="SliderSubjectImpl.h.class.decl" id="SliderSubjectImpl.h.class.decl.co">
                           <para>The interface implementation class must inherit from the IDL-generated class <classname>POA_networktest::SliderSubject</classname> and from <classname>tweek::SubjectImpl</classname>.</para>
                        </callout>
                        <callout arearefs="SliderSubjectImpl.h.setValue SliderSubjectImpl.h.getValue" id="SliderSubjectImpl.h.virtuals.co">
                           <para><classname>POA_networktest::SliderSubject</classname> defines two pure virtual methods that must be implemented. These correspond to the methods in <filename>SliderSubject.idl</filename>.</para>
                        </callout>
                        <callout arearefs="SliderSubjectImpl.h.hack" id="SliderSubjectImpl.h.hack.co">
                           <para>As of this writing, all subject implementations must contain an overriding version of the <methodname>_this()</methodname> method. This is due to the use of multiple inheritance. Note the return type and the <literal>return</literal> statement. These will vary for each subject implementation based on the name of the IDL-defined interface.</para>
                        </callout>
                        <callout arearefs="SliderSubjectImpl.h.mValue" id="SliderSubjectImpl.h.mValue.co">
                           <para>This is the actual value being stored by the C++ servant.</para>
                        </callout>
                     </calloutlist>
                  </example>
                  <para>In <filename>SliderSubjectImpl.h</filename>, the most important parts to note are the use of multiple inheritance, the declarations of the <interfacename>SliderSubject</interfacename> interface methods, and the implementation of <methodname>_this()</methodname>. The implementations of <methodname>setValue()</methodname> and <methodname>getValue()</methodname> are shown next in <xref linkend="SliderSubjectImpl.cpp.example"/>.</para>
                  <example id="SliderSubjectImpl.cpp.example">
                     <title>SliderSubjectImpl.cpp</title>
                     <programlisting linenumbering="numbered">#include &lt;vpr/Util/Debug.h&gt;
#include &lt;SliderSubjectImpl.h&gt;                   <co linkends="SliderSubjectImpl.cpp.inc.co" id="SliderSubjectImpl.cpp.inc"/>


namespace networktest
{

void SliderSubjectImpl::setValue(long value)
{
   mValue = value;                               <co linkends="SliderSubjectImpl.cpp.mValue.assign.co" id="SliderSubjectImpl.cpp.mValue.assign"/>

   // Notify any observers that our value has changed.  This is very
   // important.
   tweek::SubjectImpl::notify();                 <co linkends="SliderSubjectImpl.cpp.notify.co" id="SliderSubjectImpl.cpp.notify"/>
}

long SliderSubjectImpl::getValue()
{
   return mValue;                                <co linkends="SliderSubjectImpl.cpp.mValue.return.co" id="SliderSubjectImpl.cpp.mValue.return"/>
}

} // End networktest namespace</programlisting>
                     <calloutlist>
                        <callout arearefs="SliderSubjectImpl.cpp.inc" id="SliderSubjectImpl.cpp.inc.co">
                           <para>Include the class declaration file, shown in <xref linkend="SliderSubjectImpl.h.example"/>.</para>
                        </callout>
                        <callout arearefs="SliderSubjectImpl.cpp.mValue.assign" id="SliderSubjectImpl.cpp.mValue.assign.co">
                           <para>When invoked, the remote caller will pass a <type>long</type> value, and this saves the result into the servant's storage.</para>
                        </callout>
                        <callout arearefs="SliderSubjectImpl.cpp.notify" id="SliderSubjectImpl.cpp.notify.co">
                           <para>Because the subject's state has been modified, all attached observers must be notified. This is a very important step that must be taken in this method. Note that it invokes the <methodname>notify()</methodname> method of the parent class.</para>
                        </callout>
                        <callout arearefs="SliderSubjectImpl.cpp.mValue.return" id="SliderSubjectImpl.cpp.mValue.return.co">
                           <para>Observers will invoke this method when requesting the current <varname>mValue</varname>.</para>
                        </callout>
                     </calloutlist>
                  </example>
               </section>
            </section>
            <section>
               <title>The Observer</title>
               <para>The observer does not define its own specialized IDL interface. Instead, it makes use of the existing Tweek basic observer (<classname>tweek.ObserverPOA</classname><indexterm>
                     <primary>classes</primary>
                     <secondary>tweek.ObserverPOA</secondary>
                  </indexterm> in Java). The method <methodname>update()</methodname> must be implemented. The remainder of the observer implementation is centered around communication with a <interfacename>SliderSubject</interfacename> object reference. All observer code is written in Java. The only C++ code for observers is part of the Tweek library, and it is generated entirely by the <glossterm linkend="gloss.idl-compiler">IDL compiler</glossterm>.</para>
               <section id="implement.observer.java.section">
                  <title>Implementing the Observer in Java</title>
                  <para>For every subject interface defined in IDL, a corresponding observer class must be written in Java. Without an observer, there is no way for the Java and C++ sides to conduct useful two-way communication. At best, the Java GUI could request a subject reference and manipulate the C++ application through the reference, but the communication would be entirely one-way.</para>
                  <para>In <xref linkend="SliderObserverImpl.java.example"/>, we show the complete Java implementation of an observer corresponding to the <interfacename>tweek::SliderSubject</interfacename> interface defined earlier. (The JavaBean that uses this observer is explained in <xref linkend="slider.subject.bean.section"/>.) The main focus of this observer is to update its contained <classname>JSlider</classname> whenever the state of the corresponding subject changes.</para>
                  <example id="SliderObserverImpl.java.example">
                     <title>SliderObserverImpl.java</title>
                     <programlisting linenumbering="numbered">package networktest;

import javax.swing.DefaultBoundedRangeModel;
import javax.swing.JSlider;
import tweek.*;


/**
 * Implementation of the Observer side of the Tweek Subject/Observer pattern.
 * It must extend tweek.ObserverPOA so that instances of this class can be
 * registered as CORBA servants.  In addition, CORBA references to the
 * servants must be capable of being attached to remote subjects.
 */
public class SliderObserverImpl extends ObserverPOA                  <co linkends="SliderObserverImpl.java.class.decl.co" id="SliderObserverImpl.java.class.decl"/>
{
   public SliderObserverImpl(JSlider slider, SliderSubject subject)  <co linkends="SliderObserverImpl.java.constructor.co" id="SliderObserverImpl.java.constructor"/>
   {
      mSlider        = slider;
      mSliderSubject = subject;
   }

   /**
    * Implements the required method in tweek.ObserverPOA.  The remote subject
    * will invoke this method whenever it is notified of a change.
    */
   public void update()                                              <co linkends="SliderObserverImpl.java.update.co" id="SliderObserverImpl.java.update"/>
   {
      // If we have a valid slider object, we need to update its value to
      // whatever our subject has.
      if ( mSlider != null )
      {
         DefaultBoundedRangeModel model =
            (DefaultBoundedRangeModel) mSlider.getModel();
         model.setValue(mSliderSubject.getValue());                  <co linkends="SliderObserverImpl.java.getValue.co" id="SliderObserverImpl.java.getValue"/>
         mSlider.repaint();
      }
   }

   /**
    * Detaches this observer from our subject.  This is needed when shutting
    * down a CORBA connection.
    */
   public void detach()
   {
      mSliderSubject.detach(this._this());                           <co linkends="SliderObserverImpl.java.detach.co" id="SliderObserverImpl.java.detach"/>
   }

   private SliderSubject mSliderSubject = null;
   private JSlider       mSlider        = null;
}</programlisting>
                     <calloutlist>
                        <callout arearefs="SliderObserverImpl.java.class.decl" id="SliderObserverImpl.java.class.decl.co">
                           <para>As an observer, this class must derive from <classname>tweek.ObserverPOA</classname>. This class is generated by the IDL compiler and is part of the Tweek Network Library (see <xref linkend="network.library.section"/>).</para>
                        </callout>
                        <callout arearefs="SliderObserverImpl.java.constructor" id="SliderObserverImpl.java.constructor.co">
                           <para>The constructor for this observer takes two arguments: a <classname>JSlider</classname> object reference and a <interfacename>networktest.SliderSubject</interfacename> object reference. The observer needs the latter argument so that it can query state information from the subject when notified of state changes. This is part of the subject/observer design pattern <xref linkend="Gam95"/>.</para>
                        </callout>
                        <callout arearefs="SliderObserverImpl.java.update" id="SliderObserverImpl.java.update.co">
                           <para>As stated, all observers must implement <methodname>update()</methodname>. This will be invoked by the remote subject when its <methodname>notify()</methodname> method is invoked.</para>
                        </callout>
                        <callout arearefs="SliderObserverImpl.java.getValue" id="SliderObserverImpl.java.getValue.co">
                           <para>To get the updated state of the remote subject, the encapsulated subject reference's <methodname>getValue()</methodname> method is invoked. The value returned will be the most up-to-date information from the subject.</para>
                        </callout>
                        <callout arearefs="SliderObserverImpl.java.detach" id="SliderObserverImpl.java.detach.co">
                           <para>It may be convenient for the observer to implement a <methodname>detach()</methodname> method (though the name may vary). This is used when the Java application is shutting down to ensure that the remote subject does not have dangling references to observers that no longer exist. The only action required here is invoking the subject's <methodname>detach()</methodname> method to inform the subject that this observer is going away.</para>
                        </callout>
                     </calloutlist>
                  </example>
                  <para>This example demonstrates that observers do not have to be complex to be usable. While this example is purposely simple, it should illustrate that developers of observers do not necessarily have to make their implementations complicated. As will be shown in <xref linkend="slider.subject.bean.section"/>, the JavaBean that uses this observer completes the picture and provides users with a GUI slider that can be manipulated by any number of simultaneous users.</para>
               </section>
            </section>
            <section id="SliderSubject.server.section">
               <title lang="SliderSubject.server.section">The Server Application</title>
               <para>Now that we have the subject and observer ready to go, we can make an application that uses them. The following example is a (relatively) simple C++ application that starts the CORBA Manager<indexterm>
                     <primary>CORBA Manager</primary>
                     <secondary>initialization</secondary>
                     <tertiary>example of</tertiary>
                  </indexterm>, creates the Subject Manager<indexterm>
                     <primary>Subject Manager</primary>
                     <secondary>creation</secondary>
                     <tertiary>example of</tertiary>
                  </indexterm>, registers a <interfacename>networktest::SliderSubject</interfacename> servant, and then waits for the user to press '<literal>x</literal>' to exit. The use of exceptions may appear unfamiliar to some C++ programmers. CORBA makes use of exceptions as a cross-language mechanism to report errors, and thus, there must be proper exception handling code for the application to work correctly.</para>
               <example id="SliderSubjectApp.cpp.example">
                  <title>SliderSubjectApp.cpp</title>
                  <programlisting linenumbering="numbered">#include &lt;tweek/CORBA/CorbaManager.h&gt;                                        <co linkends="SliderSubjectApp.cpp.includes.co" id="SliderSubjectApp.cpp.includes.tweek"/>
#include &lt;vpr/Thread/Thread.h&gt;
#include &lt;vpr/Util/Debug.h&gt;

#include &lt;SliderSubjectImpl.h&gt;                                               <co linkends="SliderSubjectApp.cpp.includes.co" id="SliderSubjectApp.cpp.includes.gen"/>


/**
 * This application starts the CORBA server for the C++ side of the test.
 */
int main(int argc, char* argv[])
{
   tweek::CorbaManager mgr;                                                  <co linkends="SliderSubjectApp.cpp.corbamgr.co" id="SliderSubjectApp.cpp.corbamgr.decl"/>

   // The first thing we have to do is initialize the Tweek CORBA Manager.
   // If this fails, we're out of luck.
   try
   {
      if ( mgr.init("corba_test", argc, argv).success() )                    <co linkends="SliderSubjectApp.cpp.corbamgr.co" id="SliderSubjectApp.cpp.corbamgr.init"/>
      {
         vpr::ReturnStatus status;

         // Once the CORBA Manager is initialized, we need to create a
         // Subject Manager.  This will hold our SliderSubject object.
         try
         {
            status = mgr.createSubjectManager();                             <co linkends="SliderSubjectApp.cpp.subjectmgr.create.co" id="SliderSubjectApp.cpp.subjectmgr.create"/>

            // If we were able to create the Subject Manager, now we register
            // our objects with it.
            if ( status.success() )
            {
               // First, create real instances of the C++ object that will
               // be the CORBA servant.  This must be allocated on the heap.
               networktest::SliderSubjectImpl* slider_subj =
                  new networktest::SliderSubjectImpl();                      <co linkends="SliderSubjectApp.cpp.subject.create.co" id="SliderSubjectApp.cpp.subject.create"/>

               // Now we try to register the subject and give it a symbolic,
               // easy-to-remember name.
               try
               {
                  mgr.getSubjectManager()-&gt;registerSubject(slider_subj,
                                                           "SliderSubject"); <co linkends="SliderSubjectApp.cpp.subject.register.co" id="SliderSubjectApp.cpp.subject.register"/>
               }
               catch (...)
               {
                  vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
                     &lt;&lt; "Failed to register subject\n" &lt;&lt; vprDEBUG_FLUSH;
               }
            }
         }
         catch (CORBA::Exception&amp; ex)
         {
            vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
               &lt;&lt; "Caught an unknown CORBA exception when trying to register!\n"
               &lt;&lt; vprDEBUG_FLUSH;
         }

         if ( ! status.success() )
         {
            vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
               &lt;&lt; "Failed to register Subject Manager instance\n"
               &lt;&lt; vprDEBUG_FLUSH;
         }

         std::cout &lt;&lt; "Press 'x' to exit" &lt;&lt; std::endl;
         char input;

         // Loop forever so that we can act sort of like a server.
         while ( 1 )                                                         <co linkends="SliderSubjectApp.cpp.loop.co" id="SliderSubjectApp.cpp.loop"/>
         {
            std::cin &gt;&gt; input;
            if ( input == 'x' )
            {
               break;
            }
            else
            {
               vpr::System::msleep(100);
            }
         }
      }
      else
      {
         vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
            &lt;&lt; "CORBA failed to initialize\n" &lt;&lt; vprDEBUG_FLUSH;
      }
   }
   catch (...)
   {
      vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
         &lt;&lt; "Caught an unknown exception!\n" &lt;&lt; vprDEBUG_FLUSH;
   }

   vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL) &lt;&lt; "Exiting\n" &lt;&lt; vprDEBUG_FLUSH;

   return 0;
}</programlisting>
                  <calloutlist>
                     <callout arearefs="SliderSubjectApp.cpp.includes.tweek SliderSubjectApp.cpp.includes.gen" id="SliderSubjectApp.cpp.includes.co">
                        <para>These two headers are typically needed. The first includes the declaration of the Tweek CORBA Manager, and the second is the subject implementation declaration, shown in <xref linkend="SliderSubjectImpl.h.example"/>.</para>
                     </callout>
                     <callout arearefs="SliderSubjectApp.cpp.corbamgr.decl SliderSubjectApp.cpp.corbamgr.init" id="SliderSubjectApp.cpp.corbamgr.co">
                        <para>In order to use CORBA through Tweek, the CORBA Manager must be created and initialized. Any number of these may be created, but in general, only one is needed per application</para>
                     </callout>
                     <callout arearefs="SliderSubjectApp.cpp.subjectmgr.create" id="SliderSubjectApp.cpp.subjectmgr.create.co">
                        <para>After the COBRA Manager has been initialized successfully, the Tweek Subject Manager must be created.</para>
                     </callout>
                     <callout arearefs="SliderSubjectApp.cpp.subject.create" id="SliderSubjectApp.cpp.subject.create.co">
                        <para>Once we have a valid Subject Manager, we must register subjects with it in order for object references to be passed out by CORBA. This creates the <glossterm linkend="gloss.servant">servant</glossterm> to which <interfacename>networktest::SliderSubject</interfacename> references will be made.</para>
                     </callout>
                     <callout arearefs="SliderSubjectApp.cpp.subject.register" id="SliderSubjectApp.cpp.subject.register.co">
                        <para>Once the servant is created, it is registered with the Subject Manager. The Subject Manager will activate the servant within the POA so that references to it can be created and returned to clients.</para>
                     </callout>
                     <callout arearefs="SliderSubjectApp.cpp.loop" id="SliderSubjectApp.cpp.loop.co">
                        <para>After the subject is registered, all the work is done. This application now just waits for clients to request references. It will exit when the user enters '<literal>x</literal>'.</para>
                     </callout>
                  </calloutlist>
               </example>
               <para>The application shown in <xref linkend="SliderSubjectApp.cpp.example"/> is purposely simple. There are many ways to use the CORBA Manager and the Subject Manager. For example, an object registry could be built on top of the Subject Manager so that only specific types of servant objects may be registered. Servant registration could be automated in object constructors. The C++ API is intended to be simple to enhance its usability and flexibility, and the application shown in the example is just that: an example.</para>
            </section>
            <section id="slider.subject.bean.section">
               <title>The JavaBean</title>
               <para>We have finally reached the point at which we implement a JavaBean that can visualize the numeric data held by the C++ slider subject. Such a JavaBean must be defined as a Tweek Panel Bean. (Refer back to <xref linkend="intro.javabeans.chapter"/> if these statements seem unfamiliar or confusing.)</para>
               <para>The JavaBean shown in the following example is typical of one that uses the Tweek Network library to take advantage of CORBA facilities. The code for the Bean is longer than previous examples, and because of this, it will be split into multiple code blocks. Each will be discussed in turn. The full code is in one file: <filename>NetworkTest.java</filename>.</para>
               <para>Please note that the details of setting up the GUI elements used by the Bean are left out. The code in this case was generated by JBuilder and could easily vary from Bean to Bean. For the full code, please refer to the aforementioned locations.</para>
               <section>
                  <title>Imports</title>
                  <para>The slider JavaBean uses common Java Swing classes, a CORBA exception class, the Tweek Event library, the Tweek Network library, and the Java code generated by an IDL compiler. The following explains how each of these are imported into the main Bean class.</para>
                  <programlisting>package networktest;                                       <co linkends="NetworkTest.java.package.co" id="NetworkTest.java.package"/>

import java.awt.*;                                         <co linkends="NetworkTest.java.imports.gui.co" id="NetworkTest.java.imports.gui.awt"/>
import javax.swing.*;                                      <co linkends="NetworkTest.java.imports.gui.co" id="NetworkTest.java.imports.gui.swing"/>
import javax.swing.event.*;                                <co linkends="NetworkTest.java.imports.gui.co" id="NetworkTest.java.imports.gui.swing.event"/>
import org.omg.CORBA.BAD_PARAM;                            <co linkends="NetworkTest.java.imports.corba.co" id="NetworkTest.java.imports.corba"/>
import org.vrjuggler.tweek.event.*;                        <co linkends="NetworkTest.java.imports.tweek.co" id="NetworkTest.java.imports.tweek.event"/>
import org.vrjuggler.tweek.net.*;                          <co linkends="NetworkTest.java.imports.tweek.co" id="NetworkTest.java.imports.tweek.net"/>
import org.vrjuggler.tweek.net.corba.*;                    <co linkends="NetworkTest.java.imports.tweek.co" id="NetworkTest.java.imports.tweek.net.corba"/>
import tweek.*;                                            <co linkends="NetworkTest.java.imports.tweek-gen.co" id="NetworkTest.java.imports.tweek-gen"/>
</programlisting>
                  <calloutlist>
                     <callout arearefs="NetworkTest.java.package" id="NetworkTest.java.package.co">
                        <para>This Bean is in a package corresponding to the IDL module defined in <filename>SliderSubject.idl</filename>. Using a consistent name throughout makes the code easier to manage and understand.</para>
                     </callout>
                     <callout arearefs="NetworkTest.java.imports.gui.awt NetworkTest.java.imports.gui.swing NetworkTest.java.imports.gui.swing.event" id="NetworkTest.java.imports.gui.co">
                        <para>These imports bring in common Swing and AWT GUI classes. Different Beans will use different classes and packages.</para>
                     </callout>
                     <callout arearefs="NetworkTest.java.imports.corba" id="NetworkTest.java.imports.corba.co">
                        <para>In order to do proper narrowing of reference types, the exception <exceptionname>org.omg.CORBA.BAD_PARAM</exceptionname> must be caught.</para>
                     </callout>
                     <callout arearefs="NetworkTest.java.imports.tweek.event NetworkTest.java.imports.tweek.net NetworkTest.java.imports.tweek.net.corba" id="NetworkTest.java.imports.tweek.co">
                        <para>These imports bring in the classes of the Tweek Event and Network libraries.</para>
                     </callout>
                     <callout arearefs="NetworkTest.java.imports.tweek-gen" id="NetworkTest.java.imports.tweek-gen.co">
                        <para>Tweek Java code generated by an IDL compiler will always be in the package <classname>tweek</classname>. This corresponds to the IDL module and to the C++ namespace.</para>
                     </callout>
                  </calloutlist>
               </section>
               <section>
                  <title>Class Declaration</title>
                  <para>Now we can begin writing the Bean code. Besides the class <classname>SliderObserverImpl</classname>, this Bean has only one class: <classname>NetworkTest</classname>. It will provide the GUI representation of the numeric data. The declaration of the class follows.</para>
                  <programlisting>/**
 * This is an example of a JavaBean that Tweek can load dynamically.  It holds
 * a JSlider that acts as an Observer in the Tweek CORBA Subject/Observer
 * pattern implementation.
 *
 * @version 1.0
 */
public class NetworkTest
   extends JPanel                                          <co linkends="NetworkTest.java.superclass.co" id="NetworkTest.java.superclass"/>
   implements CommunicationListener, TweekFrameListener    <co linkends="NetworkTest.java.interfaces.co" id="NetworkTest.java.interfaces"/>
{
...
}</programlisting>
                  <calloutlist>
                     <callout arearefs="NetworkTest.java.superclass" id="NetworkTest.java.superclass.co">
                        <para>As a Tweek Panel Bean, there must be a class that derives from <classname>javax.swing.JComponent</classname> or some subclass thereof. In this case, the superclass is <classname>javax.swing.JPanel</classname>.</para>
                     </callout>
                     <callout arearefs="NetworkTest.java.interfaces" id="NetworkTest.java.interfaces.co">
                        <para>Since this Bean needs to access the remote Subject Manager, it needs to know when a CORBA service is available. By implementing <interfacename>org.vrjuggler.tweek.net.CommunicationListener</interfacename>, the Bean will be informed by the Tweek Java GUI whenever the communication state with a CORBA service changes. This Bean also listens for <classname>TweekFrameEvents</classname> so that it can shut itself down cleanly. To be informed of such events, it must implement <interfacename>org.vrjuggler.tweek.event.TweekFrameListener</interfacename>.</para>
                     </callout>
                  </calloutlist>
               </section>
               <section>
                  <title>Member Variables</title>
                  <para>Before delving into the methods of the <classname>networktest.NetworkTest</classname> class, it will be helpful to review the member variables used throughout the class. Refer back to this section if there is any confusion regarding the use or the type of some member variable in the method implementations.</para>
                  <programlisting>private BorderLayout mBeanLayout = new BorderLayout();     <co linkends="NetworkTest.java.members.layout.co" id="NetworkTest.java.members.layout"/>

private JPanel mSliderPanel = new JPanel();                <co linkends="NetworkTest.java.members.slider-group.co" id="NetworkTest.java.members.slider-group.panel"/>
private JSlider mDataSlider = new JSlider();               <co linkends="NetworkTest.java.members.slider-group.co" id="NetworkTest.java.members.slider-group.slider"/>

private SliderObserverImpl mSliderObserver = null;         <co linkends="NetworkTest.java.members.observer.co" id="NetworkTest.java.members.observer"/>
</programlisting>
                  <calloutlist>
                     <callout arearefs="NetworkTest.java.members.layout" id="NetworkTest.java.members.layout.co">
                        <para>This is the containing layout for the entire Bean.</para>
                     </callout>
                     <callout arearefs="NetworkTest.java.members.slider-group.panel NetworkTest.java.members.slider-group.slider" id="NetworkTest.java.members.slider-group.co">
                        <para>The <classname>JSlider</classname> used for visually representing the subject's numeric data is <varname>mDataSlider</varname>, and it will be contained within <varname>mSliderPanel</varname>.</para>
                     </callout>
                     <callout arearefs="NetworkTest.java.members.observer" id="NetworkTest.java.members.observer.co">
                        <para>The <interfacename>networktest::SliderSubject</interfacename> observer will be stored within <varname>mSliderObserver</varname>.</para>
                     </callout>
                  </calloutlist>
                  <para>Note that the observer is stored in a member variable initialized to <symbol>null</symbol>. It will be assigned a value when a CORBA service becomes available and the corresponding subject can be requested. The object itself is stored as a member variable so that it can be accessed by all the methods of the class.</para>
               </section>
               <section>
                  <title>Handling CORBA Communications</title>
                  <para>The most complex part of this Bean is the handling of CORBA communication events delivered by the Tweek GUI. All of the handling in this example will be done in the methods <methodname>connectionOpened()</methodname> and <methodname>connectionClosed()</methodname>. The steps that must be followed are straightforward, but there are errors that must be handled properly. It is the error handling that can make the code look daunting, not the use of the Tweek Network library.</para>
                  <programlisting linenumbering="numbered">/**
 * Implements the Tweek CommunicationListener interface needed for being
 * informed of new connections with remote ORBs.
 */
public void connectionOpened(CommunicationEvent e)                        <co linkends="NetworkTest.java.connect.co" id="NetworkTest.java.connect"/>
{
   // The first thing to do is get the CORBA service object from the
   // event.  We need this so we know to whom we are are connecting.  Once
   // we have the CORBA service, we get its Subject Manager since that's
   // what contains the actual subjects we need.
   CorbaService corba_service = e.getCorbaService();                      <co linkends="NetworkTest.java.corba.co" id="NetworkTest.java.corba.service"/>
   SubjectManager mgr         = corba_service.getSubjectManager();        <co linkends="NetworkTest.java.corba.co" id="NetworkTest.java.corba.subjectmgr"/>

   Subject subject = mgr.getSubject("SliderSubject");                     <co linkends="NetworkTest.java.getSubject.co" id="NetworkTest.java.getSubject"/>
   SliderSubject slider_subject = null;

   // Try to narrow the Subject object to a SliderSubject object.  If this
   // fails, it throws a CORBA BAD_PARAM exception.  In that case, we open
   // a dialog box saying that the narrowing failed.
   try
   {
      slider_subject = SliderSubjectHelper.narrow(subject);               <co linkends="NetworkTest.java.narrow.co" id="NetworkTest.java.narrow-subject"/>
   }
   catch (BAD_PARAM narrow_ex)                                            <co linkends="NetworkTest.java.narrow.co" id="NetworkTest.java.narrow-exception"/>
   {
      JOptionPane.showMessageDialog(null,
                                    "Failed to narrow subject to SliderSubject",
                                    "SliderSubject Narrow Error",
                                    JOptionPane.ERROR_MESSAGE);
   }

   // Ensure that slider_subject is a valid object just to be safe.
   if ( slider_subject != null )
   {
      // First, we need a Java object that implements the Observer.  That
      // object must be registered with the Java CORBA service.
      m_slider_observer = new SliderObserverImpl(mDataSlider,
                                                 slider_subject);         <co linkends="NetworkTest.java.observer.create.co" id="NetworkTest.java.observer.create"/>
      corba_service.registerObject(mSliderObserver, "SliderObserver");    <co linkends="NetworkTest.java.observer.register.co" id="NetworkTest.java.observer.register"/>

      // Now that the observer is registered, we can attach it to the
      // subject.  The subject needs to know who its observers are so
      // that it can notify them of updates.
      slider_subject.attach(mSliderObserver._this());                     <co linkends="NetworkTest.java.observer.attach.co" id="NetworkTest.java.observer.attach"/>

      // Now we set the slider in our GUI to be whatever value the
      // remote subject is holding for us.
      mDataSlider.setValue(slider_subject.getValue());                    <co linkends="NetworkTest.java.setValue.co" id="NetworkTest.java.setValue"/>
      mDataSlider.addChangeListener(
         new SliderChangeListener(slider_subject)
      );                                                                  <co linkends="NetworkTest.java.addChangeListener.co" id="NetworkTest.java.addChangeListener"/>
   }
}

/**
 * Implements the Tweek CommunicationListener interface needed for being
 * informed when existing ORB connections are closed.
 */
public void connectionClosed(ConnectEvent e)                              <co linkends="NetworkTest.java.shutdown.co" id="NetworkTest.java.disconnect"/>
{
   if ( slider_subject != null )
   {
      if ( mSliderObserver != null )
      {
         mSliderObserver.detach();                                        <co linkends="NetworkTest.java.shutdown.co" id="NetworkTest.java.observer.detach"/>
         mSliderObserver = null;
      }
   }
}</programlisting>
                  <calloutlist>
                     <callout arearefs="NetworkTest.java.connect" id="NetworkTest.java.connect.co">
                        <para>If the event delivered to the Bean is a newly opened connection, there is a new CORBA service available, so we will create a new observer to communicate through that service.</para>
                     </callout>
                     <callout arearefs="NetworkTest.java.corba.service NetworkTest.java.corba.subjectmgr" id="NetworkTest.java.corba.co">
                        <para>The first step that must be taken is retrieving the <classname>org.vrjuggler.tweek.net.corba.CorbaService</classname> object from the event. This is needed as the basis for all further actions. With the CORBA service reference, we can request the Subject Manager reference. The result is a CORBA reference to the remote Subject Manager, a servant within the C++ application.</para>
                     </callout>
                     <callout arearefs="NetworkTest.java.getSubject" id="NetworkTest.java.getSubject.co">
                        <para>Through the Subject Manager, we request subjects using symbolic names. In this case, we request the subject with the hard-coded name <quote>SliderSbuject</quote>.</para>
                     </callout>
                     <callout arearefs="NetworkTest.java.narrow-subject NetworkTest.java.narrow-exception" id="NetworkTest.java.narrow.co">
                        <para>The call to <methodname>getSubject()</methodname> returns a reference of type <interfacename>tweek.Subject</interfacename>, but we need to narrow it to <interfacename>networktest.SliderSubject</interfacename> so we can use it. Among the code generated by the IDL compiler is a class named <classname>networktest.SliderSubjectHelper</classname>. Its <methodname>narrow()</methodname> method is used to narrow the CORBA reference type to a more specific type. If the narrowing fails, an exception of type <exceptionname>org.omg.CORBA.BAD_PARAM</exceptionname> is thrown, and it is best to handle it here.</para>
                     </callout>
                     <callout arearefs="NetworkTest.java.observer.create" id="NetworkTest.java.observer.create.co">
                        <para>Once we have the subject reference, we create an observer servant that we will attach to the subject. This is where <classname>networktest.SliderObserverImpl</classname> comes into the picture.</para>
                     </callout>
                     <callout arearefs="NetworkTest.java.observer.register" id="NetworkTest.java.observer.register.co">
                        <para>The observer servant must be registered with the local CORBA service so that references to it can be created. This single statement takes care of all the POA activation behind the scenes.</para>
                     </callout>
                     <callout arearefs="NetworkTest.java.observer.attach" id="NetworkTest.java.observer.attach.co">
                        <para>Now that the servant is registered with the CORBA service, a reference to it can be passed to the remote subject in order to attach the observer to the subject.</para>
                     </callout>
                     <callout arearefs="NetworkTest.java.setValue" id="NetworkTest.java.setValue.co">
                        <para>Once the initial references are passed around, we need to update the GUI slider to the current value held by the subject.</para>
                     </callout>
                     <callout arearefs="NetworkTest.java.addChangeListener" id="NetworkTest.java.addChangeListener.co">
                        <para>As part of the collaborative slider, we need to register a change listener with the GUI slider so that it will be informed of changes made by the local user. These changes are reported to the remote subject so that other users get the update. The class <classname>SliderChangeListener</classname> is shown later.</para>
                     </callout>
                     <callout arearefs="NetworkTest.java.disconnect NetworkTest.java.observer.detach" id="NetworkTest.java.shutdown.co">
                        <para>If the event delivered to the Bean was the closing of an existing connection, the CORBA service is being shut down. When the CORBA service is shut down, we need to detach the local observer from the remote subject to prevent further update notification attempts for this observer.</para>
                     </callout>
                  </calloutlist>
                  <para>It is important to note that the use of hard-coded subject names is not recommended. In this example, the subject name is hard-coded for simplicity. The Tweek Subject Manager allows accessing code to request a list of all registered subjects. Using this information, it is possible to present the Java GUI user with a list of subjects from which they can make a selection.</para>
               </section>
               <section>
                  <title>Handling Frame Events</title>
                  <para>This Bean makes an effort to shut down open CORBA connections when the Tweek GUI is closed. It does this by implementing <interfacename>org.vrjuggler.tweek.event.TweekFrameListener</interfacename> which has a single method, <methodname>frameStateChanged()</methodname>.</para>
                  <programlisting>public void frameStateChanged(TweekFrameEvent e)
{
   if ( e.getType() == TweekFrameEvent.FRAME_CLOSE )            <co linkends="NetworkTest.java.frame.close.co" id="NetworkTest.java.frame.close"/>
   {
      if ( mSliderObserver != null )
      {
         mSliderObserver.detach();                              <co linkends="NetworkTest.java.frame.detach.co" id="NetworkTest.java.frame.detach"/>
         mSliderObserver = null;
      }
   }
}</programlisting>
                  <calloutlist>
                     <callout arearefs="NetworkTest.java.frame.close" id="NetworkTest.java.frame.close.co">
                        <para>If the event is the closing of the Tweek GUI frame, the CORBA reference clean-up steps will be taken.</para>
                     </callout>
                     <callout arearefs="NetworkTest.java.frame.detach" id="NetworkTest.java.frame.detach.co">
                        <para>If the slider observer is defined, we assume that the observer is attached. The handy <methodname>detach()</methodname> method is invoked to detach this observer from the remote subject.</para>
                     </callout>
                  </calloutlist>
               </section>
               <section>
                  <title>Handling Local Slider Change Events</title>
                  <para>A helper class is used to handle local change events in the slider. The class is a private inner class within the Bean and is defined as follows:</para>
                  <programlisting>private class SliderChangeListener implements ChangeListener
{
   public SliderChangeListener(SliderSubject subject)
   {
      mSliderSubject = subject;
   }

   public void stateChanged(javax.swing.event.ChangeEvent e)
   {
      JSlider source = (JSlider) e.getSource();

      if ( ! source.getValueIsAdjusting() )                     <co linkends="NetworkTest.java.SliderChangeListener.stateChanged.co" id="NetworkTest.java.SliderChangeListener.stateChanged.adjust"/>
      {
         mSliderSubject.setValue(source.getValue());            <co linkends="NetworkTest.java.SliderChangeListener.stateChanged.co" id="NetworkTest.java.SliderChangeListener.stateChanged.setValue"/>
      }
   }

   private SliderSubject mSliderSubject = null;
}</programlisting>
                  <calloutlist>
                     <callout arearefs="NetworkTest.java.SliderChangeListener.stateChanged.adjust NetworkTest.java.SliderChangeListener.stateChanged.setValue" id="NetworkTest.java.SliderChangeListener.stateChanged.co">
                        <para>Within the <methodname>stateChanged()</methodname> method, we check to see if the user is done adjusting the slider. If so, the remote subject is updated so that its internal value matches that of the local slider. Other users are automatically updated when this happens.</para>
                     </callout>
                  </calloutlist>
               </section>
               <section>
                  <title>XML File</title>
                  <para>With the Bean implementation done, the XML file that describes the Bean must be written. All Beans loaded by the Tweek Java GUI are described by an XML file. In <xref linkend="NetworkTestBean.xml.example"/>, we show the XML file for the Bean we have been developing.</para>
                  <example id="NetworkTestBean.xml.example">
                     <title>NetworkTestBean.xml</title>
                     <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;                               <co linkends="NetworkTestBean.xml.version.co" id="NetworkTestBean.xml.version"/>
&lt;beanlist xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"      <co linkends="NetworkTestBean.xml.beanlist.co" id="NetworkTestBean.xml.beanlist"/>
          xsi:noNamespaceSchemaLocation="http://www.vrjuggler.org/tweek/xsd/1.1/beanlist.xsd"&gt;
  &lt;guipanel name="Network Tester"&gt;                                   <co linkends="NetworkTestBean.xml.guipanel.co" id="NetworkTestBean.xml.guipanel"/>
    &lt;file name="${TWEEK_BASE_DIR}/bin/beans/NetworkTestBean.jar"     <co linkends="NetworkTestBean.xml.file.co" id="NetworkTestBean.xml.file"/>
          class="networktest.NetworkTest" /&gt;
    &lt;tree path="/Beans" /&gt;                                           <co linkends="NetworkTestBean.xml.tree.co" id="NetworkTestBean.xml.tree"/>
  &lt;/guipanel&gt;
&lt;/beanlist&gt;</programlisting>
                     <calloutlist>
                        <callout arearefs="NetworkTestBean.xml.version" id="NetworkTestBean.xml.version.co">
                           <para>Well-formed XML requires this line.</para>
                        </callout>
                        <callout arearefs="NetworkTestBean.xml.beanlist" id="NetworkTestBean.xml.beanlist.co">
                           <para>Tweek XML Bean files are <sgmltag>beanlist</sgmltag> documents. There must be exactly one <sgmltag>beanlist</sgmltag> per file, but the list itself can contain multiple Beans. In this element, we also provide the information needed to validate this document using the XML Schema <filename>beanlist.xsd</filename>. In this case, we use the schema that does not employ XML namespaces. Use of the schema for validation is optional, but it is recommended.</para>
                        </callout>
                        <callout arearefs="NetworkTestBean.xml.guipanel" id="NetworkTestBean.xml.guipanel.co">
                           <para>The Bean we have been developing is a GUI Panel Bean, and this indicates that fact.</para>
                        </callout>
                        <callout arearefs="NetworkTestBean.xml.file" id="NetworkTestBean.xml.file.co">
                           <para>To find the Bean, a path must be specified. In this example, we will put the XML and JAR files in <filename>$TWEEK_BASE_DIR/bin/beans</filename>. Note the use of curly braces around the environment variable. This is required. The class attribute names the class that will be instantiated, and in this case, that is <filename>networktest.NetworkTest</filename>. This name corresponds more to the fully qualified name of the class stored within the JAR file.</para>
                        </callout>
                        <callout arearefs="NetworkTestBean.xml.tree" id="NetworkTestBean.xml.tree.co">
                           <para>Panel Beans are loaded into a tree data structure and visualized using a viewer. This specifies the path within the tree using a UNIX-style path. The path is arbitrary and will be constructed as needed when the Bean is loaded.</para>
                        </callout>
                     </calloutlist>
                  </example>
                  <para>After the Bean is compiled into a JAR file, the JAR file and XML file need to be copied into <filename>$TWEEK_BASE_DIR/bin/beans</filename>. This is the default path that Tweek searches for Beans at startup, and it is a convenient place to put this example Bean.</para>
               </section>
            </section>
            <section>
               <title>Running the Example</title>
               <para>With all the coding done and the code compiled, we can run the C++ application and connect multiple instances of the Tweek Java GUI to it. The steps to run the C++ application are as follows:</para>
               <orderedlist>
                  <listitem>
                     <para>Run a CORBA Naming Service. This is required so that the C++ and Java ORBs can resolve symbolic references.</para>
                  </listitem>
                  <listitem>
                     <para>Since Tweek uses omniORB for a C++ ORB (see <xref linkend="orb-impl.appendix"/> for more information on this), the environment variable <envar>$OMNIORB_CONFIG</envar> must be set. This gives the full path to an omniORB configuration file that omniORB will load at runtime.</para>
                  </listitem>
                  <listitem>
                     <para>Run the C++ application.</para>
                  </listitem>
                  <listitem>
                     <para>Run the Tweek Java GUI. This will find and load all the Beans in <filename>$TWEEK_BASE_DIR/bin/beans</filename>.</para>
                  </listitem>
                  <listitem>
                     <para>Within the Java GUI, connect to the CORBA Naming Service started in step 1. The way the Bean is written, it will request the subject held by the C++ application automatically, and the slider will be updated to the current value.</para>
                  </listitem>
               </orderedlist>
            </section>
         </section>
         <section id="file.loader.section">
            <title>File Loader</title>
            <para>Not everything written in Tweek must use Java, C++, IDL, and CORBA. The Tweek Java GUI is a generalized Bean-loading environment, and as such, its main focus is to load JavaBeans and present them to the user. Those Beans may take advantage of CORBA, but they are not required to do so. In this section, we show another sample Bean that is much simpler than the previous example.</para>
            <para>The Bean shown in this example can open and close multiple text files. To do this, the Bean implements the interface <interfacename>org.vrjuggler.tweek.beans.FileLoader</interfacename>. The Java code will be shown in separate pieces to make it easier to understand. The full code is in <filename>$TWEEK_BASE_DIR/share/test/FileOpenTestBean/fileopentestbean/FileOpenTestBean.java</filename>. An example makefile can be found in <xref linkend="FileLoader.makefile.section"/>. within <xref linkend="makefile.appendix"/>..</para>
            <section>
               <title>The JavaBean</title>
               <para>As in the previous example, we focus on the imported classes first. They are as follows:</para>
               <programlisting>package fileopentestbean;                                       <co linkends="FileOpenTestBean.java.package.co" id="FileOpenTestBean.java.package"/>

import java.awt.*;                                              <co linkends="FileOpenTestBean.java.std-imports.co" id="FileOpenTestBean.java.import.awt"/>
import java.io.File;                                            <co linkends="FileOpenTestBean.java.std-imports.co" id="FileOpenTestBean.java.import.io-File"/>
import java.io.FileInputStream;                                 <co linkends="FileOpenTestBean.java.std-imports.co" id="FileOpenTestBean.java.import.io-FileInputStream"/>
import javax.swing.*;                                           <co linkends="FileOpenTestBean.java.std-imports.co" id="FileOpenTestBean.java.import.swing"/>
import org.vrjuggler.tweek.services.ExtensionFileFilter;        <co linkends="FileOpenTestBean.java.import.ext-filter.co" id="FileOpenTestBean.java.import.ext-filter"/>
import org.vrjuggler.tweek.beans.FileLoader;                    <co linkends="FileOpenTestBean.java.import.FileLoader.co" id="FileOpenTestBean.java.import.FileLoader"/>
</programlisting>
               <calloutlist>
                  <callout arearefs="FileOpenTestBean.java.package" id="FileOpenTestBean.java.package.co">
                     <para>This Bean will be in the package <literal>fileopentestbean</literal>.</para>
                  </callout>
                  <callout arearefs="FileOpenTestBean.java.import.awt FileOpenTestBean.java.import.io-File FileOpenTestBean.java.import.io-FileInputStream FileOpenTestBean.java.import.swing" id="FileOpenTestBean.java.std-imports.co">
                     <para>These are the imports of standard Java classes. In this Bean, we need two Java file I/O classes so that we may load files.</para>
                  </callout>
                  <callout arearefs="FileOpenTestBean.java.import.ext-filter" id="FileOpenTestBean.java.import.ext-filter.co">
                     <para>This line imports the Tweek Service Bean known as the <classname>ExtensionFileFilter</classname>. This provides a simplified mechanism for making file filters typically used with <classname>JFileChooser</classname> instances.</para>
                  </callout>
                  <callout arearefs="FileOpenTestBean.java.import.FileLoader" id="FileOpenTestBean.java.import.FileLoader.co">
                     <para>This line imports the interface from the Tweek Bean library that we will implement.</para>
                  </callout>
               </calloutlist>
               <para>Next, we show the class declaration and the member variables.</para>
               <programlisting>public class FileOpenTestBean extends JPanel                              <co linkends="FileOpenTestBean.java.superclass.co" id="FileOpenTestBean.java.superclass"/>
                              implements java.io.Serializable, FileLoader <co linkends="FileOpenTestBean.java.interfaces.co" id="FileOpenTestBean.java.interfaces"/>
{
   // Methods ...

   private int openFileCount = 0;                                         <co linkends="FileOpenTestBean.java.openFileCount.co" id="FileOpenTestBean.java.openFileCount"/>

   private BorderLayout mMainLayout    = new BorderLayout();
   private JLabel       mBeanTitle     = new JLabel();
   private JTabbedPane  mTextContainer = new JTabbedPane();               <co linkends="FileOpenTestBean.java.mTextContainer.co" id="FileOpenTestBean.java.mTextContainer"/>
}</programlisting>
               <calloutlist>
                  <callout arearefs="FileOpenTestBean.java.superclass" id="FileOpenTestBean.java.superclass.co">
                     <para>As the primary class for a Panel Bean, this class must from <classname>javax.swing.JComponent</classname> or some subclass thereof. In this case, the class will be <classname>javax.swing.JPanel</classname>.</para>
                  </callout>
                  <callout arearefs="FileOpenTestBean.java.interfaces" id="FileOpenTestBean.java.interfaces.co">
                     <para>JavaBeans are expected to implement <interfacename>java.io.Serializable</interfacename>, and this class does that. The more interesting interface for this example is <interfacename>org.vrjuggler.tweek.beans.FileLoader</interfacename>. By implementing this interface, the Tweek Java GUI will know that this Bean can manage files.</para>
                  </callout>
                  <callout arearefs="FileOpenTestBean.java.openFileCount" id="FileOpenTestBean.java.openFileCount.co">
                     <para>This is a property of the class that keeps track of the number of currently open files.</para>
                  </callout>
                  <callout arearefs="FileOpenTestBean.java.mTextContainer" id="FileOpenTestBean.java.mTextContainer.co">
                     <para>This Bean is capable of opening multiple files, and it will manage them with a <classname>JTabbedPane</classname>.</para>
                  </callout>
               </calloutlist>
               <para>Now that we have the basics for the class, we can start implementing the <interfacename>FileLoader</interfacename> interface. Of the methods that must be implemented, the most complex is <methodname>openRequested()</methodname>. It will be shown last because of its length. We will begin instead with the simplest methods.</para>
               <programlisting linenumbering="numbered">public String getFileType()
{
   return "Text";                                                    <co linkends="FileOpenTestBean.java.getFileType.co" id="FileOpenTestBean.java.getFileType"/>
}

public boolean canOpenMultiple()
{
   return true;                                                      <co linkends="FileOpenTestBean.java.canOpenMultiple.co" id="FileOpenTestBean.java.canOpenMultiple"/>
}

public boolean canSave()
{
   return false;                                                     <co linkends="FileOpenTestBean.java.canSave.co" id="FileOpenTestBean.java.canSave"/>
}

public boolean saveRequested()
{
   return false;                                                     <co linkends="FileOpenTestBean.java.saveRequested.co" id="FileOpenTestBean.java.saveRequested"/>
}

public boolean closeRequested()
{
   mTextContainer.remove(mTextContainer.getSelectedComponent());     <co linkends="FileOpenTestBean.java.closeRequested.co" id="FileOpenTestBean.java.closeRequested"/>
   openFileCount--;
   return true;
}

public int getOpenFileCount ()
{
   return openFileCount;                                             <co linkends="FileOpenTestBean.java.getOpenFileCount.co" id="FileOpenTestBean.java.getOpenFileCount"/>
}</programlisting>
               <calloutlist>
                  <callout arearefs="FileOpenTestBean.java.getFileType" id="FileOpenTestBean.java.getFileType.co">
                     <para>This returns the type of file (or files) that can be loaded by the Bean. In this case, we are just loading plain text files.</para>
                  </callout>
                  <callout arearefs="FileOpenTestBean.java.canOpenMultiple" id="FileOpenTestBean.java.canOpenMultiple.co">
                     <para>This method is used to determine if the Bean can open multiple files at one time. This Bean can because of its tabbed pane.</para>
                  </callout>
                  <callout arearefs="FileOpenTestBean.java.canSave" id="FileOpenTestBean.java.canSave.co">
                     <para>This method is used to determine if the Bean can save files, and this Bean does not.</para>
                  </callout>
                  <callout arearefs="FileOpenTestBean.java.saveRequested" id="FileOpenTestBean.java.saveRequested.co">
                     <para>Because this Bean does not save files, it simply returns <constant>false</constant> if a save is requested.</para>
                  </callout>
                  <callout arearefs="FileOpenTestBean.java.closeRequested" id="FileOpenTestBean.java.closeRequested.co">
                     <para>When a close is requested, the currently selected tab is removed and the open file count is decremented.</para>
                  </callout>
                  <callout arearefs="FileOpenTestBean.java.getOpenFileCount" id="FileOpenTestBean.java.getOpenFileCount.co">
                     <para>This simply returns the number of currently open files.</para>
                  </callout>
               </calloutlist>
               <para>The above are all the methods of the <interfacename>FileLoader</interfacename> interface except <methodname>openRequested()</methodname>. We are now ready to move on to it.</para>
               <programlisting linenumbering="numbered">public boolean openRequested()
{
   // Initialize this to false since a lot of things can go wrong in the
   // process of opening files.  Once the file is opened and read
   // successfully, this can be changed to true.
   boolean opened = false;

   JFileChooser chooser = new JFileChooser();                             <co linkends="FileOpenTestBean.java.openRequested.chooser.co" id="FileOpenTestBean.java.openRequested.chooser"/>
   chooser.setMultiSelectionEnabled(false);
   chooser.setDialogTitle("Text File Loader");
   chooser.setFileSelectionMode(JFileChooser.FILES_ONLY);

   // Only load .txt files.
   ExtensionFileFilter filter = new ExtensionFileFilter("Text Files");    <co linkends="FileOpenTestBean.java.openRequested.filter.co" id="FileOpenTestBean.java.openRequested.filter"/>
   filter.addExtension("txt");
   chooser.addChoosableFileFilter(filter);

   int status = chooser.showOpenDialog(this);                             <co linkends="FileOpenTestBean.java.openRequested.show-chooser.co" id="FileOpenTestBean.java.openRequested.show-chooser"/>

   if ( status == JFileChooser.APPROVE_OPTION )
   {
      File file = chooser.getSelectedFile();

      if ( file.canRead() )                                               <co linkends="FileOpenTestBean.java.openRequested.read.co" id="FileOpenTestBean.java.openRequested.canRead"/>
      {
         try
         {
            // Read the contents of the file into a byte[] object.
            FileInputStream input_file = new FileInputStream(file);
            byte[] file_data = new byte[(int) file.length()];
            input_file.read(file_data);                                   <co linkends="FileOpenTestBean.java.openRequested.read.co" id="FileOpenTestBean.java.openRequested.do-read"/>

            // Create a text area to hold the contents of the file.
            JTextArea text_area = new JTextArea();                        <co linkends="FileOpenTestBean.java.openRequested.text-area.co" id="FileOpenTestBean.java.openRequested.text-area"/>
            text_area.setEditable(false);
            text_area.insert(new String(file_data), 0);

            // Create a scroll pane to hold the text area; add it to the
            // tabbed pane with all the other previously loaded scroll
            // panes; and make the new scroll pane the selected component.
            JScrollPane text_comp = new JScrollPane(text_area);           <co linkends="FileOpenTestBean.java.openRequested.scroll-pane.co" id="FileOpenTestBean.java.openRequested.scroll-pane"/>
            mTextContainer.add(text_comp, file.getName());
            mTextContainer.setSelectedComponent(text_comp);

            // Our work is done.
            openFileCount++;                                              <co linkends="FileOpenTestBean.java.openRequested.open-inc.co" id="FileOpenTestBean.java.openRequested.open-inc"/>
            opened = true;
         }
         catch (java.io.FileNotFoundException ex)
         {
            JOptionPane.showMessageDialog(null, "Cannot find '" +
                                          file.getAbsolutePath() + "'",
                                          "Read Error",
                                          JOptionPane.ERROR_MESSAGE);
         }
         catch (java.io.IOException ex)
         {
            JOptionPane.showMessageDialog(null, "Error reading from '" +
                                          file.getAbsolutePath() + "':" +
                                          ex.getMessage(), "Read Error",
                                          JOptionPane.ERROR_MESSAGE);
         }
      }
      else
      {
         JOptionPane.showMessageDialog(null, "Cannot read from file '" +
                                       file.getAbsolutePath() + "'",
                                       "Read Error",
                                       JOptionPane.ERROR_MESSAGE);
      }
   }

   return opened;
}</programlisting>
               <calloutlist>
                  <callout arearefs="FileOpenTestBean.java.openRequested.chooser" id="FileOpenTestBean.java.openRequested.chooser.co">
                     <para>First, we create a <classname>JFileChooser</classname> that will be used to select a text file. It is configured to allow selection of only a single file each time.</para>
                  </callout>
                  <callout arearefs="FileOpenTestBean.java.openRequested.filter" id="FileOpenTestBean.java.openRequested.filter.co">
                     <para>Next, we create a filter for <filename>.txt</filename> files that will be used by the file chooser.</para>
                  </callout>
                  <callout arearefs="FileOpenTestBean.java.openRequested.show-chooser" id="FileOpenTestBean.java.openRequested.show-chooser.co">
                     <para>With those steps taken, we now open the chooser and wait for the user to select a file.</para>
                  </callout>
                  <callout arearefs="FileOpenTestBean.java.openRequested.canRead FileOpenTestBean.java.openRequested.do-read" id="FileOpenTestBean.java.openRequested.read.co">
                     <para>If a readable file was chosen, we open it and read its contents into an array of <type>byte</type>s.</para>
                  </callout>
                  <callout arearefs="FileOpenTestBean.java.openRequested.text-area" id="FileOpenTestBean.java.openRequested.text-area.co">
                     <para>With the bytes read, we can now put the contents of the text file into a read-only <classname>JTexArea</classname> object.</para>
                  </callout>
                  <callout arearefs="FileOpenTestBean.java.openRequested.scroll-pane" id="FileOpenTestBean.java.openRequested.scroll-pane.co">
                     <para>Next, we put the <classname>JTextArea</classname> in a <classname>JScrollPane</classname> so that long files can be viewed more easily. The scroll pane is added to the tabbed pane and made the currently selected panel.</para>
                  </callout>
                  <callout arearefs="FileOpenTestBean.java.openRequested.open-inc" id="FileOpenTestBean.java.openRequested.open-inc.co">
                     <para>At this point, we are done, so we increment the number of open files and set the return value to <constant>true</constant> to indicate that a file was opened successfully.</para>
                  </callout>
               </calloutlist>
               <para>This Bean uses no CORBA code and does not require C++ code to act as a peer. This may be the case for many Panel Beans written for Tweek. Of course, this Bean could be extended to open files that are then handed off to C++ code through CORBA.</para>
            </section>
            <section>
               <title>XML File</title>
               <para>The XML file for this Bean is very simple. It simply lists the Bean file information and puts the Bean at the root of the Bean tree. The full file is shown in <xref linkend="FileOpenTestBean.xml.example"/>.</para>
               <example id="FileOpenTestBean.xml.example">
                  <title>FileOpenTestBean.xml</title>
                  <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beanlist xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:noNamespaceSchemaLocation="http://www.vrjuggler.org/tweek/xsd/1.1/beanlist.xsd"&gt;
  &lt;guipanel name="File Open Test Bean"&gt;
    &lt;file name="${TWEEK_BASE_DIR}/bin/beans/FileOpenTestBean.jar" 
          class="fileopentestbean.FileOpenTestBean" /&gt;
    &lt;tree path="/" /&gt;
  &lt;/guipanel&gt;
&lt;/beanlist&gt;</programlisting>
               </example>
            </section>
         </section>
      </chapter>
      <chapter id="cxx.client.chapter">
         <title>C++ as a Client</title>
         <indexterm>
            <primary>C++ client API</primary>
         </indexterm>
         <para>As of Tweek version 0.13.0, users can write C++ clients in addition to Java clients. As of this writing, the interface is relatively low-level. The C++ counterpart of the Java class <classname>org.vrjuggler.tweek.net.corba.CorbaService</classname><indexterm>
               <primary>org.vrjuggler.tweek.net.CorbaService</primary>
            </indexterm> is used to communicate with a remote C++ server. The class is <classname>tweek::CorbaService</classname><indexterm>
               <primary>tweek::CorbaService</primary>
            </indexterm>, and its API is almost identical to the Java version. The basic idea is that users familiar with the Java API can easily make use of the C++ version and vice versa.</para>
         <para>In this chapter, we explain how to write C++ clients. First, we cover the CORBA Service, and then we show how to use it with a C++ client application. The basic ideas are identical to those used in Java clients. The syntax varies slightly due to the differences in the C++ and Java mappings of IDL. Additionally, we do not need to be concerned with JavaBeans because we will be speaking strictly in terms of C++. There is nothing to prevent an ambitious user from developing a C++ counterpart to the Tweek Java GUI, however.</para>
         <section>
            <title>The CORBA Service</title>
            <para></para>
         </section>
         <section>
            <title>Example Client Application</title>
            <para>To understand how to use the C++ client API, we will examine a simple application. Similar to the Java/C++ application we reviewed in <xref linkend="prog.all.chapter"/>, this application makes use of an IDL-specified interface, and a C++ server. The key differences, then, are that there is no Java code in this case, and we will not need to use XML.</para>
            <para>All the code shown here, including a GNU makefile, can be found in the directory <filename>$TWEEK_BASE_DIR/share/tweek/test/CxxClient</filename>. In the following sections, we will refer to the specific files and highlight key sections within them. We assume that readers have already read and understood <xref linkend="prog.all.chapter"/>. This is important because we will refer back to concepts illustrated in that chapter. Further, we will not present the server code in this chapter because it is nearly identical to the code for the server discussed previously. Interested readers can review the file <filename>server.cpp</filename>.</para>
            <section id="StringSubject.interface.section">
               <title><interfacename>StringSubject</interfacename> Interface</title>
               <para>As usual, we begin by defining an interface. For this example, we will use an interface that provides access to a simple string object. The server (Subject) will maintain the value of the string, and the clients (Observers) will be able to query and manipulate the string. The interface will be called <interfacename>CxxClientTest::StringSubject</interfacename>. The code for the interface is shown in <xref linkend="StringSubject.idl.example"/>.</para>
               <example id="StringSubject.idl.example">
                  <title>StringSubject.idl</title>
                  <programlisting>#ifndef _CXX_CLIENT_TEST_STRING_SUBJECT_IDL_
#define _CXX_CLIENT_TEST_STRING_SUBJECT_IDL_

#include &lt;tweek/idl/Subject.idl&gt;

module CxxClientTest
{
   interface StringSubject : tweek::Subject   <co linkends="StringSubject.interface.decl.co" id="StringSubject.interface.decl"/>
   {
      void setValue(in string val);           <co linkends="StringSubject.accessors.co" id="StringSubject.setValue"/>
      string getValue();                      <co linkends="StringSubject.accessors.co" id="StringSubject.getValue"/>
   };
};

#endif /* _CXX_CLIENT_TEST_STRING_SUBJECT_IDL_ */</programlisting>
                  <calloutlist>
                     <callout arearefs="StringSubject.interface.decl" id="StringSubject.interface.decl.co">
                        <para>As with all user-defined Subjects, we derive our interface from <interfacename>tweek::Subject</interfacename>.</para>
                     </callout>
                     <callout arearefs="StringSubject.setValue StringSubject.getValue" id="StringSubject.accessors.co">
                        <para>These methods define the accessors for the encapsulated string value. Clients will invoke these to query and to manipulate the state of the remote Subject.</para>
                     </callout>
                  </calloutlist>
               </example>
            </section>
            <section>
               <title><interfacename>StringSubject</interfacename> Interface Implementation</title>
               <para>Now that we have our interface defined abstractly, we must provide a C++ implementation of the Subject. This will be done in the files <filename>StringSubjectImpl.cpp</filename> and <filename>StringSubjectImpl.h</filename>. We begin with the header file, shown in <xref linkend="StringSubjectImpl.h.example"/>. While the example code may appear long, there is only slight variation from previous Subject implementation header files. We highlight the important bits, of course.</para>
               <example id="StringSubjectImpl.h.example">
                  <title>StringSubjectImpl.h</title>
                  <programlisting linenumbering="numbered">#ifndef _STRING_SUBJECT_IMPL_H_
#define _STRING_SUBJECT_IMPL_H_

#include &lt;tweek/tweekConfig.h&gt;

#include &lt;string&gt;

#include &lt;vpr/vpr.h&gt;
#include &lt;vpr/Sync/Mutex.h&gt;
#include &lt;tweek/CORBA/SubjectImpl.h&gt;
#include &lt;StringSubject.h&gt;                                               <co linkends="StringSubjectImpl.h.include.co" id="StringSubjectImpl.h.include"/>

namespace CxxClientTest
{

/**
 * This class is an extension to the base Tweek SubjectImpl class.  It uses
 * multiple inheritance with that class and with the generated CORBA class
 * corresponding to the IDL for StringSubject.
 */
class StringSubjectImpl : public POA_CxxClientTest::StringSubject,       <co linkends="StringSubjectImpl.h.decl.co" id="StringSubjectImpl.h.decl"/>
                          public tweek::SubjectImpl
{
public:
   StringSubjectImpl() : tweek::SubjectImpl(), mValue("")
   {
      /* Do nothing. */ ;
   }

   virtual ~StringSubjectImpl()
   {
      /* Do nothing. */ ;
   }

   /**
    * Sets this subject's internal value.
    */
   virtual void setValue(const char* value);                             <co linkends="StringSubjectImpl.h.virtuals.co" id="StringSubjectImpl.h.setValue"/>

   /**
    * Returns this subject's internal value.
    */
   virtual char* getValue();                                             <co linkends="StringSubjectImpl.h.virtuals.co" id="StringSubjectImpl.h.getValue"/>

   /**
    * This overriding method is needed so that the correct type is returned
    * when the _this() method is invoked.  Without this method, an object of
    * type tweek::Subject_ptr would be returned.
    */
   CxxClientTest::StringSubject_ptr _this()                              <co linkends="StringSubjectImpl.h.this.co" id="StringSubjectImpl.h.this"/>
   {
      return POA_CxxClientTest::StringSubject::_this();
   }

private:
   std::string mValue;      /**&lt; Our value */                            <co linkends="StringSubjectImpl.h.mValue.co" id="StringSubjectImpl.h.mValue"/>
   vpr::Mutex  mValueLock;  /**&lt; A mutex to protect mValue accesses */   <co linkends="StringSubjectImpl.h.mutex.co" id="StringSubjectImpl.h.mutex"/>
};

} // End of CxxClientTest namespace

#endif /* _STRING_SUBJECT_IMPL_H_ */</programlisting>
                  <calloutlist>
                     <callout arearefs="StringSubjectImpl.h.include" id="StringSubjectImpl.h.include.co">
                        <para>We must be sure to include the header that defines the base class from which we will derive our implementation. Remember that this code will be generated by the IDL compiler.</para>
                     </callout>
                     <callout arearefs="StringSubjectImpl.h.decl" id="StringSubjectImpl.h.decl.co">
                        <para>As usual, we declare our implementation so that it derives from the class generated by the IDL compiler (<classname>POA_CxxClientTest::StringSubject</classname>) and from the basic Tweek Subject implementation class (<classname>tweek::SubjectImpl</classname>).</para>
                     </callout>
                     <callout arearefs="StringSubjectImpl.h.setValue StringSubjectImpl.h.getValue" id="StringSubjectImpl.h.virtuals.co">
                        <para>These are the pure virtual methods defined by <classname>POA_CxxClientTest::StringSubject</classname> that we must implement. As in previous examples, this is where we will do the work of accessing the encapsulated string value.</para>
                     </callout>
                     <callout arearefs="StringSubjectImpl.h.this" id="StringSubjectImpl.h.this.co">
                        <para>As with all C++ Subject implementations, we must override the method <methodname>_this()</methodname> in order to return the correct type. This is critical for proper use of the specific Subject type.</para>
                     </callout>
                     <callout arearefs="StringSubjectImpl.h.mValue" id="StringSubjectImpl.h.mValue.co">
                        <para>Here we have the string value that will be encapsulated within the servant instance. For convenience, we use the <classname>std::string</classname> type, though it will require careful handling of the <type>char*</type> data that CORBA actually passes around.</para>
                     </callout>
                     <callout arearefs="StringSubjectImpl.h.mutex" id="StringSubjectImpl.h.mutex.co">
                        <para>In this Subject implementation, we are being more paranoid about concurrent accesses to <varname>mValue</varname>, so we will protect it with a mutex.</para>
                     </callout>
                  </calloutlist>
               </example>
               <para>Next, we look at the very simple implementations of <methodname>CxxClientTest::StringSubjectImpl::setValue()</methodname> and <methodname>CxxClientTest::StringSubjectImpl::getValue()</methodname>. These are found in the file <filename>StringSubjectImpl.cpp</filename>, and the code is shown in <xref linkend="StringSubjectImpl.cpp.example"/>. It is important to note the use of guards in the method implementations. These provide an exception-safe mechanism for controlling access to the data member <varname>mValue</varname>. When constructed, the guard locks the mutex passed as the argument to the constructor. When the guard goes out of scope, the mutex is automatically unlocked.</para>
               <example id="StringSubjectImpl.cpp.example">
                  <title>StringSubjectImpl.cpp</title>
                  <programlisting linenumbering="numbered">#include &lt;vpr/Sync/Guard.h&gt;
#include &lt;StringSubjectImpl.h&gt;                              <co linkends="StringSubjectImpl.cpp.include.co" id="StringSubjectImpl.cpp.include"/>

namespace CxxClientTest
{

void StringSubjectImpl::setValue(const char* value)
{
   {
      vpr::Guard&lt;vpr::Mutex&gt; val_guard(mValueLock);         <co linkends="StringSubjectImpl.cpp.setValue.co" id="StringSubjectImpl.cpp.setValue.guard"/>
      mValue = std::string(value);                          <co linkends="StringSubjectImpl.cpp.setValue.co" id="StringSubjectImpl.cpp.setValue.assign"/>
   }

   // Notify any observers that our value has changed.  This is very
   // important.
   tweek::SubjectImpl::notify();                            <co linkends="StringSubjectImpl.cpp.notify.co" id="StringSubjectImpl.cpp.setValue.notify"/>
}

char* StringSubjectImpl::getValue()
{
   vpr::Guard&lt;vpr::Mutex&gt; val_guard(mValueLock);            <co linkends="StringSubjectImpl.cpp.getValue.co" id="StringSubjectImpl.cpp.getValue.guard"/>
   return CORBA::string_dup(mValue.c_str());                <co linkends="StringSubjectImpl.cpp.getValue.co" id="StringSubjectImpl.cpp.getValue.return"/>
}

} // End CxxClientTest namespace</programlisting>
                  <calloutlist>
                     <callout arearefs="StringSubjectImpl.cpp.include" id="StringSubjectImpl.cpp.include.co">
                        <para>As usual, we must include our header file to get the necessary declarations.</para>
                     </callout>
                     <callout arearefs="StringSubjectImpl.cpp.setValue.guard StringSubjectImpl.cpp.setValue.assign" id="StringSubjectImpl.cpp.setValue.co">
                        <para>Within this scoped block, we lock the <varname>mValueLock</varname> using a guard and assign a new value to <varname>mValue</varname>. Upon exiting this block, the guard goes out of scope, and <varname>mValueLock</varname> is unlocked.</para>
                     </callout>
                     <callout arearefs="StringSubjectImpl.cpp.setValue.notify" id="StringSubjectImpl.cpp.notify.co">
                        <para>As with all cases where we modify the state of the Subject, we must notify any Observers who are attached to us. Just as the comment notes, this is very important.</para>
                     </callout>
                     <callout arearefs="StringSubjectImpl.cpp.getValue.guard StringSubjectImpl.cpp.getValue.return" id="StringSubjectImpl.cpp.getValue.co">
                        <para>Here, we return the current value of <varname>mValue</varname>. We use a guard again to simplify unlocking the mutex (it happens automatically upon return). Note that we make a copy of the memory contained in <varname>mValue</varname> using <function>CORBA::string_dup()</function>. Making a copy is required by CORBA.</para>
                     </callout>
                  </calloutlist>
               </example>
            </section>
            <section>
               <title id="string.observer.section">Observer Implementation</title>
               <para>With the Subject implemented, we now turn our attention to a C++ Observer implementation. Its implementation we will be very simple. Its <methodname>update()</methodname> method will query the current string value and print it to the console. The goal here is to demonstrate how to write a C++ Observer, not how to write an <emphasis>interesting</emphasis> Observer.</para>
               <example id="StringObserverImpl.h.example">
                  <title>StringObserverImpl.h</title>
                  <programlisting linenumbering="numbered">#ifndef _STRING_OBSERVER_IMPL_H_
#define _STRING_OBSERVER_IMPL_H_

#include &lt;tweek/CORBA/Observer.h&gt;                        <co linkends="StringObserverImpl.h.includes.co" id="StringObserverImpl.h.Observer.include"/>
#include &lt;StringSubject.h&gt;                               <co linkends="StringObserverImpl.h.includes.co" id="StringObserverImpl.h.StringSubject.include"/>

class StringObserverImpl : public POA_tweek::Observer    <co linkends="StringObserverImpl.h.decl.co" id="StringObserverImpl.h.decl"/>
{
public:
   StringObserverImpl(CxxClientTest::StringSubject_var subject)
      : mSubject(subject)
   {
      /* Do nothing. */ ;
   }

   virtual ~StringObserverImpl()
   {
      /* Do nothing. */ ;
   }

   virtual void update();                                <co linkends="StringObserverImpl.h.update.co" id="StringObserverImpl.h.update"/>

   void detach()
   {
      mSubject-&gt;detach(_this());                         <co linkends="StringObserverImpl.h.detach.co" id="StringObserverImpl.h.detach"/>
   }

private:
   CxxClientTest::StringSubject_var mSubject;            <co linkends="StringObserverImpl.h.mSubject.co" id="StringObserverImpl.h.mSubject"/>
};

#endif /* _STRING_OBSERVER_IMPL_H_ */</programlisting>
                  <calloutlist>
                     <callout arearefs="StringObserverImpl.h.Observer.include StringObserverImpl.h.StringSubject.include" id="StringObserverImpl.h.includes.co">
                        <para>First, we include the headers we need. The first declares the basic <classname>tweek::Observer</classname> C++ interface. The second includes the <classname>tweek::StringSubject</classname> interface. We need this header so that we can hang onto a reference to our Subject.</para>
                     </callout>
                     <callout arearefs="StringObserverImpl.h.decl" id="StringObserverImpl.h.decl.co">
                        <para>Our Observer implementation derives from the basic Tweek Observer class <classname>POA_tweek::Observer</classname>. The Java equivalent is <classname>tweek.ObserverPOA</classname>. Refer to <xref linkend="SliderObserverImpl.java.example"/> in <xref linkend="implement.observer.java.section"/> to see the correspondence.</para>
                     </callout>
                     <callout arearefs="StringObserverImpl.h.update" id="StringObserverImpl.h.update.co">
                        <para>The <methodname>update()</methodname> method must be implemented for all subclasses of <classname>POA_tweek::Observer</classname>. Here, we just declare the method; the implementation will be shown in <xref linkend="StringObserverImpl.cpp.example"/>.</para>
                     </callout>
                     <callout arearefs="StringObserverImpl.h.detach" id="StringObserverImpl.h.detach.co">
                        <para>The <methodname>detach()</methodname> method is provided as an easy way to detach the Observer from its Subject. Ideally, this would be done in the destructor so that the detaching process happens automatically when the Observer servant is deleted. Doing so leads to incorrect deactivation of the servant, however. Instead, we provide this method as a way to perform the detachment before servant deactivation or deletion occurs.</para>
                     </callout>
                     <callout arearefs="StringObserverImpl.h.mSubject" id="StringObserverImpl.h.mSubject.co">
                        <para>Finally, we have a member variable that we will use to retain a reference our Subject. This allows the Observer to be passed around to functions without passing its Subject explicitly. Further, we will see that having a reference to the Subject is required for the <methodname>update()</methodname> method implementation to work.</para>
                     </callout>
                  </calloutlist>
               </example>
               <para>Now, we show the implementation of <methodname>StringObserverImpl::update()</methodname>. This method is implemented in <filename>StringObserverImpl.cpp</filename>. While the method body is very short, we use the <filename>.cpp</filename> file to encourage the implementation of methods outside of the class declaration.</para>
               <example id="StringObserverImpl.cpp.example">
                  <title>StringObserverImpl.cpp</title>
                  <programlisting>#include &lt;iostream&gt;
#include &lt;StringObserverImpl.h&gt;                     <co linkends="StringObserverImpl.cpp.include.co" id="StringObserverImpl.cpp.include"/>

void StringObserverImpl::update()
{
   char* cur_value = mSubject-&gt;getValue();          <co linkends="StringObserverImpl.cpp.update.query.co" id="StringObserverImpl.cpp.update.query"/>
   std::cout &lt;&lt; "Current string value is now '"     <co linkends="StringObserverImpl.cpp.update.query.co" id="StringObserverImpl.cpp.update.print"/>
             &lt;&lt; cur_value &lt;&lt; "'" &lt;&lt; std::endl;
   delete cur_value;                                <co linkends="StringObserverImpl.cpp.update.delete.co" id="StringObserverImpl.cpp.update.delete"/>
}</programlisting>
                  <calloutlist>
                     <callout arearefs="StringObserverImpl.cpp.include" id="StringObserverImpl.cpp.include.co">
                        <para>As usual, we have to include our header file to get the class declaration information.</para>
                     </callout>
                     <callout arearefs="StringObserverImpl.cpp.update.query StringObserverImpl.cpp.update.print" id="StringObserverImpl.cpp.update.query.co">
                        <para>Since <methodname>update()</methodname> is only called when the state of the Subject changes, we need to query its current state. Once we get the current string value back, we print it to the console. The value is enclosed in single quotes so that any leading or trailing whitespace is displayed clearly.</para>
                     </callout>
                     <callout arearefs="StringObserverImpl.cpp.update.delete" id="StringObserverImpl.cpp.update.delete.co">
                        <para>Lastly, we delete the memory returned by <methodname>CxxClientTest::StringSubject::getValue()</methodname>. The burden for freeing this memory is on the client, as per standard CORBA operating procedure.</para>
                     </callout>
                  </calloutlist>
               </example>
            </section>
            <section>
               <title>Client Application</title>
               <para>Finally, we look at the C++ client application. This brings everything together and makes use of the <classname>tweek::CorbaService</classname> class to contact the remote server. The application shown below is more complicated than the server because more work must done. We must initialize the local CORBA Service (the local ORB); we must pick out the correct Subject Manager reference; and we must get the correct <interfacename>CxxClientTest::StringSubject</interfacename> reference from the Subject Manager. Once all of those steps are completed, we can create an Observer servant (an instance of <classname>StringObserverImpl</classname>) and attach it to the remote Subject.</para>
               <para>The file containing the complete client application source is client.cpp. We will examine it in three parts: the required headers, the implementation of <function>main()</function>, and the Subject Manager lookup.</para>
               <example>
                  <title>client.cpp: Required Header Files</title>
                  <programlisting>#include &lt;iostream&gt;
#include &lt;string&gt;

#include &lt;vpr/vpr.h&gt;
#include &lt;vpr/Util/Debug.h&gt;
#include &lt;tweek/Client/CorbaService.h&gt;    <co linkends="client.cpp.include.CorbaService.co" id="client.cpp.include.CorbaService"/>
#include &lt;tweek/CORBA/SubjectManager.h&gt;   <co linkends="client.cpp.include.SubjectManager.co" id="client.cpp.include.SubjectManager"/>

#include &lt;StringObserverImpl.h&gt;           <co linkends="client.cpp.include.StringObserverImpl.co" id="client.cpp.include.StringObserverImpl"/>
</programlisting>
                  <calloutlist>
                     <callout arearefs="client.cpp.include.CorbaService" id="client.cpp.include.CorbaService.co">
                        <para>The key to the C++ client interface is the CORBA Service. Its declaration is found in <filename>tweek/Client/CorbaService.h</filename>.</para>
                     </callout>
                     <callout arearefs="client.cpp.include.SubjectManager" id="client.cpp.include.SubjectManager.co">
                        <para>As in Java clients, the Subject Manager plays a vital role in getting references to remote Subjects. Note that the file we include here is generated by the IDL compiler and provides only the basic interface. We will not be using the actual Subject Manager C++ implementation here. That is only used on the server side.</para>
                     </callout>
                     <callout arearefs="client.cpp.include.StringObserverImpl" id="client.cpp.include.StringObserverImpl.co">
                        <para>Lastly, we include the implementation of our Observer. We will be creating an instance of this class to act as the servant for an Observer reference. The servant we create will be attached to a remote Subject, just as in all Java clients.</para>
                     </callout>
                  </calloutlist>
               </example>
               <para>Next, we look at the implementation of the application's <function>main()</function> function. This is where the bulk of the work is done. Of course, in real-world use, modularizing the code would be much better than dumping most of it in <function>main()</function>. For the purposes of this example, we can get by with having most of the code in <function>main()</function>.</para>
               <para>Note the use of try/catch blocks in the client application code. As in the case of server applications (refer to <xref linkend="SliderSubject.server.section"/>), we are careful about handling exceptions properly. Remember that CORBA uses exceptions extensively to indicate errors, and thus it is necessary for user code to catch them.</para>
               <example id="client.cpp.main.example1">
                  <title>client.cpp: Implementation of main(), Part I</title>
                  <programlisting linenumbering="numbered">int main(int argc, char* argv[])
{
   std::string ns_host, iiop_ver;
   vpr::Uint16 ns_port;

   std::cout &lt;&lt; "Naming Service host: ";                                  <co linkends="client.cpp.main.naming.info.co" id="client.cpp.main.nshost"/>
   std::cin &gt;&gt; ns_host;

   std::cout &lt;&lt; "Naming Service port (usually 2809): ";                   <co linkends="client.cpp.main.naming.info.co" id="client.cpp.main.nsport"/>
   std::cin &gt;&gt; ns_port;

   std::cout &lt;&lt; "IIOP version (usually 1.0): ";                           <co linkends="client.cpp.main.naming.info.co" id="client.cpp.main.iiopver"/>
   std::cin &gt;&gt; iiop_ver;

   // Create the local CORBA Service using the Naming Service URI information
   // we just collected.
   tweek::CorbaService corba_service(ns_host, ns_port, iiop_ver);         <co linkends="client.cpp.main.corba-service.construct.co" id="client.cpp.main.corba-service.construct"/>

   try
   {
      // Attempt to initialize the CORBA Service.
      if ( corba_service.init(argc, argv).success() )                     <co linkends="client.cpp.main.corba-service.init.co" id="client.cpp.main.corba-service.init"/>
      {
         // This will hold the reference to the Subject Manager we use.
         tweek::SubjectManager_var subj_mgr =
            chooseSubjectManager(corba_service);                          <co linkends="client.cpp.main.SubjectManager.choose.co" id="client.cpp.main.SubjectManager.choose"/>

         // Verify that we actually got a Subject Manager reference back
         // from chooseSubjectManager.
         if ( ! CORBA::is_nil(subj_mgr) )                                 <co linkends="client.cpp.main.SubjectManager.choose.co" id="client.cpp.main.SubjectManager.verify"/>
         {
            // Request the Subject with which we will communicate.  This
            // hard-coded Subject name is not necessarily a good thing.
            tweek::Subject_var subj =
               subj_mgr-&gt;getSubject("StringSubject");                     <co linkends="client.cpp.main.subject.request.co" id="client.cpp.main.subject.request"/>

            // If the Subject Manager knows about the Subject named above,
            // then we are good to go.
            if ( ! CORBA::is_nil(subj) )                                  <co linkends="client.cpp.main.subject.request.co" id="client.cpp.subject.verify"/>
            {
               ...  // Shown in the next example block
            }
         }
         // We did not get a Subject Manager reference back for some reason.
         else
         {
            vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
               &lt;&lt; "No Subject Manager chosen--exiting.\n" &lt;&lt; vprDEBUG_FLUSH;
         }
      }
      // The CORBA Service initialization failed.
      else
      {
         vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
            &lt;&lt; "CORBA Service failed to initialize\n" &lt;&lt; vprDEBUG_FLUSH;
      }
   }
   catch (...)
   {
      vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
         &lt;&lt; "Caught an unknown exception!\n" &lt;&lt; vprDEBUG_FLUSH;
   }

   return 0;
}</programlisting>
                  <calloutlist>
                     <callout arearefs="client.cpp.main.nshost client.cpp.main.nsport client.cpp.main.iiopver" id="client.cpp.main.naming.info.co">
                        <para>Here, we query input from the user to get Naming Service information. We need the host name where the Naming Service is running, the port on which it is listening, and the version of <glossterm linkend="gloss.iiop">IIOP</glossterm> to use. Using the values we get from the user, we can construct an instance of <classname>tweek::CorbaService</classname>. Internally, it will use the values to create a URI for looking up the Naming Service reference.</para>
                     </callout>
                     <callout arearefs="client.cpp.main.corba-service.construct" id="client.cpp.main.corba-service.construct.co">
                        <para>Once we have all the necessary initialization pieces, we can construct an instance of <classname>tweek::CorbaService</classname>. Simply creating an instance of this class does not perform any CORBA-related activities. That is the next step.</para>
                     </callout>
                     <callout arearefs="client.cpp.main.corba-service.init" id="client.cpp.main.corba-service.init.co">
                        <para>Now we initialize the local CORBA Service. We pass in <varname>argc</varname> and <varname>argv</varname> in case the user provided any CORBA-specific command-line parameters. (Any such parameters will be stripped from <varname>argv</varname>, and <varname>argc</varname> will be decremented accordingly.) If initialization succeeds, we proceed to requesting the Subject Manager reference.</para>
                     </callout>
                     <callout arearefs="client.cpp.main.SubjectManager.choose client.cpp.main.SubjectManager.verify" id="client.cpp.main.SubjectManager.choose.co">
                        <para>Using the CORBA Service, we choose the Subject Manager through which all Subject requests will be handled. The work for making this choice is offloaded to the helper function <function>chooseSubjectManager()</function>, shown in <xref linkend="client.cpp.chooseSubjectManager.example"/>. For now, we just assume that we got back some reference, possibly nil, to a remote <interfacename>tweek::SubjectManager</interfacename> object. Since we do not know for sure what the state of things is on the server side or what decision the user made, we verify that we did not get back a nil reference. If we got back a valid Subject Manager reference, we can use it just as we would in a Java client to request Subject references by name.</para>
                     </callout>
                     <callout arearefs="client.cpp.main.subject.request client.cpp.subject.verify" id="client.cpp.main.subject.request.co">
                        <para>Next, we request the reference to the remote Subject. The symbolic name we use here is the same as that specified in the server application (not shown in this chapter). Note that using a hard-coded name in this way is not recommended, but we use it here for the sake of simplicity. Once we have a reference, we verify that it is not nil before trying to use it.</para>
                     </callout>
                  </calloutlist>
               </example>
               <para>We now narrow our attention to the handling of the Subject reference that was returned by the Subject Manager. The code shown in <xref linkend="client.cpp.main.example2"/> comes from the <quote>...</quote> block in <xref linkend="client.cpp.main.example1"/>. At this point in the application execution, we know that we have a non-nil <interfacename>tweek::Subject</interfacename> reference, so we need to narrow it to our specific type, create an Observer servant, and attach it to the remote Subject.</para>
               <example id="client.cpp.main.example2">
                  <title>client.cpp: Implementation of main(), Part II</title>
                  <programlisting linenumbering="numbered">StringObserverImpl* string_observer(NULL);
PortableServer::ObjectId_var observer_id;

try
{
   // Attempt to narrow subj to the more specific reference type
   // CxxClientTest::StringSubject_var.  If this fails, an
   // exception will be thrown and caught below.
   CxxClientTest::StringSubject_var string_subj =
      CxxClientTest::StringSubject::_narrow(subj);               <co linkends="client.cpp.main.subject.narrow.co" id="client.cpp.main.subject.narrow"/>

   // Request the current value before we create the Observer.
   // In this way, we can see the persistent state maintained
   // by the Subject.
   char* cur_value = string_subj-&gt;getValue();
   std::cout &lt;&lt; "Current string value is '" &lt;&lt; cur_value &lt;&lt; "'"
             &lt;&lt; std::endl;
   delete cur_value;

   // Create our Observer servant.
   string_observer = new StringObserverImpl(string_subj);        <co linkends="client.cpp.main.servant.construct.co" id="client.cpp.main.servant.construct"/>

   // Register the newly created servant with our ORB's POA.
   observer_id =
      corba_service.registerObject(string_observer,
                                   "StringObserver");            <co linkends="client.cpp.main.servant.register.co" id="client.cpp.main.servant.register"/>

   // This could be done in the StringObserverImpl constructor,
   // but we do it here in this example just to make it clear
   // that it is important.
   string_subj-&gt;attach(string_observer-&gt;_this());                <co id="client.cpp.main.observer.attach"/>

   const std::string exit_string("Q");
   std::string cur_string;

   for ( ;; )                                                    <co linkends="client.cpp.main.loop.co" id="client.cpp.main.loop"/>
   {
      std::cout &lt;&lt; "Enter a string (Q to quit): ";
      std::cin &gt;&gt; cur_string;

      if ( exit_string != cur_string )
      {
         string_subj-&gt;setValue(cur_string.c_str());              <co id="client.cpp.main.subject.setValue"/>
      }
      else
      {
         break;
      }
   }
}
catch (...)
{
   vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
      &lt;&lt; "Caught an unknown exception during object interaction!\n"
      &lt;&lt; vprDEBUG_FLUSH;
}

// We're done, so now we have to clean up after ourselves.
// The order of operations here is important.
if ( NULL != string_observer )
{
   string_observer-&gt;detach();                                    <co linkends="client.cpp.main.cleanup.co" id="client.cpp.main.observer.detach"/>
   corba_service.unregisterObject(observer_id);                  <co linkends="client.cpp.main.cleanup.co" id="client.cpp.main.servant.unregister"/>
   delete string_observer;                                       <co linkends="client.cpp.main.cleanup.co" id="client.cpp.main.servant.delete"/>
}</programlisting>
                  <calloutlist>
                     <callout arearefs="client.cpp.main.subject.narrow" id="client.cpp.main.subject.narrow.co">
                        <para>Given a non-nil Subject reference, we now need to narrow it to our specific Subject type, <interfacename>CxxClientTest::StringSubject</interfacename>. If the narrowing fails, an exception will be thrown. In that case, we are done because we did not get back a reference we can use.</para>
                     </callout>
                     <callout arearefs="client.cpp.main.servant.construct" id="client.cpp.main.servant.construct.co">
                        <para>If the narrowing succeeded, then we can create an Observer servant (an instance of our class <classname>StringObserverImpl</classname>). In our local ORB, this servant will handle accesses from remote objects&mdash;namely, the Subject to which it is attached.</para>
                     </callout>
                     <callout arearefs="client.cpp.main.servant.register" id="client.cpp.main.servant.register.co">
                        <para>Next, we register our newly created Observer servant with the POA in the local CORBA Service. We give it an arbitrary name, and it gives us a unique identifier for the servant. We will need this identifier later when the application is shutting down and cleaning up after itself.</para>
                     </callout>
                     <callout arearefs="client.cpp.main.observer.attach" id="client.cpp.main.observer.attach.co">
                        <para>At long last, we can attach our Observer to the remote Subject. The mechanism for doing this is nearly identical to the Java version. The only difference is the use of the <literal>-&gt;</literal> operator, which is not present in Java. Once the Subject knows about our Observer, it will be informed of all state changes.</para>
                     </callout>
                     <callout arearefs="client.cpp.main.loop" id="client.cpp.main.loop.co">
                        <para>In this loop, we ask the user for input and then pass that input to the Subject's <methodname>setValue()</methodname> method. We do this until the user enters the string <literal>"Q"</literal>, which denotes that s/he wants to quit the application.</para>
                     </callout>
                     <callout arearefs="client.cpp.main.subject.setValue" id="client.cpp.main.subject.setValue.co">
                        <para>This is where we modify the state of the remote Subject. We pass the C string version of the user-specified string as the argument to <methodname>CxxClientTest::StringSubject::setValue()</methodname>.</para>
                     </callout>
                     <callout arearefs="client.cpp.main.observer.detach client.cpp.main.servant.unregister client.cpp.main.servant.delete" id="client.cpp.main.cleanup.co">
                        <para>Once the user has requested to quit the application, we need to clean up the servant we constructed earlier. First, we detach the Observer from the remote Subject. Next, we unregister our servant using the ID returned by the local CORBA Service. Finally, we delete the heap memory allocated for the servant. With that, we are done.</para>
                     </callout>
                  </calloutlist>
               </example>
               <para>The last part of the client application is the choice of the Subject Manager reference to use. In this example, we put that code in the helper function <function>chooseSubjectManager()</function>. In this function, we request the list of valid Subject Manager references from the local CORBA Service and present the information about each one to the user. Using this information, the user selects one, and that reference is then returned to the caller. In a real-world example, the Subject Manager chooser would be much more sophisticated than what we show in <xref linkend="client.cpp.chooseSubjectManager.example"/>, but for the purposes of explaining the ideas, this will suffice.</para>
               <example id="client.cpp.chooseSubjectManager.example">
                  <title>client.cpp: Implementation of chooseSubjectManager()</title>
                  <programlisting linenumbering="numbered">tweek::SubjectManager_var chooseSubjectManager(tweek::CorbaService&amp; corbaService)
{
   tweek::SubjectManager_var subj_mgr;

   // Request all the active Subject Manager references.
   std::list&lt;tweek::SubjectManager_var&gt; mgrs =
      corbaService.getSubjectManagerList();                                   <co linkends="client.cpp.chooseSubjectManager.list.co" id="client.cpp.chooseSubjectManager.list"/>

   std::list&lt;tweek::SubjectManager_var&gt;::iterator cur_mgr;

   // Iterate over all the tweek::SubjectManager references we have.
   for ( cur_mgr = mgrs.begin(); cur_mgr != mgrs.end(); ++cur_mgr )           <co linkends="client.cpp.chooseSubjectManager.loop.co" id="client.cpp.chooseSubjectManager.loop"/>
   {
      try
      {
         // It is not entirely safe to assume that *cur_mgr is still valid at
         // this point, even though it was valid when the mgrs list was
         // constructed.  Hence, we test it again now.
         if ( ! (*cur_mgr)-&gt;_non_existent() )                                 <co linkends="client.cpp.chooseSubjectManager.verify.co" id="client.cpp.chooseSubjectManager.verify"/>
         {
            std::string response;
            const std::string proceed("y");

            tweek::SubjectManager::SubjectManagerInfoList_var mgr_info =      <co linkends="client.cpp.chooseSubjectManager.info.co" id="client.cpp.chooseSubjectManager.getInfo"/>
               (*cur_mgr)-&gt;getInfo();

            std::cout &lt;&lt; "\nSubject Manager information:" &lt;&lt; std::endl;

            // Loop over the information items and print each key/value pair
            // to the screen.
            for ( CORBA::ULong i = 0; i &lt; mgr_info-&gt;length(); ++i )           <co linkends="client.cpp.chooseSubjectManager.info.co" id="client.cpp.chooseSubjectManager.info-loop"/>
            {
               std::cout &lt;&lt; "\t" &lt;&lt; mgr_info[i].key  &lt;&lt; " = "
                         &lt;&lt; mgr_info[i].value &lt;&lt; std::endl;
            }

            std::cout &lt;&lt; "Use this Subject Manager (y/n)? ";
            std::cin &gt;&gt; response;

            if ( proceed == response )
            {
               subj_mgr = *cur_mgr;                                           <co linkends="client.cpp.chooseSubjectManager.done.co" id="client.cpp.chooseSubjectManager.done"/>
               break;
            }
         }
      }
      catch (...)
      {
         vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
            &lt;&lt; "Caught an unknown exception in chooseSubjectManager loop\n"
            &lt;&lt; vprDEBUG_FLUSH;
      }
   }

   return subj_mgr;
}</programlisting>
                  <calloutlist>
                     <callout arearefs="client.cpp.chooseSubjectManager.list" id="client.cpp.chooseSubjectManager.list.co">
                        <para>Using the given <classname>tweek::CorbaService</classname> reference, we ask for the current list of valid <interfacename>tweek::SubjectManager</interfacename> references. The references in this list are guaranteed to be valid at the time the list was constructed.</para>
                     </callout>
                     <callout arearefs="client.cpp.chooseSubjectManager.loop" id="client.cpp.chooseSubjectManager.loop.co">
                        <para>We use an STL iterator to loop over the list of returned <interfacename>tweek::SubjectManager</interfacename> references. This loop presents each reference in sequence and asks the user if the current reference is the one s/he wants. The loop completes when the user selects a reference or when no more references are available.</para>
                     </callout>
                     <callout arearefs="client.cpp.chooseSubjectManager.verify" id="client.cpp.chooseSubjectManager.verify.co">
                        <para>While the list of Subject Manager references was guaranteed to have contained valid references when it was constructed, things may have changed since then. That is the nature of asynchronous programming. To be safe, we test the current Subject Manager reference to see if it still refers to an extant object. If so, we continue. If not, we skip it. This invocation of <methodname>tweek::SubjectManager::_non_existent()</methodname> may throw an exception, and for that reason, we enclose the body of the for loop in a try/catch block.</para>
                     </callout>
                     <callout arearefs="client.cpp.chooseSubjectManager.getInfo client.cpp.chooseSubjectManager.info-loop" id="client.cpp.chooseSubjectManager.info.co">
                        <para>It is possible for a single Naming Service to have multiple active Subject Manager references. Each of these has a unique identifier within the Naming Service, but the identifier is not human readable. To work around this, we make use of the method <methodname>tweek::SubjectManager::getInfo()</methodname>. This method returns a sequence of key/value pairs (both are strings) that can be used to identify which Subject Manager reference is the correct one. Here, we request this information sequence and print all the key/value pairs. With this output, the user can (hopefully) determine which Subject Manager reference to use.</para>
                        <note>
                           <para>This example is purposefully simple to keep the code small. Readers are strongly encouraged to come up with much more sophisticated choosing mechanisms here. For example, the flexibility of the Subject Manager information sequence would allow choices to be made entirely in code without any interactive user feedback.</para>
                        </note>
                     </callout>
                     <callout arearefs="client.cpp.chooseSubjectManager.done" id="client.cpp.chooseSubjectManager.done.co">
                        <para>Here, the user has selected the current Subject Manager as the correct one. We copy the reference to the <varname>subj_mgr</varname> variable. Then, we break out of the loop and return <varname>subj_mgr</varname> to the caller.</para>
                     </callout>
                  </calloutlist>
               </example>
               <para>With that, we are done with our review of the C++ client API in Tweek. The use of CORBA allows Java and C++ client code to be quite similar, and this can be helpful when migrating between the two. The addition of the C++ client API in Tweek 0.13 also demonstrates one of the basic design philosophies of Tweek: clients can be written in any language without concern for the language the server uses.</para>
            </section>
         </section>
      </chapter>
   </part>
   <part>
      <title>Appendices</title>
      <appendix id="makefile.appendix">
         <title>Makefiles for Example Code</title>
         <para>This appendix provides makefiles that can be used as starting points for compiling the example code shown earlier. These can also be used as the basis for future projects using Tweek.</para>
         <section id="SliderSubject.makefile.section">
            <title>SliderSubject</title>
            <para>The following is a makefile that shows how to compile the code related to the <interfacename>SliderSubject</interfacename> example presented in <xref linkend="collab.slider.section"/>. It runs the IDL compiler, the C++ compiler, and the Java compiler. It assumes the use of <command>omniidl</command>, the JacORB compiler, and GCC in a Linux environment.</para>
            <programlisting>default: all

# Basic options.
srcdir		= .
CFLAGS		= $(EXTRA_CFLAGS) $(INCLUDES) $(DEFS)
CXXFLAGS		= -Wall -Werror-implicit-function-declaration \
                    -I$(VPR_BASE_DIR/include -I$(TWEEK_BASE_DIR)/include/tweek/CORBA \
                    $(EXTRA_CFLAGS) $(INCLUDES) $(DEFS)
CXX_IDL_OPTS	= -bcxx -Wbh=.h,s=.cpp -C$(srcdir)
CXX_IDL_INCLUDES	= -I$(TWEEK_BASE_DIR)/include
JAVAC_FLAGS	= -classpath $(CLASSPATH) -sourcepath $(srcdir) -d .
JAVA_IDL_OPTS	=  -d $(srcdir)
JAVA_IDL_INCLUDES	= -I$(TWEEK_BASE_DIR)/include

JAVA_ORB_JAR	= $(HOME)/OpenORB-1.2.0/lib/openorb-1.2.0.jar

TWEEK_EVENT_LIB	= $(TWEEK_BASE_DIR)/bin/TweekEvents.jar
TWEEK_NET_LIB	= $(TWEEK_BASE_DIR)/bin/TweekNet.jar
CLASSPATH	= $(TWEEK_EVENT_LIB):$(TWEEK_NET_LIB):$(JAVA_ORB_JAR)
DEFS		= -D__linux__ -D__OSVERSION__=2 -D__x86__
EXTRA_CFLAGS	= $(DEBUG_CFLAGS)
DEBUG_CFLAGS	= -g -D_DEBUG
OPTIM_CFLAGS	= -O2 -fno-strict-aliasing -D_OPT
INCLUDES		= -I$(TWEEK_BASE_DIR)/include -I$(HOME)/omni/include -I$(srcdir)

EXTRA_LFLAGS	= $(DEBUG_LFLAGS)
DEBUG_LFLAGS	= 
OPTIM_LFLAGS	= 
LINK_FLAGS	= $(EXTRA_LFLAGS)

# Libraries needed for linking.
BASIC_LIBS	= -Wl,-Bstatic $(LINKALL_ON) -L$(TWEEK_BASE_DIR)/lib -ltweek \
                    $(LINKALL_OFF) -Wl,-Bdynamic
EXTRA_LIBS	= -Wl,-Bdynamic  -L$(HOME)/omni/lib/i586_linux_2.0_glibc \
                    -lomniORB3 -lomnithread -lomniDynamic3 -lomniGK_stub   \
                    -L$(VPR_BASE_DIR)/lib -lvpr  -pthread   

# Commands to execute.
C_COMPILE	= gcc $(CFLAGS)
CXX_IDL		= $(HOME)/omni/bin/i586_linux_2.0_glibc/omniidl
CXX_COMPILE	= c++ $(CXXFLAGS)
JAVA_COMPILE	= /usr/java/jdk1.3.1_02/bin/javac $(JAVAC_FLAGS)
JAVA_IDL		= JACORB_PATH="$(TWEEK_BASE_DIR)/bin" "$(TWEEK_BASE_DIR)/bin/idl"
JAR		= /usr/java/jdk1.3.1_02/bin/jar
LINK		= c++ $(LINK_FLAGS)
LINKALL_ON	= -W,--whole-archive
LINKALL_OFF	= -W,--no-whole-archive

VPATH = $(srcdir):$(srcdir)/networktest:$(srcdir)/tweek:$(TWEEK_BASE_DIR)/include/tweek/idl

IDL_CXX_FILES	= SliderSubject.cpp SliderSubject.h
IDL_JAVA_FILES	= SliderSubject.java		\
                    Observer.java

OBJS		= SliderSubject.o SliderSubjectImpl.o	\
                    SliderSubjectApp.o
CLASSES		= networktest/NetworkTest.class		\
                    networktest/SliderObserverImpl.class	\
                    networktest/SliderSubjectHolder.class	\
                    tweek/ObserverHolder.class

NETWORK_TEST_CLASSES = networktest/*.class tweek/*.class

# -----------------------------------------------------------------------------
# Application build targets.
# -----------------------------------------------------------------------------
all:
	$(MAKE) cxx_idl
	$(MAKE) java_idl
	$(MAKE) cxx
	$(MAKE) server
	$(MAKE) java
	$(MAKE) NetworkTestBean.jar
	-$(MAKE) install

cxx_idl: $(IDL_CXX_FILES)

java_idl: $(IDL_JAVA_FILES)

cxx: $(OBJS)

java: $(CLASSES)

server: $(OBJS)
	$(LINK) -o $@ $(OBJS) $(BASIC_LIBS) $(EXTRA_LIBS)

NetworkTestBean.jar: $(CLASSES)
	$(JAR) cvfm $@ $(srcdir)/networktest.MF $(NETWORK_TEST_CLASSES)

install:
	cp NetworkTestBean.jar $(TWEEK_BASE_DIR)/bin/beans
	cp $(srcdir)/NetworkTestBean.xml $(TWEEK_BASE_DIR)/bin/beans

# Suffix rules for building object files.
.SUFFIXES: .cpp .o .java .class .idl .h

.cpp.o:
	$(CXX_COMPILE) -o $@ -c $&lt;

.java.class:
	$(JAVA_COMPILE) $&lt;

.idl.cpp:
	$(CXX_IDL) $(CXX_IDL_OPTS) $(CXX_IDL_INCLUDES) $&lt;

.idl.h:
	$(CXX_IDL) $(CXX_IDL_OPTS) $(CXX_IDL_INCLUDES) $&lt;

SliderSubject.java: SliderSubject.idl
	$(JAVA_IDL) $(JAVA_IDL_OPTS) -noskel $(JAVA_IDL_INCLUDES) $&lt;

.idl.java:
	$(JAVA_IDL) $(JAVA_IDL_OPTS) $(JAVA_IDL_INCLUDES) $&lt;

# -----------------------------------------------------------------------------
# Clean-up targets.
# -----------------------------------------------------------------------------
clean:
	rm -f Makedepend *.o networktest.ilk  so_locations *.?db	\
          core* $(addprefix $(srcdir)/, $(IDL_CXX_FILES))		\
          $(addprefix $(srcdir)/networktest/, $(IDL_JAVA_FILES))
	rm -rf ii_files $(srcdir)/tweek

clobber:
	@$(MAKE) clean
	rm -f server </programlisting>
         </section>
         <section id="FileLoader.makefile.section">
            <title>File Loader</title>
            <para>The following is a makefile that shows how to compile the code related to the file loader Bean example presented in <xref linkend="file.loader.section"/>. All it must do is compile the Java code for the Bean.</para>
            <programlisting># Generated automatically from Makefile.in by configure.
default: all

# Basic options.
srcdir		= .
JAVAC_FLAGS	= -classpath $(CLASSPATH) -sourcepath $(srcdir) -d .
JCPS		= :

JDOM_JAR		= $(JDOM_ROOT)/jdom.jar:$(JDOM_ROOT)/xerces.jar

TWEEK_SERV_LIB	= $(TWEEK_BASE_DIR)/bin/TweekServices.jar
TWEEK_NET_LIB	= $(TWEEK_BASE_DIR)/bin/TweekEvents.jar
CLASSPATH	= $(TWEEK_SERV_LIB):$(TWEEK_NET_LIB):$(JDOM_JAR)

# Commands to execute.
JAVA_COMPILE	= javac $(JAVAC_FLAGS)
JAR		= jar

VPATH		= .

CLASSES		= fileopentestbean/FileOpenTestBean.class
ALL_CLASSES	= fileopentestbean/*.class

# -----------------------------------------------------------------------------
# Application build targets.
# -----------------------------------------------------------------------------
all:
	$(MAKE) java
	$(MAKE) FileOpenTestBean.jar
	-$(MAKE) install

java: $(CLASSES)

FileOpenTestBean.jar: $(CLASSES)
	$(JAR) cvfm $@ $(srcdir)/opener_test.MF $(ALL_CLASSES)

install:
	cp FileOpenTestBean.jar $(TWEEK_BASE_DIR)/bin/beans
	cp $(srcdir)/FileOpenTestBean.xml $(TWEEK_BASE_DIR)/bin/beans

# Suffix rules for building object files.
.SUFFIXES: .java .class

.java.class:
	$(JAVA_COMPILE) $&lt;

# -----------------------------------------------------------------------------
# Clean-up targets.
# -----------------------------------------------------------------------------
clean:
	rm -rf fileopentestbean

clobber:
	@$(MAKE) clean
	rm -f FileOpenTestBean.jar</programlisting>
         </section>
      </appendix>
      <appendix id="orb-impl.appendix">
         <title>CORBA Implementations</title>
         <para>In order to use CORBA, a CORBA implementation must be available. As of this writing, Tweek uses omniORB 3.0.4 <xref linkend="Omn02"/> for a C++ ORB. Since Tweek uses POA, any C++ ORB may be used with only a few changes to the code.</para>
         <para>For the Java side, OpenORB 1.2.0 <xref linkend="Ope02"/> has been used. Java IDL <xref linkend="Jid02"/>, the CORBA implementation that comes with the Java Development Kit (JDK), does not fully implement POA as of JDK 1.3.1. With the release of JDK 1.4.0, Java IDL has a complete implementation and can be used without taking any special steps.</para>
         <para>To use an alternate ORB with Java, two arguments must be passed to the Java virtual machine. They are based on the ORB implementation. For example, if using OpenORB, the following two arguments must be specified:</para>
         <orderedlist>
            <listitem>
               <para><option>-Dorg.omg.CORBA.ORBClass=org.openorb.CORBA.ORB</option></para>
            </listitem>
            <listitem>
               <para><option>-Dorg.omg.CORBA.ORBSingletonClass=org.openorb.CORBA.ORB</option>Singleton</para>
            </listitem>
         </orderedlist>
         <para>Other ORBs will vary in the location of the <classname>ORBClass</classname> and the <classname>ORBSingletonClass</classname>. Refer to the documentation of the specific ORB to find out more about using it instead of Java IDL.</para>
      </appendix>
      <appendix>
         <title>Legal</title>
         <para>A full binary distribution of Tweek comes with binary code from several other software projects not affiliated with the Juggler Project or Iowa State University. Tweek makes use of redistributable code from the following packages:</para>
         <itemizedlist>
            <listitem>
               <para>JDOM (<ulink url="http://www.jdom.org/">http://www.jdom.org/</ulink>)</para>
            </listitem>
            <listitem>
               <para>JacORB (<ulink url="http://www.jacorb.org/">http://www.jacorb.org/</ulink>)</para>
            </listitem>
            <listitem>
               <para>Kuststoff look and feel (<ulink url="http://www.incors.org/">http://www.incors.org/</ulink>)</para>
            </listitem>
            <listitem>
               <para>Metouia look and feel (<ulink url="http://mlf.sourceforge.net/">http://mlf.sourceforge.net/</ulink>)</para>
            </listitem>
            <listitem>
               <para>OpenORB (<ulink url="http://openorb.exolab.org/">http://openorb.exolab.org/</ulink> or <ulink url="http://openorb.sourceforge.net/">http://openorb.sourceforge.net/</ulink>)</para>
            </listitem>
         </itemizedlist>
         <para>The licenses for each of these software packages can be found in <filename>$TWEEK_BASE_DIR/share/tweek/data/licenses</filename>.</para>
      </appendix>
   </part>
   <bibliography>
      <biblioentry id="Gam95">
         <biblioset relation="book">
            <authorgroup>
               <author>
                  <firstname>Erich</firstname>
                  <surname>Gamma</surname>
               </author>
               <author>
                  <firstname>Richard</firstname>
                  <surname>Helm</surname>
               </author>
               <author>
                  <firstname>Ralph</firstname>
                  <surname>Johnson</surname>
               </author>
               <author>
                  <firstname>John</firstname>
                  <surname>Vlissides</surname>
               </author>
            </authorgroup>
            <title>Design Patterns</title>
            <copyright>
               <year>1995</year>
               <holder>Addison Wesley Longman, Inc.</holder>
            </copyright>
            <isbn>0-201-63361-2</isbn>
            <publisher>
               <publishername>Addison-Wesley</publishername>
            </publisher>
         </biblioset>
      </biblioentry>
      <biblioentry id="Hen99">
         <biblioset relation="book">
            <authorgroup>
               <author>
                  <firstname>Michi</firstname>
                  <surname>Henning</surname>
               </author>
               <author>
                  <firstname>Steve</firstname>
                  <surname>Vinoski</surname>
               </author>
            </authorgroup>
            <title>Advanced CORBA Programming with C++</title>
            <copyright>
               <year>1999</year>
               <holder>Addison Wesley Longman, Inc.</holder>
            </copyright>
            <isbn>0-201-37927-9</isbn>
            <publisher>
               <publishername>Addison Wesley Longman, Inc.</publishername>
            </publisher>
         </biblioset>
      </biblioentry>
      <biblioentry id="Jbe02">
         <biblioset relation="website">
            <address><otheraddr><ulink url="http://java.sun.com/products/javabeans/">JavaBeans website</ulink></otheraddr></address>
         </biblioset>
      </biblioentry>
      <biblioentry id="Jid02">
         <biblioset relation="website">
            <address><otheraddr><ulink url="http://java.sun.com/products/jdk/idl/">Java IDL website</ulink></otheraddr></address>
         </biblioset>
      </biblioentry>
      <biblioentry id="Omn02">
         <biblioset relation="website">
            <address><otheraddr><ulink url="http://www.uk.research.att.com/omniORB/">omniORB website</ulink></otheraddr></address>
         </biblioset>
      </biblioentry>
      <biblioentry id="Ope02">
         <biblioset relation="website">
            <address><otheraddr><ulink url="http://www.openorb.com/">OpenORB website</ulink></otheraddr></address>
         </biblioset>
      </biblioentry>
   </bibliography>
   <glossary>
      <title>Glossary</title>
      <glossdiv>
         <title>A</title>
         <glossentry id="gloss.api">
            <glossterm>application programmer interface</glossterm>
            <acronym>API</acronym>
            <glossdef>
               <para>An application programmer interface is the documented, programatic interface used by programmers to access a software library.</para>
            </glossdef>
         </glossentry>
      </glossdiv>
      <glossdiv>
         <title>C</title>
         <glossentry id="gloss.corba">
            <glossterm>Common Object Request Broker Architecture</glossterm>
            <acronym>CORBA</acronym>
            <glossdef>
               <para>The Common Object Request Broker Architecture (CORBA) is a standard specified by the Object Management Group for distributed object-oriented programming. It is both platform- and language-independent. Implementations of CORBA are available from many vendors for a wide variety of programming languages.</para>
            </glossdef>
         </glossentry>
      </glossdiv>
      <glossdiv>
         <title>D</title>
         <glossentry id="gloss.distrib-programming">
            <glossterm>distributed programming</glossterm>
            <glossdef>
               <para>Distributed programming is a paradigm in which software components are installed on physically separated computers and accessed remotely though a network. Examples of distributed programming include Sun's Remote Procedure Calls (RPC), Java's Remote Method Invocation (RMI), Microsoft's Component Object Model (COM), and the Common Object Request Broker Architecture (CORBA). RPC is based on the procedural programming paradigm used by languages such as C and Pascal. With RPC, procedures residing in memory on remote machines are accessed. The other examples listed are based on the object-oriented programming paradigm used by languages such as C++, Java, Smalltalk, and Python. In this case, software objects and their methods are accessed remotely.</para>
            </glossdef>
         </glossentry>
      </glossdiv>
      <glossdiv>
         <title>E</title>
         <glossentry id="gloss.xml.main">
            <glossterm>Extensible Markup Language</glossterm>
            <acronym>XML</acronym>
            <glossdef>
               <para>The eXtensible Markup Language (XML) is a specification from the World Wide Web Consortium. XML itself is a language for specifying well-defined, structured document markup.</para>
            </glossdef>
         </glossentry>
      </glossdiv>
      <glossdiv>
         <title>G</title>
         <glossentry id="gloss.gui">
            <glossterm>graphical user interface</glossterm>
            <acronym>GUI</acronym>
            <glossdef>
               <para>Graphical user interfaces are used in modern operating systems that support the concept of <quote>windows</quote>. The windows provide a visual representation of an application and usually have a border and a title to distinguish one window from another. Within the window, there are graphical elements known as <quote>widgets</quote> that make up the full interface. Widgets include pull-down menus, clickable buttons, and scroll bars.</para>
            </glossdef>
         </glossentry>
      </glossdiv>
      <glossdiv>
         <title>I</title>
         <glossentry id="gloss.idl-compiler">
            <glossterm>IDL compiler</glossterm>
            <glossdef>
               <para>A software tool that reads an IDL file and generates code in a specific language (e.g., Java, C++, Smalltalk, etc.). This code may be anything, but typically, it is stub or skeleton code that is extended by user-defined code that completes the interface implementation.</para>
            </glossdef>
         </glossentry>
         <glossentry id="gloss.interface">
            <glossterm>interface</glossterm>
            <glossdef>
               <para>Several types of <quote>interfaces</quote> exist within the scope of Tweek:</para>
               <itemizedlist>
                  <listitem>
                     <para>In Java. there is a keyword <literal>interface</literal> that can be used to define a set of methods that must be part of an implementing class. Classes that claim to implement a given interface must define the methods described by the interface or declare themselves abstract.</para>
                  </listitem>
                  <listitem>
                     <para>In <glossterm linkend="gloss.idl">IDL</glossterm>, an interface is essentially identical to a Java interface, but an IDL compiler can generate code from the IDL. The interface methods must still be implemented (by a C++ class, for example), and thus, the main function of an IDL interface is to define a language-independent signature through which CORBA communication may occur.</para>
                  </listitem>
                  <listitem>
                     <para>In C++, there is no <literal>interface</literal> keyword as in Java and IDL. The term <quote>interface</quote> is typically applied to abstract classes (those with pure virtual methods). More generally, it is use to refer to the collection of methods defined by a class.</para>
                  </listitem>
               </itemizedlist>
            </glossdef>
         </glossentry>
         <glossentry id="gloss.idl">
            <glossterm>Interface Definition Language</glossterm>
            <acronym>IDL</acronym>
            <glossdef>
               <para>The Interface Definition Language is a simple language used to define the interface (or signature) an object will have. An interface is composed solely of methods (functions) that may be invoked on an object (data element). No data members are present in the interface definition. IDL is not tied to a specific language but instead must be compiled into another language where the interface will be implemented.</para>
            </glossdef>
         </glossentry>
         <glossentry id="gloss.iiop">
            <glossterm>Internet Inter-ORB Protocol</glossterm>
            <acronym>IIOP</acronym>
            <glossdef>
               <para>The Internet Inter-ORB Protocol (IIOP) is part of the CORBA specification. It is used to standardize communication between ORBs so that ORBs from different vendors can inter-operate seamlessly.</para>
            </glossdef>
         </glossentry>
      </glossdiv>
      <glossdiv>
         <title>J</title>
         <glossentry id="gloss.javabean">
            <glossterm>JavaBean</glossterm>
            <glossdef>
               <para>JavaBeans are the component architecture of the Java programming language. There are no restrictions on the interfaces implemented by JavaBeans, though it is strongly recommended that they implement <interfacename>java.io.Serializable</interfacename>.</para>
            </glossdef>
         </glossentry>
         <glossentry id="gloss.jni">
            <glossterm>Java Native Interface</glossterm>
            <acronym>JNI</acronym>
            <glossdef>
               <para>The Java Native Interface is the bridge between a Java virtual machine (JVM) and natively compiled code. Native code can load a JVM and get access to Java objects through it, or Java classes may have native methods that are loaded by the JVM.</para>
            </glossdef>
         </glossentry>
      </glossdiv>
      <glossdiv>
         <title>O</title>
         <glossentry id="gloss.orb">
            <glossterm>Object Request Broker</glossterm>
            <acronym>ORB</acronym>
            <glossdef>
               <para>An Object Request Broker (ORB) is used by CORBA for management of interface implementation objects (servants) and the references made to those objects. ORBs communicate with each other using a client/server model, though two ORBs may both act as servers and clients during the transactions.</para>
            </glossdef>
         </glossentry>
      </glossdiv>
      <glossdiv>
         <title>P</title>
         <glossentry id="gloss.poa">
            <glossterm>Portable Object Adapter</glossterm>
            <acronym>POA</acronym>
            <glossdef>
               <para>The Portable Object Adapter (POA) the standard object adapter and is part of the CORBA 2.3 specification. It is used together with IIOP to allow ORB implementations from different vendors to communicate. A single ORB may have multiple POAs each tailored to a certain task using parameterized characteristics.</para>
            </glossdef>
         </glossentry>
      </glossdiv>
      <glossdiv>
         <title>R</title>
         <glossentry id="gloss.rmi">
            <glossterm>Remote Method Invocation</glossterm>
            <acronym>RMI</acronym>
            <glossdef>
               <para>Remote Method Invocation (RMI) is a mechanism for gaining access to remote Java code. It is implemented as part of the Java virtual machine and was originally intended to be comparable to CORBA. RMI allows easy access to code between two virtual machines, but it does not have the cross-language features of CORBA.</para>
            </glossdef>
         </glossentry>
      </glossdiv>
      <glossdiv>
         <title>S</title>
         <glossentry id="gloss.servant">
            <glossterm>servant</glossterm>
            <glossdef>
               <para>In CORBA, a servant is an instance of an interface implementation that is registered with an ORB. A servant receives method invocations through the CORBA object adapter.</para>
            </glossdef>
         </glossentry>
      </glossdiv>
      <glossdiv>
         <title>X</title>
         <glossentry id="gloss.xml">
            <glossterm>XML</glossterm>
            <glossdef>
               <para>See <glossterm linkend="gloss.xml.main">Extensible Markup Language</glossterm>.</para>
            </glossdef>
         </glossentry>
      </glossdiv>
   </glossary>
   <index/>
</book>

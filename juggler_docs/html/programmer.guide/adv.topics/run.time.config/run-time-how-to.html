<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>How to write run</title>
<!-- install-web block-ignore-begin -->
<link rel="stylesheet" type="text/css" href="../../../../style/base_style.css">
<!-- install-web block-ignore-end -->
</head>

<body>

<!--NewPage-->
<h1>How to write run-time reconfig</h1>
<h2>How does run-time config work?</h2>
<h2>Why would I want to use it?</h2>
<p>Reasons to use it</p>
<h2>Run-time config examples</h2>
<h3>How can my app adapt to use it?</h3>

<ol>

<h4><li>Define application ChunkDescs</h4>

<p>
The first step in adding dynamic reconfiguration capabilities to an 
application is to decide what aspects of the application should be
configurable.  Naturally, this is very application-specific, but 
might include some of the following choices:

<p>
<ul>
<li>Initial parameters (position, color, etc.) of objects in the
environment.
<li>Navigational position.
<li>Global settings such as difficulty level of a game, or network
settings for a distributed application.
</ul>

<p>
Once you decide what sort of configuration information to include,
it is time to define the kinds of ConfigChunks which will contain 
it.  This essentially means creating a file containing one or more
ChunkDescs.

<p>
As an example, you might define an "Object" ChunkDesc in your
application, with properties that include the name and type of 
an object, its color and size, and so forth.

<p>
There are several ways to make sure your custom ChunkDescs are
read by your application.  One way is to explicitly load the
ChunkDesc file (described below), but the simplest way is to 
include your custom ChunkDesc file from one of the configuration 
files your app loads at startup.

<p>
Instructions for editing ChunkDesc files and creating new kinds
of ChunkDescs are included in the <I>VjControl User's Guide</I>.

<h4><li>Implement dynamic reconfiguration interface</h4>

The next step is to implement the dynamic reconfiguration
interface for your application object.  This interface is 
defined by the vjConfigChunkHandler class and consists
of three methods:

<ol>

<p>
<li><tt>virtual bool configCanHandle(vjConfigChunk* chunk)</tt>
<p>
This function should simply return a boolean, true or false,
depending on whether this object knows how to deal with the
ConfigChunk passed to it.  If this Chunk uses one of your 
application-custom ChunkDescs, you should return true.  For 
example:

<pre>
    std::string s = chunk->getType();
    if (!vjstrcasecmp (s, "my_custom_chunk_type"))
        return true;
</pre>

<p>
<li><tt>virtual bool configAdd (vjConfigChunk* chunk)</tt>
<p>
This method is called whenever a ConfigChunk is added to your
application, whether by loading a configuration file or 
through a dynamic reconfiguration event.  The chunk will have
already been passed through your application object's 
<tt>configCanHandle()</tt> method, so when <tt>configAdd()</tt>
is called, you know the chunk is meant for you.
<p>
When configAdd is called, your app should look at the chunk
passed to it and decide what to do.  This might involve 
creating a new object, changing the configuration of an already
extant object, changing the values of certain variables, etc.

<p>
<li><tt>virtual bool configRemove (vjConfigChunk* chunk)</tt>
<p>
This method is analogous to <tt>configAdd()</tt>, and is called
when VR Juggler receives a command to remove a particular
ConfigChunk.
<p>
If the ConfigChunk refers to a specific object in your 
application, the most obvious behavior would be to remove that
particular object.  If the ConfigChunk refers to some other
properties of your application, there are several choices for 
the correct behavior.  For example, you might choose to reset
those properties to their default values, or you might simply
choose to ignore the remove request.

</ol>


<h4><li>Processing ConfigChunks</h4>
<p>
When your application receives a ConfigChunk to process via
<tt>configAdd()</tt> or <tt>configRemove()</tt>, it needs to
retrieve the data in that Chunk in order to decide what to do.
ConfigChunks can be very complex, but the interface has been 
designed to be as simple as possible.  We will now describe 
a few of the most important methods in the ConfigChunk API.

<ol>
<p>
<li><tt>std::string& vjConfigChunk::getType()</tt>
<p>
This method returns the token of the ChunkDesc which describes
this ConfigChunk.  This is useful if your application uses
several kinds of custom ConfigChunk types, to distinguish one
from another.

<p>
<li><tt>vjVarValue& vjConfigChunk::getProperty 
                    (std::string& property_token, int num)</tt>
<p>
This is the key method for getting the information contained
in a ConfigChunk.  Its arguments are the token associated with
a property, and a numeric index (For example, a property 
might store a coordinate with 3 values, each of which can be
accessed separately by using the numbers 0, 1, or 2 for the
<tt>num</tt> parameter).
<p>
The return value for this method needs some explanation.
vjVarValue is a placeholder class, designed to be safely cast
to one of a variety of data types.  Basically, the return value
of <tt>getProperty()</tt> is cast to whichever type the caller
expects to receive (it is assumed that the caller knows the
types of values stored in a given property).
<p>
vjVarValue tries to coax the data in a variety of ways for 
convenience.  For example, the VarValue returned from an integer,
float, or boolean property can be safely cast to a string or
char *.  Booleans can be cast to integers and vice versa.
The following code fragment gives a few examples of this usage:

<pre>
    std::string s1 = (std::string)chunk->getProperty ("name", 0);
    char* s2 = (char*)chunk->getProperty ("name");
    // NOTE: the cast allocates new memory for s2, which you are
    // responsible for deleting.

    bool b = (bool)chunk->getProperty ("enabled");
    std::string s3 = (std::string)chunk->getProperty ("enabled");
    // s3 will be one of the strings "True" or "False"

    vjConfigChunk* ch = (vjConfigChunk*)chunk->getProperty ("embedded_chunk", 2);
    // ch is a copy of the embedded chunk. Once again, the caller
    // of getProperty() is responsible for freeing this memory.

</pre>

<p>
<li><tt>int getNum (const std::string& property_token) const;</tt>
<p>
Sometimes properties of a ConfigChunk can have a variable number of
values - a good example is a property that lists a set of files
to be loaded.  The <tt>getNum()</tt> method returns the actual
number of values of the named property.

</ol>

<p>
For definitive information about the ConfigChunk API, refer to
the VR Juggler <I>Programmer's Reference Guide</I>.

<h4><li>Loading and saving configurations</h4>

</ol>



<h3>Example app using it&nbsp;</h3>

</body>

</html>

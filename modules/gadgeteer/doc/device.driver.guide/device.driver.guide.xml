<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<book>
  <bookinfo>
    <title>Gadgeteer</title>

    <subtitle>Device Driver Authoring Guide</subtitle>

    <copyright>
      <year>2003–2006</year>

      <holder>Iowa State University</holder>
    </copyright>

    <legalnotice>
      <para>Permission is granted to copy, distribute and/or modify this
      document under the terms of the GNU Free Documentation License, Version
      1.2 or any later version published by the Free Software Foundation; with
      the Invariant Sections being <xref linkend="appendix.gfdl" />, with no
      Front-Cover Texts, and with no Back-Cover Texts. A copy of the license
      is included in <xref linkend="appendix.gfdl" />.</para>
    </legalnotice>

    <releaseinfo>Version 1.1</releaseinfo>

    <pubdate>$Date$</pubdate>
  </bookinfo>

  <part id="intro.part">
    <title id="programming.part">Introduction</title>

    <partintro>
      <para>We begin this book with some basic background information about
      Gadgeteer and the device drivers it uses. This part is written primarily
      for programmers who are new to Gadgeteer and VR Juggler in general.
      Rather than including technical content in this part, we instead review
      concepts and goals to provide new developers with an understanding of
      our motivations and our long-term goals for Gadgeteer.</para>
    </partintro>

    <chapter id="overview.chapter">
      <title>Overview of Gadgeteer</title>

      <indexterm>
        <primary>Gadgeteer</primary>

        <secondary>overview</secondary>
      </indexterm>

      <para>Gadgeteer acts as a hardware device management system. It contains
      a dynamically extensible Input Manager<indexterm>
          <primary>Input Manager</primary>
        </indexterm> that treats devices in terms of abstract concepts such as
      <quote>positional,</quote> <quote>digital,</quote>
      <quote>gesture,</quote> etc. It also contains a Remote Input
      Manager<indexterm>
          <primary>Remote Input Manager</primary>
        </indexterm> that can share device samples between computers. Most
      importantly, Gadgeteer provides device input for use with VR Juggler
      applications. As such, Gadgeteer was designed from the beginning to be
      used with an ever-widening array of virtual reality hardware
      configurations.</para>

      <section>
        <title>Goals of Gadgeteer</title>

        <indexterm>
          <primary>Gadgeteer</primary>

          <secondary>goals</secondary>
        </indexterm>

        <para>Gadgeteer serves to hide input device hardware from programmers
        so that immersive software may be written that can take advantage of a
        wide variety of devices. This goal arises from previous experience
        with software toolkits that tied immersive applications to specific
        devices, thereby limiting the portability of the applications between
        immersive hardware configurations. With Gadgeteer, applications can be
        written that migrate transparently between different hardware
        configurations with no required knowledge on the part of the
        application author relating to vendors, models, drivers, etc.</para>

        <para>Gadgeteer categorizes input devices based on abstract input
        types. The categories are the following:</para>

        <itemizedlist>
          <listitem>
            <para>Analog</para>
          </listitem>

          <listitem>
            <para>Command</para>
          </listitem>

          <listitem>
            <para>Digital</para>
          </listitem>

          <listitem>
            <para>Glove</para>
          </listitem>

          <listitem>
            <para>Gesture</para>
          </listitem>

          <listitem>
            <para>Position</para>
          </listitem>

          <listitem>
            <para>Simulator</para>
          </listitem>

          <listitem>
            <para>String</para>
          </listitem>
        </itemizedlist>

        <para>Each of these is described in more detail below in <xref
        linkend="device.types.section" />.</para>

        <para>In this categorization, devices from different vendors may
        return data that maps to the same abstract form. A single piece of
        hardware may even map to multiple input types, and more device types
        can be added as new hardware becomes available. Application authors
        write their code in terms of abstract input types, so as long as a
        device is available that provides the needed input, the application
        can function.</para>
      </section>

      <section id="driver.goals.section">
        <title>Goals for Device Driver Authors</title>

        <para>In keeping with the general goals of Gadgeteer, device driver
        authors should strive to achieve certain goals for each device driver
        they write. In no particular order, we feel that the most important
        goals are the following:</para>

        <itemizedlist>
          <listitem>
            <para>Portability</para>
          </listitem>

          <listitem>
            <para>Maintainability</para>
          </listitem>

          <listitem>
            <para>Efficiency</para>
          </listitem>

          <listitem>
            <para>Modularity</para>
          </listitem>
        </itemizedlist>

        <para>For the most part, these goals are no different than those of
        any other software project. Nonetheless, we will explain why each is
        important in the following subsections.</para>

        <section>
          <title>Portability</title>

          <para>Gadgeteer is a cross-platform device management system, and as
          such, the devices it manages should be usable on all platforms
          supported by Gadgeteer. While this may not always be
          possible<footnote>
              <para>There are various reasons why a given hardware device may
              not be usable between computers. For example, not all
              architectures have parallel ports, and thus, a parallel port
              device could not be expected to be used where no port is
              available. In general, however, the software device driver
              should not be the limiting factor in the use of a hardware
              device.</para>
            </footnote>, device driver authors should still attempt to make
          their drivers as portable as possible. The <glossterm
          linkend="gloss.vpr">VR Juggler Portable Runtime</glossterm> (VPR),
          introduced later in <xref linkend="vpr.chapter" />, provides many
          features that simplify the work of writing portable software. This
          applies to device drivers as much as any other piece of software,
          and thus, programmers should make use of VPR whenever
          possible.</para>
        </section>

        <section>
          <title>Maintainability</title>

          <para>Hardware tends to evolve over time, and new versions of a
          given device may be released. With new hardware, the communication
          protocol may change, either through extensions or through extensive
          changes. In order for Gadgeteer device drivers to be used with new
          hardware, a driver must be written so that it can be maintained by
          other programmers. That means that a driver should be documented
          well, and it should not use complex techniques to communicate with
          the hardware.</para>

          <para>Based on our experience, we recommend that the following
          practices when writing a new driver:</para>

          <itemizedlist>
            <listitem>
              <para>Do not <quote>brute force</quote> the driver
              implementation just to get something working. Implement the
              protocol clearly and completely.</para>
            </listitem>

            <listitem>
              <para>Do not hard-code maximum values to match a local
              installation or the current limitations of the hardware. For
              example, if a positional tracker at the local facility only has
              two trackers attached to it, do not assume that everyone else
              has the same configuration.</para>
            </listitem>

            <listitem>
              <para>Do not do tricks with memory buffers. C and C++ provide
              very nice features for accessing blocks of memory, so there is
              usually no need to do pointer math by hand. More often than not,
              a <literal>struct</literal> or a <literal>union</literal> will
              do a much better job than an array of bytes.</para>
            </listitem>
          </itemizedlist>
        </section>

        <section>
          <title>Efficiency</title>

          <para>Input devices used with virtual reality systems tend to sample
          at a much higher rate than the graphics are rendered (1000 Hz versus
          60 Hz). Thus, for a given frame, the driver may make tens or
          hundreds of samples. Gadgeteer provides some facilities for
          efficient collection of samples, but ultimately, the driver author
          must ensure that the driver will not overwhelm the local computer
          (or the network if the Remote Input Manager is being used). On the
          other hand, minimizing input latency is very important in achieving
          good suspension of disbelief on the part of the user. Thus, it is
          not advisable to discard samples.</para>

          <para>The key thing to keep in mind when writing a device driver for
          Gadgeteer is that the driver will be running asynchronously from the
          graphics. Usually, the sample rate will be limited by how fast the
          sample can be read from the hardware, be it a memory access, a
          serial port read, or a network buffer read. A balance between low
          latency, memory efficiency, and possibly network efficiency must be
          found.</para>
        </section>

        <section>
          <title>Modularity</title>

          <para>The current practices used in Gadgeteer encourage modularity
          of device drivers. Each driver should be able to stand on its own as
          a single unit within the Input Manager. This philosophy allows
          individual drivers to be loaded on demand at runtime, and it
          simplifies compilation of drivers that are not supported on all
          operating systems.</para>
        </section>
      </section>
    </chapter>

    <chapter id="vpr.chapter">
      <title>Using the VR Juggler Portable Runtime</title>

      <indexterm>
        <primary>VPR</primary>

        <secondary>using</secondary>
      </indexterm>

      <indexterm>
        <primary>VPR</primary>

        <secondary>overview</secondary>
      </indexterm>

      <para>In this chapter, we will review briefly key components of the
      <ulink url="http://www.vrjuggler.org/vapor/">VR Juggler Portable
      Runtime</ulink> (VPR) that will be used by Gadgeteer device driver
      authors. This chapter is not meant to be a comprehensive description of
      VPR but rather a small guide to be used by programmers new to Gadgeteer,
      VPR, and other modules used by VR Juggler. We assume that the reader has
      some familiarity with operating system programming, in particular with
      serial device I/O, socket I/O, and multi-threaded techniques. One or
      more of these will almost certainly come into play when writing a device
      driver for use with Gadgeteer.</para>

      <para>For those developers new to Gadgeteer and VPR, VPR provides an
      cross-platform, object-oriented abstraction layer to common operating
      system features. VPR is the key to the portability of Gadgeteer, Tweek,
      VR Juggler, and other middleware written at the Virtual Reality
      Applications Center. It has been in development since January 1997, and
      it has grown to be a highly portable, robust tool. Software written on
      top of VPR can be compiled on IRIX, Linux, Windows, FreeBSD, and
      Solaris, usually without modification.</para>

      <para>Internally, VPR wraps platform-specific APIs such as BSD sockets,
      POSIX threads, and Win32 overlapped I/O. Depending upon how it is
      compiled, it may also wrap the <ulink
      url="http://www.mozilla.org/projects/nspr/index.html">Netscape Portable
      Runtime</ulink> (<glossterm linkend="gloss.nspr">NSPR</glossterm>),
      another cross-platform OS abstraction layer written in C. By wrapping
      NSPR, VPR provides developers with an object-oriented interface and
      gains even better portability. These details are all hidden behind the
      classes that make up VPR, and users of VPR do not need to worry about
      platform-specific details as a result.</para>

      <section>
        <title>Buffered I/O</title>

        <para>Before discussing features of VPR useful to device driver
        authors, we must first understand how I/O is handled in VPR. All I/O
        classes (file handles, serial ports, and sockets) share the base class
        <classname>vpr::BlockIO</classname><indexterm>
            <primary>classes</primary>

            <secondary>vpr::BlockIO</secondary>
          </indexterm>. Reads and writes are performed using blocks of memory
        (buffers). This design provides an API that more closely resembles
        that of the underlying operating system (with methods called
        <methodname>read()</methodname> and <methodname>write()</methodname>),
        but it is in contrast to stream-oriented I/O that is usually seen in
        C++. Streams could be written on top of the buffered I/O classes, but
        thus far, the need has not arisen. With this in mind, the design
        provides an API that is immediately familiar to programmers used to
        POSIX-based interfaces, but the API may seem clumsy to C++ programmers
        who are accustomed to using <type>std::ostream</type> and
        friends.</para>
      </section>

      <section id="vpr.serial-ports.section">
        <title>Serial Ports</title>

        <indexterm>
          <primary>VPR</primary>

          <secondary>serial port abstraction</secondary>
        </indexterm>

        <para>Most input devices used for virtual reality systems today make
        use of a computer's serial port for data communication. For that
        reason, it is important that device driver authors have at least a
        basic understanding of the concepts behind the VPR serial port
        abstraction. In our experience, serial port programming is not much
        different than other I/O programming. Implementing the communication
        protocol used by a given device tends to be the hard part, and that
        will likely be the case regardless of the underlying hardware.</para>

        <para>The VPR serial port abstraction is based on the concepts
        implemented by the standard termios serial interface used by most
        modern UNIX-based operating systems <xref
        linkend="ref.advanced.prog.unix" />. As such, the API allows enabling
        and disabling of a subset of the serial device features that can be
        manipulated using termios directly. To provide cross-platform
        semantics, however, some termios features are not included because
        there is no corresponding capability with Win32 overlapped I/O.
        Furthermore, any termios settings that relate specifically to modems
        are not included in the VPR serial port abstraction.</para>
      </section>

      <section id="vpr.sockets.section">
        <title>Sockets</title>

        <indexterm>
          <primary>VPR</primary>

          <secondary>socket abstraction</secondary>
        </indexterm>

        <note>
          <para>Readers not familiar with socket programming should consult a
          reference manual (<xref linkend="ref.unix.network.programming" /> is
          recommended). We do not attempt to explain the ins and outs of
          socket programming. Instead, we assume that readers are familiar
          with socket-level I/O and the ideas involved with various types of
          network communication.</para>
        </note>

        <para>The socket abstraction follows the concepts set forth by the
        <glossterm linkend="gloss.bsd.sockets">BSD sockets</glossterm> API,
        which was also the model for the Winsock API used on Windows. In VPR,
        two types of sockets may be instantiated: stream-oriented (TCP,
        <classname>vpr::SocketStream</classname><indexterm>
            <primary>classes</primary>

            <secondary>vpr::SocketStream</secondary>
          </indexterm>) and datagram (UDP,
        <classname>vpr::SocketDatagram<indexterm>
            <primary>classes</primary>

            <secondary>vpr::SocketDatagram</secondary>
          </indexterm></classname>). The helper class
        <classname>vpr::InetAddr</classname><indexterm>
            <primary>classes</primary>

            <secondary>vpr::InetAddr</secondary>
          </indexterm> makes use of Internet Protocol (v4) addresses easier.
        Built on top of <classname>vpr::SocketStream</classname> are two
        classes that make writing client/server code easier:
        <classname>vpr::SocketConnector</classname><indexterm>
            <primary>classes</primary>

            <secondary>vpr::SocketConnector</secondary>
          </indexterm> and
        <classname>vpr::SocketAcceptor</classname><indexterm>
            <primary>classes</primary>

            <secondary>vpr::SocketAcceptor</secondary>
          </indexterm>. The <classname>vpr::System</classname><indexterm>
            <primary>classes</primary>

            <secondary>vpr::System</secondary>
          </indexterm> interface provides cross-platform data conversion
        functions to deal with endian issues.</para>

        <para>The utility of various socket classes will vary depending on the
        needs of a given driver protocol. It is usually safe to assume that
        the driver will connect to a server of some sort that will send out
        device samples. Unpacking information from the samples may or may not
        be necessary, depending on the protocol. Such concerns are left
        entirely to the driver authors.</para>
      </section>

      <section id="vpr.threads.chapter">
        <title>Threads</title>

        <indexterm>
          <primary>VPR</primary>

          <secondary>thread abstraction</secondary>
        </indexterm>

        <para>All device drivers written for Gadgeteer will process samples in
        a thread separate from the Input Manager. We have chosen this design
        to avoid the complications that often arise from using non-blocking
        I/O and to allow the drivers to act more as independent entities.
        Thus, it will be important to understand how to use the VPR thread
        interface.</para>

        <para>First and foremost, developers must always remember that
        Gadgeteer uses a shared-memory model for all threads, regardless of
        the underlying platform-specific thread interface. This follows the
        lightweight thread model set forth by the POSIX threads (pthreads)
        standard. With a shared-memory model, all threads have access the same
        memory, and thus it will almost certainly be necessary to control
        access to shared variables. In most cases, the class
        <classname>vpr::Mutex</classname><indexterm>
            <primary>classes</primary>

            <secondary>vpr::Mutex</secondary>
          </indexterm> will provide sufficient control over multi-threaded
        data access.</para>

        <caution>
          <para>Multi-threaded programming can be tricky, and it is not
          something that most people can jump into without some background.
          Those developers who have not done multi-threaded programming before
          should review a manual or other reference on the topic before
          beginning work on a new driver. VPR threads are semantically similar
          to pthreads, and the concepts inherent in multi-threaded programming
          (e.g., protecting critical sections) will be the same regardless of
          the specific implementation. To learn more about pthreads
          specifically, we recommend <xref
          linkend="ref.pthreads.programming" />.</para>
        </caution>

        <para>Device driver authors will probably not have to do much with
        shared data access control because the driver will operate almost
        entirely in the sample loop thread. Any other method invocations
        (starting the driver, stopping it, configuring it, etc.) will happen
        in the Input Manager thread, and common memory accesses have
        pre-defined helper methods to simplify the work of driver authors.
        These details will be explained further in later chapters.</para>
      </section>

      <section>
        <title>Programmer Reference</title>

        <indexterm>
          <primary>VPR</primary>

          <secondary>programmer reference</secondary>
        </indexterm>

        <para>The various VPR abstraction interfaces are documented
        extensively, and readers are encouraged to review the VPR Programmer
        Reference (refer to <ulink url="http://www.vrjuggler.org/vapor/">the
        VPR website</ulink> for more information).</para>

        <para>The VPR class names follow a standard convention, and
        understanding this can be helpful in navigating the API documentation.
        Classes that wrap platform-specific interfaces are named as follows:
        <classname>vpr::&lt;Type&gt;&lt;Platform&gt;</classname>. For example,
        the NSPR implementation of <classname>vpr::SocketStream</classname> is
        named <classname>vpr::SocketStreamNSPR</classname>. Here, &lt;Type&gt;
        is <quote>SocketStream</quote>, and &lt;Platform&gt; is
        <quote>NSPR</quote>. The full list of platform names (as spelled in
        the class names) is as follows:</para>

        <itemizedlist>
          <listitem>
            <para>Posix: Used for general POSIX-specified interfaces</para>
          </listitem>

          <listitem>
            <para>BSD: Used for the BSD socket wrapper classes</para>
          </listitem>

          <listitem>
            <para>Termios: Used for the termios serial port wrapper
            classes</para>
          </listitem>

          <listitem>
            <para>NSPR: Used for NSPR wrapper classes</para>
          </listitem>

          <listitem>
            <para>SPROC: Used for the SPROC thread wrapper class</para>
          </listitem>

          <listitem>
            <para>Win32: Used for Win32-specific wrapper classes</para>
          </listitem>
        </itemizedlist>
      </section>
    </chapter>
  </part>

  <part>
    <title>Programming</title>

    <partintro>
      <para>In this part of the book, we explain how to write device drivers
      and add them to Gadgeteer. We begin with a detailed description of
      device driver conventions in Gadgeteer and how the drivers fit into the
      Input Manager. We then explain how drivers are configured using JCCL.
      Throughout the following chapters, example code will be provided.</para>
    </partintro>

    <chapter>
      <title>Drivers and the Input Manager</title>

      <para>As its name suggests, the Input Manager is in charge of managing
      the active input devices and the samples those devices return. Each
      device driver will hand off a freshly read sample (also known as a
      sample buffer) to the Input Manager.</para>

      <section>
        <title>Drivers as Input Manager Plug-Ins</title>

        <indexterm>
          <primary>device drivers</primary>

          <secondary>plug-ins</secondary>
        </indexterm>

        <para>The Input Manager itself never cares about the true type of a
        device. Instead, it looks at each driver as an implementation of the
        <interfacename>gadget::Input</interfacename><indexterm>
            <primary>classes</primary>

            <secondary>gadget::Input</secondary>
          </indexterm> interface. This design lends itself well to a plug-in
        architecture wherein drivers can be loaded at runtime without being
        compiled into Gadgeteer. Using the Gadgeteer driver plug-in system,
        users can write their own device drivers without modifying Gadgeteer
        at all. Indeed, they need not even compile Gadgeteer from its source.
        All that is needed is a binary installation of Gadgeteer against which
        the user-written driver can be compiled.</para>
      </section>

      <section id="device.types.section">
        <title>Device Types</title>

        <indexterm>
          <primary>device types</primary>
        </indexterm>

        <para>As of this writing, there are five key device types handled by
        the Input Manager:</para>

        <orderedlist>
          <listitem>
            <para>Analog: <classname>gadget::Analog</classname><indexterm>
                <primary>classes</primary>

                <secondary>gadget::Position</secondary>
              </indexterm></para>
          </listitem>

          <listitem>
            <para>Command: <classname>gadget::Command</classname><indexterm>
                <primary>classes</primary>

                <secondary>gadget::Command</secondary>
              </indexterm></para>
          </listitem>

          <listitem>
            <para>Digital: <classname>gadget::Digital</classname><indexterm>
                <primary>classes</primary>

                <secondary>gadget::Digital</secondary>
              </indexterm></para>
          </listitem>

          <listitem>
            <para>Glove: <classname>gadget::Glove</classname><indexterm>
                <primary>classes</primary>

                <secondary>gadget::Glove</secondary>
              </indexterm></para>
          </listitem>

          <listitem>
            <para>Position: <classname>gadget::Position</classname><indexterm>
                <primary>classes</primary>

                <secondary>gadget::Position</secondary>
              </indexterm></para>
          </listitem>

          <listitem>
            <para>String: <classname>gadget::String</classname><indexterm>
                <primary>classes</primary>

                <secondary>gadget::String</secondary>
              </indexterm></para>
          </listitem>

          <listitem>
            <para>Simulator: <classname>gadget::SimInput</classname><indexterm>
                <primary>classes</primary>

                <secondary>gadget::SimInput</secondary>
              </indexterm>,
            <classname>gadget::SimPosition</classname><indexterm>
                <primary>classes</primary>

                <secondary>gadget::SimPosition</secondary>
              </indexterm>,
            <classname>gadget::SimDigital</classname><indexterm>
                <primary>classes</primary>

                <secondary>gadget::SimDigital</secondary>
              </indexterm>, <classname>gadget::SimAnalog</classname><indexterm>
                <primary>classes</primary>

                <secondary>gadget::SimAnalog</secondary>
              </indexterm>, <classname>gadget::SimGlove</classname><indexterm>
                <primary>classes</primary>

                <secondary>gadget::SimGlove</secondary>
              </indexterm></para>
          </listitem>
        </orderedlist>

        <section>
          <title>Analog</title>

          <indexterm>
            <primary>device types</primary>

            <secondary>analog</secondary>
          </indexterm>

          <para>Analog input represents a continuous range of values. Of
          course, with digital computers, analog values can only be simulated.
          In Gadgeteer, this simulation is performed using floating-point
          values.</para>

          <para>At the application level, programmers get values from an
          analog device in the range 0.0 to 1.0 inclusive. In other words,
          values returned by an analog device are normalized before they are
          returned to the application. This allows applications to get analog
          input from a variety of analog devices without depending on a
          specific range of values returned by any given device.</para>
        </section>

        <section>
          <title>Command</title>

          <indexterm>
            <primary>device types</primary>

            <secondary>command</secondary>
          </indexterm>

          <para></para>
        </section>

        <section>
          <title>Digital</title>

          <indexterm>
            <primary>device types</primary>

            <secondary>digital</secondary>
          </indexterm>

          <para>Digital input comes in discrete forms, as its name suggests.
          However, a digital device in Gadgeteer terms corresponds most
          closely with a button device that has an <quote>on</quote> state and
          an <quote>off</quote> state. In that regard, a more appropriate name
          for a digital device within Gadgeteer would be a Boolean device,
          except that Gadgeteer provides more than just two values for input
          from a digital device. Due to its frame-based nature, Gadgeteer can
          tell users when the state of a digital device has changed since the
          last frame, thereby allowing for up to four values to be returned
          from a digital device:</para>

          <orderedlist>
            <listitem>
              <para>On: The device is in the on state.</para>
            </listitem>

            <listitem>
              <para>Off: The device is in the off state.</para>
            </listitem>

            <listitem>
              <para>Toggle on: The device was in the off state during the last
              frame and changed to the on state this frame.</para>
            </listitem>

            <listitem>
              <para>Toggle off: The device was in the on state during the last
              frame and changed to the off state this frame.</para>
            </listitem>
          </orderedlist>

          <para>The management of the toggle states is handled by Gadgeteer;
          devices simply need to collect the raw on and off values.</para>
        </section>

        <section>
          <title>Gesture</title>

          <indexterm>
            <primary>device types</primary>

            <secondary>gesture</secondary>
          </indexterm>

          <para></para>
        </section>

        <section>
          <title>Glove</title>

          <indexterm>
            <primary>device types</primary>

            <secondary>glove</secondary>
          </indexterm>

          <para></para>
        </section>

        <section>
          <title>Position</title>

          <indexterm>
            <primary>device types</primary>

            <secondary>position</secondary>
          </indexterm>

          <para>Positional input is usually collected from a
          six-degree-of-freedom (6DOF) tracker such as a Polhemus Fastrak or
          an Ascension MotionStar. Thus, position devices in Gadgeteer return
          samples as standard 4×4 transformation matrices representing the
          position and orientation of a specific tracker. A tracker may not be
          able to track all six degrees of freedom, and this is allowed with
          the Gadgeteer position input type.</para>
        </section>

        <section>
          <title>Simulator</title>

          <indexterm>
            <primary>device types</primary>

            <secondary>simulator</secondary>
          </indexterm>

          <para>For each of the above, there is at least one corresponding
          simulator device type<footnote>
              <para>Gadgeteer is designed so that users may write new
              simulator devices. In fact, we encourage this so that we can
              expand on the ways that various input types may be
              <quote>simulated</quote> for desktop use.</para>
            </footnote>. Such a device stands in for the corresponding
          <quote>real</quote> device when one is not available. For example,
          when using a VR application on the desktop, a 6DOF position tracker
          is not usually available. Instead, the mouse and keyboard could be
          used to stand in for the 6DOF tracker. Alternatively, a 3D graphical
          user interface (GUI) could be written using GLUT to provide a more
          visually expressive desktop tracker stand-in.</para>

          <para>The word <quote>simulator</quote> is a bit of a misnomer. As
          noted above, these devices act more as stand-ins when another device
          is not available. To a VR application, the data returned will look
          exactly the same, but the input mechanism employed by the user will
          vary.</para>
        </section>

        <section>
          <title>String</title>

          <indexterm>
            <primary>device types</primary>

            <secondary>string</secondary>
          </indexterm>

          <para></para>
        </section>
      </section>

      <section>
        <title>The Input Mixer</title>

        <indexterm>
          <primary>input mixer</primary>
        </indexterm>

        <indexterm>
          <primary>classes</primary>

          <secondary>gadget::InputMixer&lt;S,T&gt;</secondary>
        </indexterm>

        <para>The second version of the Remote Input Manager<indexterm>
            <primary>Remote Input Manager</primary>
          </indexterm>, introduced in mid-2002, implemented input distribution
        by sharing devices rather than proxies, as done in the original
        version <xref linkend="ref.eolson.thesis" />. This refactoring has
        changed the class hierarchy for device drivers. Previously, classes
        such as <classname>gadget::Digital</classname><indexterm>
            <primary>classes</primary>

            <secondary>gadget::Digital</secondary>
          </indexterm> and <classname>gadget::Position</classname><indexterm>
            <primary>classes</primary>

            <secondary>gadget::Position</secondary>
          </indexterm> derived from
        <classname>gadget::Input</classname><indexterm>
            <primary>classes</primary>

            <secondary>gadget::Input</secondary>
          </indexterm>, and device drivers used multiple inheritance to derive
        from one or more of <classname>gadget::Analog</classname><indexterm>
            <primary>classes</primary>

            <secondary>gadget::Analog</secondary>
          </indexterm>, <classname>gadget::Digital</classname>, etc.</para>

        <para>With the introduction of
        <classname>gadget::InputMixer&lt;S,T&gt;</classname>, device drivers
        now derive from this single template class. More information will be
        given in <xref linkend="add.dev.driver.chapter" />, but as an example,
        consider a driver for a positional device. In VR Juggler 1.0 and in
        early versions of Gadgeteer, such a driver class would have derived
        from <classname>gadget::Position</classname><indexterm>
            <primary>classes</primary>

            <secondary>gadget::Position</secondary>
          </indexterm>. Now, it would derive from
        <classname>gadget::InputMixer&lt;gadget::Input,
        gadget::Position&gt;</classname>. Use of
        <classname>gadget::InputMixer&lt;S,T&gt;</classname> is required if a
        device is to be used with the Remote Input Manager. If the old class
        hierarchy is used (which is still allowed), the device cannot be
        shared between computers.</para>

        <note>
          <para>As of this writing, the Input Mixer is not expected to be a
          long-term solution. A future version of Gadgeteer may do away with
          <classname>gadget::InputMixer&lt;S,T&gt;</classname>, and as such,
          driver authors should be aware of potential API changes in the
          future.</para>
        </note>
      </section>
    </chapter>

    <chapter id="driver.conventions.chapter">
      <title>Device Driver Conventions</title>

      <para>Before we get into the actual coding process, we must first
      explain the conventions we have used in writing device drivers for
      Gadgeteer. We strongly recommend that all new drivers follow these
      conventions as they have proven successful for us for many years.</para>

      <section>
        <title>Separation of Code</title>

        <para>The most obvious convention that can be seen upon review of
        existing device drivers is a separation of the driver code into two
        pieces: a standalone, <quote>low-level</quote> driver and a Gadgeteer
        wrapper around the standalone driver.</para>

        <para>In this design, the standalone driver implements the complete
        hardware communication protocol without using any features of
        Gadgeteer. As such, it stands completely on its own and does not need
        Gadgeteer to be used. The result is that the driver can be tested and
        debugged without worrying that some part of Gadgeteer could be causing
        the driver to malfunction. Driver authors can focus entirely on
        implementing the hardware communication protocol so as to feel
        confident that the low-level driver is implemented correctly.</para>

        <note>
          <para>The standalone driver should use VPR to ensure portability.
          For example, a driver that will communicate with the hardware via
          the serial port should use the VPR serial port abstraction. For more
          information, refer to <xref linkend="vpr.chapter" /> and to <xref
          linkend="driver.goals.section" />.</para>
        </note>

        <tip>
          <para>The low-level driver should have an easy-to-use interface that
          allows effective manipulation of the driver state (starting,
          stopping, requesting a sample, etc.). To develop a good interface
          and to test the standalone driver, write an application that creates
          an instance of the standalone driver, starts the driver running, and
          collects samples. In writing the test application, the interface can
          be matured for use by the Gadgeteer wrapper.</para>
        </tip>

        <para>Around the low-level driver, a Gadgeteer wrapper is added. This
        wrapper makes use of the standalone driver interface to activate the
        driver and read samples. The wrapper class will derive from one or
        more of the Gadgeteer device types described in <xref
        linkend="device.types.section" />. Instances of the wrapper class will
        be handled by the Input Manager.</para>

        <tip>
          <para>Do not put a sample loop in the low-level driver. Instead,
          provide a <methodname>sample()</methodname> method in the standalone
          driver API that the wrapper can call repeatedly. This allows the
          sample thread to be managed by the Gadgeteer wrapper class.</para>
        </tip>
      </section>
    </chapter>

    <chapter id="add.dev.driver.chapter">
      <title>Writing Device Drivers</title>

      <indexterm>
        <primary>device drivers</primary>

        <secondary>writing</secondary>
      </indexterm>

      <para>At long last, we have covered enough background information to
      explain how to add device drivers to Gadgeteer. In this chapter, we will
      examine a very simple device that has an on state and an off state. The
      general flow of this chapter will model the process that driver
      programmers would normally follow when writing a new driver from
      scratch.</para>

      <section>
        <title>Identifying the Device Type</title>

        <indexterm>
          <primary>device drivers</primary>

          <secondary>implementing</secondary>

          <tertiary>identifying device type</tertiary>
        </indexterm>

        <para>As discussed in <xref linkend="device.types.section" />, there
        are a set of abstract device types supported by Gadgeteer. Based on
        its capabilities, a new device will fall into at least one of the
        device type categories. It is perfectly valid for a single device to
        provide more than one type of input. For example, an Immersion Tech
        IBox returns both analog and digital data. Determining the device type
        for a new piece of hardware should be the easiest part of the driver
        authoring process.</para>
      </section>

      <section>
        <title>Implementing the Standalone Device Driver</title>

        <indexterm>
          <primary>device drivers</primary>

          <secondary>implementing</secondary>

          <tertiary>standalone driver</tertiary>
        </indexterm>

        <para>The standalone device driver makes use of
        <emphasis>nothing</emphasis> in Gadgeteer. It can utilize dependencies
        of Gadgeteer including VPR and GMTL, however. Reusing code from those
        projects is encouraged. In particular, writing the driver on top of
        VPR allows it to be much more portable than it would be if all the
        cross-platform code were written from scratch. The reason that the
        standalone driver does not use Gadgeteer is so that it can be tested
        without needing any of the complexity of the Input Manager, thereby
        allowing easier, more direct debugging.</para>

        <para>In most cases the standalone driver should be an implementation
        of the hardware communication protocol and nothing more. The
        standalone driver is written as a single C++ class that provides an
        interface that the Gadgeteer wrapper class can call. The interface
        normally has methods such as <methodname>open()</methodname>,
        <methodname>sample()</methodname>, and
        <methodname>close()</methodname> for opening the connection to the
        hardware, collecting a single sample, and closing the connection to
        the hardware respectively.</para>

        <para>The standalone driver class should return data it is most raw
        form in the majority of cases, but the data should be meaningful. For
        example, if logic is needed to convert four bytes read from the
        hardware into a single floating-point value (a <type>float</type>),
        that should be performed in the standalone driver. That sort of data
        processing is part of implementing the communication protocol.
        However, processing such as unit conversion should not be done in the
        standalone driver in most cases. Instead, such conversions should be
        handled by the Gadgeteer wrapper class since that is where the unit
        configuration is done.</para>

        <para>Typically, the standalone driver will not be multi-threaded.
        Instead, a method with a name such as
        <methodname>sample()</methodname> should be provided that returns a
        single sample. Then, test code and the Gadgeteer wrapper class can
        call the sampling method in a loop which may or may not be run in a
        thread.</para>

        <para>With this design, the standalone driver class can be tested by
        writing a simple console application that makes an instance of the
        class and invokes each of the methods. The application can be
        interactive so that users can configure aspects of the driver and take
        samples. This makes debugging and data validation easy.</para>
      </section>

      <section>
        <title>Implementing the Gadgeteer Wrapper Class</title>

        <indexterm>
          <primary>device drivers</primary>

          <secondary>implementing</secondary>

          <tertiary>Gadgeteer wrapper class</tertiary>
        </indexterm>

        <para>The Gadgeteer wrapper class has the job of passing samples read
        from the standalone driver off to the Input Manager. Depending on the
        device type, a given sample must be of a certain form. This is where
        sample buffers come into play. We will discuss sample buffers later in
        this section, but the possible sample buffer types are the
        following:</para>

        <itemizedlist>
          <listitem>
            <para><classname>gadget::AnalogData</classname><indexterm>
                <primary>classes</primary>

                <secondary>gadget::AnalogData</secondary>
              </indexterm></para>
          </listitem>

          <listitem>
            <para><classname>gadget::CommandData</classname><indexterm>
                <primary>classes</primary>

                <secondary>gadget::CommandData</secondary>
              </indexterm></para>
          </listitem>

          <listitem>
            <para><classname>gadget::DigitalData</classname><indexterm>
                <primary>classes</primary>

                <secondary>gadget::DigitalData</secondary>
              </indexterm></para>
          </listitem>

          <listitem>
            <para><classname>gadget::GloveData</classname><indexterm>
                <primary>classes</primary>

                <secondary>gadget::GloveData</secondary>
              </indexterm></para>
          </listitem>

          <listitem>
            <para><classname>gadget::PositionData</classname><indexterm>
                <primary>classes</primary>

                <secondary>gadget::PositionData</secondary>
              </indexterm></para>
          </listitem>

          <listitem>
            <para><classname>gadget::StringData</classname><indexterm>
                <primary>classes</primary>

                <secondary>gadget::StringData</secondary>
              </indexterm></para>
          </listitem>
        </itemizedlist>

        <section>
          <title>Choose the Base Class(es)</title>

          <para>As discussed earlier in <xref
          linkend="device.types.section" />, all device drivers in Gadgeteer
          must derive from one or more classes based on the device type. If a
          driver is to be used with the Remote Input Manager (i.e., there
          exists a desire to share a device between two or more computers),
          then the base class must be
          <classname>gadget::InputMixer&lt;S,T&gt;</classname> with
          appropriate device type classes given as the template parameters.
          If, for whatever reason, the device will not be used with the Remote
          Input Manager, it may derive from one or more of the device type
          classes directly using multiple inheritance.</para>

          <para>For example, to make a driver that registers button presses,
          derive from <classname>gadget::Digital</classname>:</para>

          <programlisting>class ButtonDevice
   : public gadget::InputMixer&lt;gadget::Input, gadget::Digital&gt;</programlisting>

          <para>Suppose that a game controller driver supporting buttons and
          joystick axes is needed. In this case, an additional component is
          needed for the for analog input from the X and Y axes. Since the
          device is both digital and analog, its class must derive from both
          <classname>gadget::Digital</classname> and
          <classname>gadget::Analog</classname> using C++ multiple
          inheritance:</para>

          <programlisting>class JoystickDevice
   : public gadget::InputMixer&lt;gadget::Input,
                               gadget::InputMixer&lt;gadget::Digital,
                                                  gadget::Analog&gt; &gt;</programlisting>

          <para>Using the type <classname>ButtonDevice</classname> as declared
          above, we will proceed with the implementation of the driver class.
          There are six member functions that must be implemented by every
          driver class:</para>

          <orderedlist>
            <listitem>
              <para><methodname>startSampling()</methodname>: A pure virtual
              member function declared by
              <classname>gadget::Input</classname></para>
            </listitem>

            <listitem>
              <para><methodname>stopSampling()</methodname>: A pure virtual
              member function declared by
              <classname>gadget::Input</classname></para>
            </listitem>

            <listitem>
              <para><methodname>sample()</methodname>: A pure virtual member
              function declared by <classname>gadget::Input</classname></para>
            </listitem>

            <listitem>
              <para><methodname>updateData()</methodname>: A pure virtual
              member function declared by
              <classname>gadget::Input</classname></para>
            </listitem>

            <listitem>
              <para><methodname>getElementType()</methodname>: A static member
              function</para>
            </listitem>

            <listitem>
              <para><methodname>config()</methodname>: A virtual member
              function declared by <classname>gadget::Input</classname>,
              <classname>gadget::Analog</classname>,
              <classname>gadget::Digital</classname>, etc., that must be
              overridden</para>
            </listitem>
          </orderedlist>

          <para>In this section, we will examine the first four of these. The
          remaining two will be addressed in <xref
          linkend="section.driver.config.methods" />.</para>

          <section>
            <title><methodname>startSampling()</methodname></title>

            <highlights>
              <itemizedlist>
                <listitem>
                  <para>Method synopsis: <methodsynopsis>
                      <modifier>virtual</modifier>

                      <type>bool</type>

                      <methodname>startSampling</methodname>

                      <void />
                    </methodsynopsis></para>
                </listitem>

                <listitem>
                  <para>Overrides the pure virtual function
                  <methodname>gadget::Input::startSampling()</methodname>
                  declared in <filename>gadget/Type/Input.h</filename></para>
                </listitem>
              </itemizedlist>
            </highlights>

            <para>Within this function, a new thread is started. This thread
            is used to sample the data from the device. There are two ways to
            create threads using <classname>vpr::Thread</classname><indexterm>
                <primary>classes</primary>

                <secondary>vpr::Thread</secondary>
              </indexterm>. The first uses a non-member function or a static
            member function. The second uses a non-static member function. To
            spawn a thread that executes a non-member function or a static
            member function, the code would be similar to that shown in <xref
            linkend="example.thread.nonmember.func" /> and <xref
            linkend="example.thread.static.member.func" /> respectively. To
            spawn a thread that executes a member function, the code would be
            similar to that shown in <xref
            linkend="example.thread.member.func" />. The thread can be tested
            for validity using the method
            <methodname>vpr::Thread::valid()</methodname>. For a complete
            description of how to use the cross-platform multi-threading
            capabilities of the VR Juggler Portable Runtime, refer to the
            <ulink url="http://www.vrjuggler.org/vapor/docs.php">VPR
            <emphasis>Programmer's Guide</emphasis></ulink>.</para>

            <example id="example.thread.nonmember.func">
              <title>Spawning a Non-Member Function Thread</title>

              <programlisting>namespace
{

void nonMemberSampleFunction(void* arg)
{
   ButtonDevice* dev_ptr = static_cast&lt;ButtonDevice*&gt;(arg);

   // Keep working until mRunning becomes false.
   while ( dev_ptr-&gt;isRunning() )
   {
      dev_ptr-&gt;sample();
   }
}

}

bool ButtonDevice::startSampling()
{
   mRunning = true;
   mThread = new vpr::Thread(nonMemberSampleFunction, (void*) this);
   return true;
}</programlisting>
            </example>

            <example id="example.thread.static.member.func">
              <title>Spawning a Static Member Function Thread</title>

              <programlisting>class ButtonDevice : public ...
{
public:
   ...
   bool startSampling();
   bool sample();

private:
   static void staticMemberSampleFunction(void* arg);
   ...
};

bool ButtonDevice::startSampling()
{
   mRunning = true;
   mThread = new vpr::Thread(staticMemberSampleFunction, (void*) this);
   return true;
}

void ButtonDevice::staticMemberSampleFunction(void* arg)
{
   ButtonDevice* dev_ptr = static_cast&lt;ButtonDevice*&gt;(arg);

   // Keep working until mRunning becomes false.
   while ( dev_ptr-&gt;mRunning )
   {
      dev_ptr-&gt;sample();
   }
}</programlisting>
            </example>

            <example id="example.thread.member.func">
              <title>Spawning a Member Function Thread</title>

              <programlisting>bool ButtonDevice::startSampling()
{
   mRunning = true;
   vpr::ThreadMemberFunctor&lt;ButtonDevice&gt;* functor =
      new vpr::ThreadMemberFunctor&lt;ButtonDevice&gt;(
         this, &amp;ButtonDevice::membersampleFunction, NULL
      );
   mThread = new vpr::Thread(functor);
   return true;
}

void ButtonDevice::memberSampleFunction(void* arg)
{
   // Keep working until mRunning becomes false.
   while ( mRunning )
   {
      this-&gt;sample();
   }
}</programlisting>
            </example>

            <tip>
              <para>Using a thread for the sample loop is not always necessary
              or appropriate. It is most useful for the case of a device
              protocol implementation that relies on blocking I/O. Such a
              device could cause the Input Manager to block when querying the
              latest sample, and this would impact the application frame rate.
              For drivers that can read data at any time without blocking,
              simply taking a sample in the implementation of
              <methodname>updateData()</methodname> is sufficient. The
              decision to use a thread or not depends very much on the
              specific hardware communication protocol, and driver authors
              must take this into consideration on a per-driver basis.</para>
            </tip>

            <caution>
              <para>In certain cases, it is highly desirable to avoid using a
              thread. For example, devices that return sample data immediately
              would collect many, many samples that would have to be shared
              among cluster nodes every frame. The burden on the network could
              have a negative impact on the performance of the cluster. The
              driver we are examining in this section is a good example of a
              driver that should <emphasis>not</emphasis> use a thread because
              it does not block while waiting for hardware to return a sample.
              Nevertheless, we illustrate the use of a thread so that readers
              can see how it works.</para>
            </caution>
          </section>

          <section>
            <title><methodname>stopSampling()</methodname></title>

            <highlights>
              <itemizedlist>
                <listitem>
                  <para>Method synopsis: <methodsynopsis>
                      <modifier>virtual</modifier>

                      <type>bool</type>

                      <methodname>stopSampling</methodname>

                      <void />
                    </methodsynopsis></para>
                </listitem>

                <listitem>
                  <para>Overrides the pure virtual function
                  <methodname>gadget::Input::stopSampling()</methodname>
                  declared in <filename>gadget/Type/Input.h</filename></para>
                </listitem>
              </itemizedlist>
            </highlights>

            <para>The job of this function is to kill the thread created in
            <methodname>startSampling()</methodname> and release resources
            such as open file handles. If no thread was created, then this
            method only needs to release any open resources. Remember that
            <methodname>startSampling()</methodname> could be called again
            later, so drivers must be written to handle the case where they
            are shut down and restarted.</para>
          </section>

          <section>
            <title><methodname>sample()</methodname></title>

            <highlights>
              <itemizedlist>
                <listitem>
                  <para>Method synopsis: <methodsynopsis>
                      <modifier>virtual</modifier>

                      <type>bool</type>

                      <methodname>sample</methodname>

                      <void />
                    </methodsynopsis></para>
                </listitem>

                <listitem>
                  <para>Overrides the pure virtual function
                  <methodname>gadget::Input::sample()</methodname> declared in
                  <filename>gadget/Type/Input.h</filename></para>
                </listitem>
              </itemizedlist>
            </highlights>

            <para>This method reads data from the device and stores it for
            later use by
            <methodname>gadget::Digital::getDigitalData()</methodname>. Note
            that <methodname>ButtonDevice::sampleFunction()</methodname>,
            defined above, invokes this method. It is the responsibility of
            the driver itself to call <methodname>sample()</methodname>, and
            therefore, its implementation may be empty depending on how the
            driver is designed.</para>

            <para>Gadgeteer devices typically use triple-buffered data
            management. This is done to ensure that data is not being written
            into a buffer when the Input Manager is trying to read the most
            recent value. The various base classes for device types provide
            helper methods for handling triple-buffered data. This is a big
            help over VR Juggler 1.0 and early versions of VR Juggler 1.1
            where the triple-buffering had to be managed manually in every
            driver.</para>

            <para>We are not actually implementing a hardware protocol, so we
            simply use dummy values as the sample buffers. For this, we use
            the protected base class method
            <methodname>gadget::Digital::addDigitalSample()</methodname>. Note
            that this method expects a
            <classname>std::vector&lt;T&gt;</classname> containing sample
            buffers as its parameter. In our case, we will have one sample
            buffer in the vector, as shown below:</para>

            <example>
              <title>Implementation of <methodname>sample()</methodname>
              Member Function</title>

              <programlisting>bool ButtonDevice::sample()
{
   bool status(false);

   if ( mRunning )
   {
      // Here you would add your code to sample the hardware for a
      // button press:
      std::vector&lt;gadget::DigitalData&gt; digital_samples(1);
      digital_samples[0] = 1;
      addDigitalSample(digital_samples);

      // Successful sample.
      status = true;
   }

   return status;
}</programlisting>
            </example>

            <para>For a device driver that supports multiple data types, there
            are additional inherited helper methods such as
            <methodname>gadget::Position::addPositionSample()</methodname>,
            <methodname>gadget::Analog::addAnalogSample()</methodname>, etc.
            Refer to the Gadgeteer Programmer Reference for complete details
            about the class declarations.</para>
          </section>

          <section>
            <title><methodname>updateData()</methodname></title>

            <highlights>
              <itemizedlist>
                <listitem>
                  <para>Method synopsis: <methodsynopsis>
                      <modifier>virtual</modifier>

                      <void />

                      <methodname>updateData</methodname>

                      <void />
                    </methodsynopsis></para>
                </listitem>

                <listitem>
                  <para>Overrides the pure virtual function
                  <methodname>gadget::Input::updateData()</methodname>
                  declared in <filename>gadget/Type/Input.h</filename></para>
                </listitem>
              </itemizedlist>
            </highlights>

            <para>This method is invoked by the Input Manager once per frame
            for each active device to prepare the latest input data for use by
            higher level code such as a VR Juggler application object. Again,
            we can use a helper function inherited from
            <classname>gadget::Digital</classname><indexterm>
                <primary>classes</primary>

                <secondary>gadget::Digital</secondary>
              </indexterm> to perform this operation. As usual, there are
            similar helper functions that would be inherited from the other
            device types if our driver supported multiple types of input
            data.</para>

            <example>
              <title>Implementation of <methodname>updateData()</methodname>
              Member Function</title>

              <programlisting>void ButtonDevice::updateData()
{
   if ( mRunning )
   {
      swapDigitalBuffers();
   }
}</programlisting>
            </example>

            <note>
              <para>As mentioned above, some drivers may perform their entire
              sample operation in their override of
              <methodname>gadget::Input::updateData()</methodname>. This
              driver would be a good candidate for that use of the
              <methodname>updateData()</methodname> method. Instead of
              building up a large number of sample buffers in a separate
              thread, our sample could be taken here. This would be
              accomplished by combining the implementations of
              <methodname>ButtonDevice::sample()</methodname> and
              <methodname>ButtonDevice::updateData()</methodname> into this
              method, thereby leaving
              <methodname>ButtonDevice::sample()</methodname> empty.</para>
            </note>
          </section>
        </section>

        <section>
          <title>Driver Plug-in Entry Points</title>

          <para>All the device drivers that can be loaded at run time by the
          Input Manager have what are known as <firstterm>entry point
          functions</firstterm>. These are free functions with C-style
          signatures that may be looked up at run time using operating system
          features. In Gadgeteer 1.0, every driver plug-in must include two
          exported functions: <function>getGadgeteerVersion()</function> and
          <function>initDevice()</function>. The first is used for simple
          version checking, and the second registers the driver with the Input
          Manager.</para>

          <sidebar>
            <para>For Windows programmers, these are the only two symbols that
            must be exported from the driver DLL. The device driver class or
            classes do not have to exported from the DLL.</para>
          </sidebar>

          <section>
            <title>Driver Version Checking</title>

            <para>As of the release of Gadgeteer 1.0 Beta 1, all driver
            plug-ins must have an entry point function that allows the Input
            Manager to perform version checking. This is done to ensure that
            the driver is compatible with the Input Manager. The
            implementation of this function will be the same for all drivers,
            and it is shown in <xref linkend="example.getGadgeteerVersion" />.
            Because we are dealing with C++ code, we must indicate to the
            compiler that this is a C-style function, so no name mangling
            should occur when its symbol table entry is created. We do this by
            wrapping the function body in an <literal>extern "C"</literal>
            block. For cross-platform plug-in capabilities, we use the
            <symbol>GADGET_DRIVER_EXPORT()</symbol> macro. On Win32 systems,
            this will add the appropriate type modifiers to declare
            <function>initDevice()</function> as a function exported by the
            DLL that will be compiled. For other platforms, the macro simply
            evaluates to the <type>void</type> type. (These details are
            handled within the
            <filename>gadget/Devices/DriverConfig.h</filename> header.)</para>

            <example id="example.getGadgeteerVersion">
              <title>Implementation of
              <function>getGadgeteerVersion()</function> Entry Point
              Function</title>

              <programlisting>#include &lt;gadget/Devices/DriverConfig.h&gt;
#include &lt;vpr/vpr.h&gt;
#include &lt;gadget/gadgetParam.h&gt;

extern "C"
{

GADGET_DRIVER_EXPORT(vpr::Uint32) getGadgeteerVersion()
{
   return __GADGET_version;
}

}</programlisting>
            </example>

            <para>The result of this implementation is that the Gadgeteer
            version number is compiled into the driver plug-in. At run time,
            the Input Manager compares this value with the version of the
            Gadgeteer library. If the two match exactly, the driver loading
            process continues. If not, the driver plug-in is ignored.</para>

            <sidebar>
              <para>This form of version compatibility testing is rudimentary,
              but because the Juggler libraries do not guarantee binary
              compatibility between releases, it is necessary. In the future,
              a more sophisticated version comparison system may be devised
              for driver plug-ins. Presently, it is already possible to get
              the individual version numbers of the Gadgeteer library (major,
              minor, and patch), and these could be used as the foundation for
              a more advanced compatibility management system.</para>
            </sidebar>
          </section>

          <section>
            <title>Register the Driver with the Input Manager</title>

            <indexterm>
              <primary>device drivers</primary>

              <secondary>registering</secondary>
            </indexterm>

            <para>Device driver registration is done through a template type
            called
            <classname>gadget::DeviceConstructor&lt;T&gt;</classname><indexterm>
                <primary>classes</primary>

                <secondary>gadget::DeviceConstructor&lt;T&gt;</secondary>
              </indexterm>. When this type is used with a special
            <quote>factory function</quote> called
            <function>initDevice()</function>, the driver can be used as a
            plug-in to the Input Manager. While there are some drivers that
            cannot currently be loaded dynamically, those that can include an
            entry point function named
            <function>initDevice()</function>.</para>

            <para>With all of that, we can now write the body for
            <function>initDevice()</function>. No declaration in a header file
            is needed because this function will be looked up dynamically at
            run time. The implementation of <function>initDevice()</function>
            will appear in <filename>ButtonDevice.cpp</filename> as
            follows:</para>

            <example>
              <title>Implementation of <function>initDevice()</function> Entry
              Point Function</title>

              <programlisting>#include &lt;gadget/Devices/DriverConfig.h&gt;
#include &lt;gadget/Type/DeviceConstructor.h&gt;
#include "ButtonDevice.h"

extern "C"
{

GADGET_DRIVER_EXPORT(void) initDevice(gadget::InputManager* inputMgr)
{
   new gadget::DeviceConstructor&lt;ButtonDevice&gt;(inputMgr);
}

}</programlisting>
            </example>
          </section>
        </section>
      </section>
    </chapter>

    <chapter>
      <title>Compiling the Driver Plug-in</title>

      <para>At this point, our device driver is not yet complete because it
      cannot be configured. Nevertheless, there will be nothing for the Input
      Manager to load—and hence no driver to configure—until we are able to
      compile the driver plug-in. In this chapter, we explain how to compile
      the driver as a dynamically loadable component. We present this from the
      perspective of a driver that exists outside the Gadgeteer driver source
      tree. For drivers that are integrated into the Gadgeteer driver source
      tree, refer to <xref linkend="makefile.templates.section" />.</para>

      <para>The device driver must be compiled into a standalone dynamically
      loadable component. The usual file extension names for plug-ins
      are<filename>.so</filename>, <filename>.dll</filename>, or
      <filename>.dylib</filename> depending on the host operating system. This
      component will act as the Input Manager plug-in. In this way, there is
      no need to modify the Gadgeteer source code to add a new driver. Thus,
      the driver code is collected into a cohesive unit that can be
      distributed as a plug-in for Gadgeteer.</para>

      <para>Compiling device driver plug-ins for use with Gadgeteer is a
      relatively simple process that can use either GNU Make or a Visual C++
      project file. To compile a driver plug-in on Windows, a Visual C++
      project file must be used; using GNU Make on Windows is not supported by
      Gadgeteer 1.0.</para>

      <para>In either case, the name of the compiled driver plug-in must
      follow certain conventions. A debug version of the driver must be named
      as <filename>&lt;device&gt;_drv_d.&lt;ext&gt;</filename>. Here,
      <filename>&lt;device&gt;</filename> provides a meaningful, unique name
      for the driver plug-in, and <filename>&lt;ext&gt;</filename> is the
      platform-specific file extension for plug-ins. The
      <filename>_d</filename> part indicates that the driver is debug-enabled
      and on Windows that it is linked against the Visual C++ debug runtime.
      Examples are <filename>IS900_drv_d.so</filename> and
      <filename>MotionStar_drv_d.dll</filename>. On Mac OS X, the extension
      <filename>.dylib</filename> is used rather than
      <filename>.bundle</filename>. An optimized (<quote>release</quote> in
      Visual C++ terminology) version of the driver uses the same convention
      but drops the <filename>_d</filename> part.</para>

      <para>When using GNU Make, a very short makefile is all that is
      required. An example for our button driver is shown in <xref
      linkend="example.driver.makefile" />. The makefile allows either a debug
      or an optimized version of the driver to be compiled depending on the
      value assigned to the <varname>$(BUILD_TYPE)</varname> variable. The
      <varname>$(SRCS)</varname> variable must contain the complete list of
      source files for the driver plug-in. The file extensions
      <filename>.c</filename>, <filename>.C</filename>,
      <filename>.CC</filename>, <filename>.cc</filename>,
      <filename>.cxx</filename>, <filename>.cpp</filename>, and
      <filename>.c++</filename> are recognized. The environment variable
      <envar>GADGET_BASE_DIR</envar> must be set for use by this makefile. It
      would usually be set to the same value as
      <envar>VJ_BASE_DIR</envar>.</para>

      <example id="example.driver.makefile">
        <title>Example Makefile for Device Driver Plug-in</title>

        <programlisting>srcdir=         .
BUILD_TYPE=     dbg
#BUILD_TYPE=    opt

DRIVER_NAME=    button
SRCS=           buttondevice.cpp

include $(GADGET_BASE_DIR)/share/gadgeteer/gadget.driver.mk</programlisting>
      </example>

      <para>To use a Visual C++ project file, the example provided in
      <filename>$GADGET_BASE_DIR/share/gadgeteer/samples/tutorials/device.driver</filename>
      can be used as a starting point. It sets all the compiler and linker
      options. Users must change the list of source and header files and the
      names of the output files. It is also recommended that users edit the
      <filename>.vcproj</filename> file with a text editor to remove the
      <literal>ProjectGUID</literal> setting on line 6 before loading the
      project file into Visual Studio. This will ensure that the new Visual
      C++ project file has a unique identifier.</para>
    </chapter>

    <chapter>
      <title>Driver Configuration</title>

      <indexterm>
        <primary>device drivers</primary>

        <secondary>configuring</secondary>
      </indexterm>

      <para>In Gadgeteer, device drivers should be parameterized. This means
      that aspects of the driver that can vary should be configurable rather
      than hard-coded values. This is in line with the general Juggler
      philosophy of making software components flexible to provide a high
      degree of adaptability. In this chapter, we explain how to configure the
      Input Manager to load a device driver plug-in and how to make a device
      driver configurable. For a more detailed explanation of the Juggler
      configuration system, refer to the VR Juggler <emphasis>Configuration
      Guide</emphasis>.</para>

      <section>
        <title>Configuring the Input Manager</title>

        <para>Run-time driver registration depends on the Input Manager
        configuration. For our button device driver, the Input Manager would
        be configured to load our driver plug-in using the configuration file
        shown in <xref linkend="example.input.mgr.config" />. Here, the driver
        plug-in is named <filename>button_drv.so</filename> (or some other
        platform-specific name), and it is found in the user's home directory.
        Never include the <filename>_d</filename> part of the driver plug-in
        name or the platform-specific file extension. The Input Manager
        determines these details automatically, thus making the configuration
        files highly portable across different operating systems. For more
        details about how to configure the Input Manager, refer to the VR
        Juggler <emphasis>Configuration Guide</emphasis>.</para>

        <example id="example.input.mgr.config">
          <title>Example Input Manager Configuration</title>

          <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?org-vrjuggler-jccl-settings configuration.version="3.0"?&gt;
&lt;configuration
  xmlns="http://www.vrjuggler.org/jccl/xsd/3.0/configuration"
  name="Configuration"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.vrjuggler.org/jccl/xsd/3.0/configuration http://www.vrjuggler.org/jccl/xsd/3.0/configuration.xsd"&gt;
   &lt;elements&gt;
      &lt;input_manager name="Button Device Input Manager" version="2"&gt;
         &lt;driver_path&gt;${HOME}&lt;/driver_path&gt;
         &lt;driver&gt;button_drv&lt;/driver&gt;
      &lt;/input_manager&gt;
   &lt;/elements&gt;
&lt;/configuration&gt;</programlisting>
        </example>
      </section>

      <section condition="" id="section.driver.config.def">
        <title>Driver Configuration Definition File</title>

        <para>Every Gadgeteer device needs a unique <firstterm>element
        type</firstterm> associated with it. An element type is similar to a
        struct in C or C++. The data structure is defined in an configuration
        definition file (which usually has the extension
        <filename>.jdef</filename>). Once defined, the type for a new driver
        can be used in JCCL configuration files.</para>

        <para>Therefore, a new driver-specific configuration definition must
        be created before a driver can be configured. We recommend that this
        be done using the <application>VRJConfig</application> Config
        Definition Editor. For the button device, the definition file is shown
        in <xref linkend="example.buttondevice.jdef" />.</para>

        <example id="example.buttondevice.jdef">
          <title><filename>button_device.jdef</filename>: Configuration
          Definition File for Simple Button Device</title>

          <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?org-vrjuggler-jccl-settings definition.version="3.1"?&gt;
&lt;definition xmlns="http://www.vrjuggler.org/jccl/xsd/3.1/definition"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.vrjuggler.org/jccl/xsd/3.1/definition http://www.vrjuggler.org/jccl/xsd/3.1/definition.xsd"
            name="button_device"&gt;                               <co
              id="buttondevice.jdef.token.decl"
              linkends="buttondevice.jdef.token.decl.co" />
   &lt;definition_version version="1" label="My Button Device"&gt;
      &lt;help&gt;Configuration for simple one-button device.&lt;/help&gt;
      &lt;parent&gt;digital_device&lt;/parent&gt;                           <co
              id="buttondevice.jdef.parent.decl"
              linkends="buttondevice.jdef.parent.decl.co" />
      &lt;category&gt;/Devices/Digital&lt;/category&gt;
      &lt;property valuetype="string" variable="false"
                name="port"&gt;                                    <co
              id="buttondevice.jdef.port.decl"
              linkends="buttondevice.jdef.port.decl.co" />
         &lt;help&gt;Serial port the device is connected to.&lt;/help&gt;
         &lt;value label="Port" defaultvalue="/dev/ttyd1"/&gt;
      &lt;/property&gt;
      &lt;property valuetype="integer" variable="false"
                name="baud"&gt;                                    <co
              id="buttondevice.jdef.baud.decl"
              linkends="buttondevice.jdef.baud.decl.co" />
         &lt;help&gt;Serial port speed.&lt;/help&gt;
         &lt;value label="Baud" defaultvalue="38400"/&gt;
      &lt;/property&gt;
      &lt;upgrade_transform/&gt;
   &lt;/definition_version&gt;
&lt;/definition&gt;</programlisting>

          <calloutlist>
            <callout arearefs="buttondevice.jdef.token.decl"
                     id="buttondevice.jdef.token.decl.co">
              <para>This begins the definition for our device type. The
              <literal>name</literal> attribute must be named as a valid XML
              tag (a CNAME in XML terminology) because it will be used as such
              in a configuration file. A free-form, human-friendly string may
              be specified in the <literal>label</literal> attribute of the
              <sgmltag>definition_version</sgmltag> element. This string will
              be presented to the user of
              <application>VRJConfig</application>, and as such, it should be
              a meaningful identifier.</para>
            </callout>

            <callout arearefs="buttondevice.jdef.parent.decl"
                     id="buttondevice.jdef.parent.decl.co">
              <para>The parent (or base type) for this config definition. Zero
              or more of these are allowed. In this case, we must indicate
              that <literal>digital_device</literal> is a parent type so that
              <application>VRJConfig</application> will know that digital
              proxies can be pointed at config elements for our driver. We
              also inherit property definitions from
              <literal>digital_device</literal> including
              <quote>device_host</quote>, which is needed for cluster
              configurations.</para>
            </callout>

            <callout arearefs="buttondevice.jdef.port.decl"
                     id="buttondevice.jdef.port.decl.co">
              <para>This declares the <quote>port</quote> property that will
              provide the name of the serial port to which the hardware is
              connected. The serial port name will be interpreted as a string,
              and it has the default value of <quote>/dev/ttyd1</quote>. In
              the case of our simple button driver, there is no serial port,
              but we include this property definition to demonstrate how the
              whole configuration definition works.</para>
            </callout>

            <callout arearefs="buttondevice.jdef.baud.decl"
                     id="buttondevice.jdef.baud.decl.co">
              <para>This declares the <quote>baud</quote> property that will
              provide the baud setting for the serial port to which the
              hardware is connected. The baud value will be interpreted as an
              integer, and it has the default value of 38400 (kilobits per
              second). In the case of our simple button driver, there is no
              serial port, but we include this property definition to
              demonstrate how the whole configuration definition works.</para>
            </callout>
          </calloutlist>
        </example>

        <note>
          <para>In the above configuration definition, we do not declare a
          <quote>device_host</quote> property, which is used in conjunction
          with the Remote Input Manager. This is not necessary because we have
          declared our parent type to be <quote>digital_device</quote>, and we
          inherit its property definitions. All drivers that may be used with
          the Remote Input Manager must have the <quote>device_host</quote>
          property, and configuration definition inheritance ensures that this
          will be the case. Refer to the VR Juggler <emphasis>Configuration
          Guide</emphasis> for more information about this property.</para>
        </note>

        <para>For a more complex device, a more complex configuration
        definition may be needed. Again, the
        <application>VRJConfig</application> Configuration Definition Editor
        simplifies the creation of this definition.</para>
      </section>

      <section id="section.driver.config.file">
        <title>Driver Configuration File</title>

        <para>Once the configuration definition is in place, a new
        configuration element can be created. Once again,
        <application>VRJConfig</application> makes the step easier. In <xref
        linkend="example.buttondevice.jconf" />, we see a configuration file
        that configures the one-button device we have been using thus
        far.</para>

        <important>
          <para>In order for <application>VRJConfig</application> and the JCCL
          Configuration Manager to find the driver-specific
          <filename>.jdef</filename> file at run time, it may be necessary to
          extend the <filename>.jdef</filename> search path using the
          environment variable <envar>JCCL_DEFINITION_PATH</envar>. This
          environment variable is set in the same manner as the
          <envar>PATH</envar> environment variable, meaning that it uses
          platform-specific conventions. On UNIX-based platforms, the
          directories to search are separated with the colon (:) character; on
          Windows, the path separator character is the semi-colon (;). If the
          .jdef file is installed in the default search path
          (<filename>$VJ_BASE_DIR/share/vrjuggler/data/definitions</filename>),
          there is no need to set <envar>JCCL_DEFINITION_PATH</envar>.</para>
        </important>

        <example id="example.buttondevice.jconf">
          <title><filename>button_device.jconf</filename>: Configuration File
          for Simple Button Device</title>

          <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?org-vrjuggler-jccl-settings configuration.version="3.0"?&gt;
&lt;configuration xmlns="http://www.vrjuggler.org/jccl/xsd/3.0/configuration"
               name="Configuration"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xsi:schemaLocation="http://www.vrjuggler.org/jccl/xsd/3.0/configuration http://www.vrjuggler.org/jccl/xsd/3.0/configuration.xsd"&gt;
   &lt;elements&gt;
      &lt;input_manager name="Button Device Input Manager"
                     version="2"&gt;                             <co
              id="buttondevice.jconf.InputManager"
              linkends="buttondevice.jconf.driver.co" />
         &lt;driver_path&gt;${HOME}&lt;/driver_path&gt;
         &lt;driver&gt;button_drv&lt;/driver&gt;
      &lt;/input_manager&gt;
      &lt;button_device name="Button Device" version="1"&gt;        <co
              id="buttondevice.jconf.ButtonDevice"
              linkends="buttondevice.jconf.ButtonDevice.co" />
         &lt;port&gt;/dev/ttyd4&lt;/port&gt;                              <co
              id="buttondevice.jconf.port.value"
              linkends="buttondevice.jconf.port.value.co" />
         &lt;baud&gt;9600&lt;/baud&gt;                                    <co
              id="buttondevice.jconf.baud.value"
              linkends="buttondevice.jconf.baud.value.co" />
         &lt;device_host /&gt;                                      <co
              id="buttondevice.jconf.hostelement.value"
              linkends="buttondevice.jconf.hostelement.value.co" />
      &lt;/button_device&gt;
      &lt;digital_proxy name="Button Proxy 0" version="1"&gt;       <co
              id="buttondevice.jconf.proxy"
              linkends="buttondevice.jconf.proxy.co" />
         &lt;device&gt;Button Device&lt;/device&gt;
         &lt;unit&gt;0&lt;/unit&gt;
      &lt;/digital_proxy&gt;
      &lt;alias name="VJButton0" version="1"&gt;
         &lt;proxy&gt;Button Proxy 0&lt;/proxy&gt;
      &lt;/alias&gt;
   &lt;/elements&gt;
&lt;/configuration&gt;</programlisting>
        </example>

        <calloutlist>
          <callout arearefs="buttondevice.jconf.InputManager"
                   id="buttondevice.jconf.driver.co">
            <para>The <sgmltag>input_manager</sgmltag> element configures the
            Gadgeteer Input Manager. In this case, we are telling the Input
            Manager about a driver plug-in, found at
            <filename>${HOME}/button_drv.so</filename>, that should be loaded
            at run time.</para>

            <tip>
              <para>Earlier, we introduced the Input Manager configuration in
              a separate configuration file. In general, we recommend
              configuring a given device entirely within one
              <filename>.jconf</filename> file—including the
              <literal>input_manager</literal> config element that loads the
              driver plug-in. That is precisely what we are showing in this
              example.</para>
            </tip>
          </callout>

          <callout arearefs="buttondevice.jconf.ButtonDevice"
                   id="buttondevice.jconf.ButtonDevice.co">
            <para>Next, we have an instance of the configuration definition
            shown in <xref linkend="example.buttondevice.jdef" />. As
            described above, <sgmltag>&lt;button_device&gt;</sgmltag> is named
            based on the <literal>name</literal> attribute of the
            <sgmltag>definition</sgmltag> element in our configuration
            definition file. The <literal>name</literal> attribute here gives
            this <emphasis>instance</emphasis> a unique identifier.</para>
          </callout>

          <callout arearefs="buttondevice.jconf.port.value"
                   id="buttondevice.jconf.port.value.co">
            <para>Now, we set the value for the serial port name. As noted
            above, our simple button device does not actually use the serial
            port, but this demonstrates how the property value is used in a
            configuration file. If no value were given here, the default value
            set in b<filename>utton_device.jdef</filename> would be
            used.</para>
          </callout>

          <callout arearefs="buttondevice.jconf.baud.value"
                   id="buttondevice.jconf.baud.value.co">
            <para>This provides a value for the serial port baud setting.
            Again, this will not actually be used by our simple device, but we
            show it here to give a complete example.</para>
          </callout>

          <callout arearefs="buttondevice.jconf.hostelement.value"
                   id="buttondevice.jconf.hostelement.value.co">
            <para>For our example, we will not fill in a value for
            <literal>device_host</literal> because we are not dealing with the
            Remote Input Manager. Refer to the VR Juggler
            <emphasis>Configuration Guide</emphasis> for more information
            about this.</para>
          </callout>

          <callout arearefs="buttondevice.jconf.proxy"
                   id="buttondevice.jconf.proxy.co">
            <para>Finally, we point a digital proxy at our device. Since the
            device has only one input source, we have to use 0 for the unit
            value.</para>
          </callout>
        </calloutlist>
      </section>

      <section id="section.driver.config.methods">
        <title>Writing Code that Accepts the Configuration</title>

        <para>In the driver, recall that there are two methods that must be
        implemented in order to handle config elements:</para>

        <orderedlist>
          <listitem>
            <para><methodname>getElementType()</methodname></para>
          </listitem>

          <listitem>
            <para><methodname>config()</methodname></para>
          </listitem>
        </orderedlist>

        <para>We now present these two methods, thereby completing the
        interface of the driver as far as the Input Manager is
        concerned.</para>

        <section>
          <title><methodname>getElementType()</methodname></title>

          <highlights>
            <itemizedlist>
              <listitem>
                <para>Method synopsis: <methodsynopsis>
                    <modifier>static</modifier>

                    <type>std::string</type>

                    <methodname>getElementType</methodname>

                    <void />
                  </methodsynopsis></para>
              </listitem>

              <listitem>
                <para>Overrides the pure virtual function
                <methodname>gadget::Input::updateData()</methodname> declared
                in <filename>gadget/Type/Input.h</filename></para>
              </listitem>
            </itemizedlist>
          </highlights>

          <para>When the configuration changes, the JCCL Configuration Manager
          asks every registered configuration handler for their respective
          configuration element types. If the type matches the type of the
          newly received configuration element, then the handler's
          <methodname>config()</methodname> method is invoked. All device
          drivers are configuration handlers and thus need to indicate the
          configuration element type they accept<footnote>
              <para>A comprehensive explanation of the full functionality of
              the Juggler run-time (re-)configuration system is beyond the
              scope of this document. Here, we present only the basic
              information about config definitions and config elements that is
              needed for writing a complete device driver. For more details,
              see the VR Juggler <emphasis>Configuration
              Guide</emphasis>.</para>
            </footnote>. The type value is returned by the member function
          <methodname>getElementType()</methodname>.</para>

          <para>In this function, the element type of the device must be
          returned. The string returned by
          <methodname>getElementType()</methodname> must be
          <emphasis>exactly</emphasis> the same as the <literal>name</literal>
          attribute for the driver configuration definition that we saw above
          in <xref linkend="section.driver.config.def" />. For example, the
          implementation for the simple button driver would appear as shown in
          <xref linkend="example.getElementType.impl" />.</para>

          <example id="example.getElementType.impl">
            <title>Implementation of <function>getElementType()</function>
            Member Function</title>

            <programlisting>std::string ButtonDevice::getElementType()
{
   return std:string("button_device");
}</programlisting>
          </example>

          <important>
            <para>Returning the correct string from
            <methodname>getElementType()</methodname> is very important.
            Failing to do so will result in the config element for the device
            driver ending up in the JCCL Configuration Manager's pending list
            at run time. For device driver authors, this can be a serious
            point of confusion. The driver plug-in will load correctly, but if
            the string returned by <methodname>getElementType()</methodname>
            is incorrect, the driver will never be configured or
            started.</para>
          </important>
        </section>

        <section>
          <title><methodname>config()</methodname></title>

          <highlights>
            <itemizedlist>
              <listitem>
                <para>Method synopsis: <methodsynopsis>
                    <modifier>virtual</modifier>

                    <type>bool</type>

                    <methodname>updateData</methodname>

                    <methodparam>
                      <type>jccl::ConfigElementPtr</type>

                      <parameter>element</parameter>
                    </methodparam>
                  </methodsynopsis></para>
              </listitem>

              <listitem>
                <para>Overrides the virtual function
                <methodname>gadget::Input::config()</methodname> declared in
                <filename>gadget/Type/Input.h</filename> as well as the
                virtual functions
                <methodname>gadget::Analog::config()</methodname>,
                <methodname>gadget::Position::config()</methodname>, etc.,
                depending on the type parameters used in the base class
                declaration</para>
              </listitem>
            </itemizedlist>
          </highlights>

          <para>When the Configuration Manager detects a configuration change
          for a given driver, it will pass the new
          <classname>jccl::ConfigElementPtr</classname> object as the
          parameter to this method. This is when the driver must handle its
          configuration and store the information for use when the Input
          Manager tells the device to start up. For more information about how
          to use instances of <classname>jccl::ConfigElementPtr</classname>,
          refer to the <emphasis>JCCL C++ Programmer's Reference</emphasis>.
          The implementation of <methodname>config()</methodname> for our
          simple button device driver is shown in <xref
          linkend="example.config.impl" />.</para>

          <important>
            <para>The override of
            <methodname>gadget::Input::config()</methodname> must invoke the
            implementations of <methodname>config()</methodname> that it
            overrides from its base classes. All the base classes defined by
            Gadgeteer for different input device types have a
            <methodname>config()</methodname> method, though some of them have
            an empty method body. Nevertheless, <emphasis>all</emphasis>
            inherited <methodname>config()</methodname> methods must be
            invoked by the driver in order to ensure that the driver is fully
            configured. In general, this should be done first before reading
            any of the device-specific properties from the config element.
            This is demonstrated in the example below.</para>
          </important>

          <example id="example.config.impl">
            <title>Implementation of <methodname>config()</methodname> Member
            Function</title>

            <programlisting>bool ButtonDevice::config(jccl::ConfigElementPtr e)
{
   // Configure all our base classes first.  If any of those fail,
   // we cannot finish configuring ourself.
   if ( ! gadget::Input::config(e) &amp;&amp; ! gadget::Digital::config(e) )
   {
      return false;
   }

   mPortName = e-&gt;getProperty&lt;std::string&gt;("port");
   mBaudRate = e-&gt;getProperty&lt;int&gt;("baud");

   return true;
}</programlisting>
          </example>
        </section>
      </section>
    </chapter>
  </part>

  <part>
    <title>Appendices</title>

    <appendix id="driver.code.appendix">
      <title>Complete Device Driver Code</title>

      <para></para>

      <section id="standalone.driver.section">
        <title>Standalone Driver</title>

        <para></para>
      </section>

      <section id="gadgeteer.wrapper.section">
        <title>Gadgeteer Wrapper</title>

        <indexterm>
          <primary>device drivers</primary>

          <secondary>example</secondary>
        </indexterm>

        <para>Now that we have explained the concepts involved in adding a
        device driver to Gadgeteer, we can show some code. The following
        example is for a fictitious piece of hardware that has only one
        button.</para>

        <example id="example.ButtonDevice.h">
          <title><filename>ButtonDevice.h</filename></title>

          <programlisting linenumbering="numbered">
#ifndef _EXAMPLE_BUTTON_DEVICE_H_
#define _EXAMPLE_BUTTON_DEVICE_H_

#include &lt;gadget/Devices/DriverConfig.h&gt;

#include &lt;stdlib.h&gt;
#include &lt;string&gt;

#include &lt;vpr/vpr.h&gt;

#include &lt;jccl/Config/ConfigElementPtr.h&gt;
#include &lt;gadget/Type/Input.h&gt;
#include &lt;gadget/Type/Digital.h&gt;
#include &lt;gadget/Type/InputMixer.h&gt;


using namespace gadget;

/** The device driver class. */
class ButtonDevice : public InputMixer&lt;Input, Digital&gt;
{
public:
   ButtonDevice()
      : mSampleThread(NULL)
      , mRunning(false)
   {
      /* Do nothing. */ ;
   }

   virtual ~ButtonDevice()
   {
      if ( mRunning )
      {
         this-&gt;stopSampling();
      }
   }

   /**
    * When the system detects a configuration change for your
    * driver, it will pass the jccl::ConfigElementPtr into
    * this function.  See the documentation on config elements,
    * for information on how to access them.
    */
   virtual bool config(jccl::ConfigElementPtr e);

   /**
    * Spawns the sample thread, which calls ButtonDevice::sample()
    * repeatedly.
    */
   virtual bool startSampling();

   /**
    * Records (or samples) the current data.  This is called
    * repeatedly by the sample thread created by startSampling().
    */
   virtual bool sample();

   /** Kills the sample thread. */
   virtual bool stopSampling();

   virtual void updateData();

   /**
    * Returns a string that matches this device's configuration
    * element type.
    */
   static std::string getElementType();

   /**
    * Invokes the global scope delete operator.  This is required
    * for proper releasing of memory in DLLs on Win32.
    */
   void operator delete(void* p)
   {
      ::operator delete(p);
   }

protected:
   /**
    * Deletes this object.  This is an implementation of the pure
    * virtual gadget::Input::destroy() method.
    */
   virtual void destroy()
   {
      delete this;
   }

private:
   /**
    * Our sampling function that is executed by the spawned
    * sample thread.  This function is declared as a static member
    * of ButtonDevice.  It simply calls ButtonDevice::sample()
    * over and over.
    */
   static void threadedSampleFunction(void* classPointer);

   vpr::Thread*  mSampleThread;
   bool          mRunning;

   // configuration data set by config()
   std::string   mPort;
   int           mBaud;
};

#endif /* _EXAMPLE_BUTTON_DEVICE_H_ */</programlisting>
        </example>

        <example>
          <title><filename>buttondevice.cpp</filename></title>

          <programlisting linenumbering="numbered">#include &lt;gadget/Devices/DriverConfig.h&gt;

#include &lt;vector&gt;

#include &lt;vpr/vpr.h&gt;
#include &lt;vpr/System.h&gt;

#include &lt;jccl/Config/ConfigElement.h&gt;
#include &lt;gadget/gadgetParam.h&gt;
#include &lt;gadget/InputManager.h&gt;
#include &lt;gadget/Type/DeviceConstructor.h&gt;

#include "buttondevice.h"

extern "C"
{

/** Entry point function for the device driver plug-in. */
GADGET_DRIVER_EXPORT(vpr::Uint32) getGadgeteerVersion()
{
   return __GADGET_version;
}

/** Entry point function for the device driver plug-in. */
GADGET_DRIVER_EXPORT(void) initDevice(InputManager* inputMgr)
{
   new DeviceConstructor&lt;ButtonDevice&gt;(inputMgr);
}

}

// Returns a string that matches this device's configuration
// element type.
std::string ButtonDevice::getElementType()
{
   return std::string("button_device");
}

// When the system detects a configuration change for your driver,
// it will pass the jccl::ConfigElementPtr into this function.
// See the documentation on config elements, for information on
// how to access them.
bool ButtonDevice::config(jccl::ConfigElementPtr e)
{
  if ( ! Input::config(e) &amp;&amp; ! Digital::config(e) )
  {
     return false;
  }

  mPort = e-&gt;getProperty&lt;std::string&gt;("port");
  mBaud = e-&gt;getProperty&lt;int&gt;("baud");

  return true;
}

// Spanws the sample thread, which calls ButtonDevice::sample()
// repeatedly.
bool ButtonDevice::startSampling()
{
   mRunning = true;
   mSampleThread = new vpr::Thread(threadedSampleFunction,
                                   (void*) this);

   if ( ! mSampleThread-&gt;valid() )
   {
      mRunning = false;
      return false; // thread creation failed
   }
   else
   {
      return true; // thread creation success
   }
}

// Records (or samples) the current data.  This is called
// repeatedly by the sample thread created by startSampling().
bool ButtonDevice::sample()
{
   bool status(false);

   if ( mRunning )
   {
      // Here you would add your code to sample the hardware for
      // a button press:
      std::vector&lt;DigitalData&gt; samples(1);
      samples[0] = 1;
      addDigitalSample(samples);

      // Successful sample.
      status = true;
   }

   return status;
}

// Kills the sample thread.
bool ButtonDevice::stopSampling()
{
   mRunning = false;

   if (mSampleThread != NULL)
   {
      mSampleThread-&gt;kill();
      mSampleThread-&gt;join();
      delete mSampleThread;
      mSampleThread = NULL;
   }
   return true;
}

void ButtonDevice::updateData()
{
   if ( mRunning )
   {
      swapDigitalBuffers();
   }
}

// Our sampling function that is executed by the spawned sample
// thread.  This function is declared as a static member of
// ButtonDevice.  It simply calls ButtonDevice::sample() over and
// over.
void ButtonDevice::threadedSampleFunction(void* classPointer)
{
   ButtonDevice* this_ptr =
      static_cast&lt;ButtonDevice*&gt;(classPointer);

   // spin until someone kills "mSampleThread"
   while ( this_ptr-&gt;mRunning )
   {
     this_ptr-&gt;sample();
   }
}</programlisting>
        </example>
      </section>

      <section id="makefile.templates.section">
        <title>Makefile Templates</title>

        <para>The following is an example <filename>Makefile.in</filename>
        that could be added to the Gadgeteer build system.</para>

        <example id="example.Makefile.in">
          <title><filename>Makefile.in</filename> for Gadgeteer Build
          System</title>

          <programlisting linenumbering="unnumbered">default: all

# Include common definitions.
include @topdir@/make.defs.mk

DRIVER_NAME=    ButtonDevice

srcdir=         @srcdir@
top_srcdir=     @top_srcdir@
INSTALL=        @INSTALL@
INSTALL_FILES=
SUBOBJDIR=      $(DRIVER_NAME)
C_AFTERBUILD=   driver-dso

SRCS=           ButtonDevice.cpp \
                DriverStandalone.cpp

include $(MKPATH)/dpp.obj.mk
include @topdir@/driver.defs.mk

# Include dependencies generated automatically.
ifndef DO_CLEANDEPEND
ifndef DO_BEFOREBUILD
   -include $(DEPEND_FILES)
endif
endif</programlisting>
        </example>

        <para>The following is a makefile for a driver that is built outside
        of the Gadgeteer source tree. This cannot be used on Windows with
        Gadgeteer 1.0.</para>

        <example>
          <title>Makefile for Use Outside Gadgeteer Source Tree</title>

          <programlisting linenumbering="unnumbered">srcdir=         .
BUILD_TYPE=     dbg
#BUILD_TYPE=    opt

DRIVER_NAME=    button
SRCS=           buttondevice.cpp

include $(GADGET_BASE_DIR)/share/gadgeteer/gadget.driver.mk</programlisting>
        </example>

        <para>The following is a Visual C++ project file for a driver that is
        built outside of the Gadgeteer source tree. A Visual C++ project file
        must be used for compiling driver plug-ins on Windows.</para>

        <example>
          <title>Visual C++ Project for Use Outside Gadgeteer Source
          Tree</title>

          <programlisting linenumbering="unnumbered">&lt;?xml version="1.0" encoding = "Windows-1252"?&gt;
&lt;VisualStudioProject
        ProjectType="Visual C++"
        Version="7.00"
        Name="Driver - Button Device"
        Keyword="Win32Proj"&gt;
        &lt;Platforms&gt;
                &lt;Platform
                        Name="Win32"/&gt;
        &lt;/Platforms&gt;
        &lt;Configurations&gt;
                &lt;Configuration
                        Name="Debug|Win32"
                        OutputDirectory="DebugDLL"
                        IntermediateDirectory="DebugDLL"
                        ConfigurationType="2"
                        CharacterSet="2"&gt;
                        &lt;Tool
                                Name="VCCLCompilerTool"
                                Optimization="0"
                                AdditionalIncludeDirectories="&amp;quot;$(VJ_BASE_DIR)\include&amp;quot;;&amp;quot;$(VJ_DEPS_DIR)\include&amp;quot;"
                                PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_USRDLL;_GADGET_DRIVER_BUILD_"
                                MinimalRebuild="FALSE"
                                BasicRuntimeChecks="3"
                                RuntimeLibrary="3"
                                BufferSecurityCheck="FALSE"
                                RuntimeTypeInfo="TRUE"
                                UsePrecompiledHeader="0"
                                WarningLevel="3"
                                Detect64BitPortabilityProblems="TRUE"
                                DebugInformationFormat="1"
                                DisableSpecificWarnings="4244;4251;4267;4275;4290;4312;4800"/&gt;
                        &lt;Tool
                                Name="VCCustomBuildTool"/&gt;
                        &lt;Tool
                                Name="VCLinkerTool"
                                AdditionalDependencies="gadget_d.lib jccl_d.lib vpr_d.lib libnspr4.lib libplc4.lib ws2_32.lib $(NOINHERIT)"
                                OutputFile="$(OutDir)/button_drv_d.dll"
                                LinkIncremental="1"
                                AdditionalLibraryDirectories="&amp;quot;$(VJ_BASE_DIR)\lib&amp;quot;;&amp;quot;$(VJ_DEPS_DIR)\lib&amp;quot;"
                                GenerateDebugInformation="TRUE"
                                ProgramDatabaseFile="$(OutDir)/button_drv_d.pdb"
                                SubSystem="1"
                                ImportLibrary="$(OutDir)/button_drv_d.lib"
                                TargetMachine="1"/&gt;
                        &lt;Tool
                                Name="VCMIDLTool"/&gt;
                        &lt;Tool
                                Name="VCPostBuildEventTool"/&gt;
                        &lt;Tool
                                Name="VCPreBuildEventTool"/&gt;
                        &lt;Tool
                                Name="VCPreLinkEventTool"/&gt;
                        &lt;Tool
                                Name="VCResourceCompilerTool"/&gt;
                        &lt;Tool
                                Name="VCWebServiceProxyGeneratorTool"/&gt;
                        &lt;Tool
                                Name="VCWebDeploymentTool"/&gt;
                &lt;/Configuration&gt;
                &lt;Configuration
                        Name="Release|Win32"
                        OutputDirectory="ReleaseDLL"
                        IntermediateDirectory="ReleaseDLL"
                        ConfigurationType="2"
                        CharacterSet="2"&gt;
                        &lt;Tool
                                Name="VCCLCompilerTool"
                                Optimization="2"
                                InlineFunctionExpansion="1"
                                OmitFramePointers="TRUE"
                                AdditionalIncludeDirectories="&amp;quot;$(VJ_BASE_DIR)\include&amp;quot;;&amp;quot;$(VJ_DEPS_DIR)\include&amp;quot;"
                                PreprocessorDefinitions="WIN32;_OPT;NDEBUG;_CONSOLE;_USRDLL;_GADGET_DRIVER_BUILD_"
                                StringPooling="TRUE"
                                MinimalRebuild="FALSE"
                                RuntimeLibrary="2"
                                BufferSecurityCheck="FALSE"
                                EnableFunctionLevelLinking="TRUE"
                                RuntimeTypeInfo="TRUE"
                                UsePrecompiledHeader="0"
                                WarningLevel="3"
                                Detect64BitPortabilityProblems="TRUE"
                                DebugInformationFormat="3"
                                DisableSpecificWarnings="4244;4251;4267;4275;4290;4312;4800"/&gt;
                        &lt;Tool
                                Name="VCCustomBuildTool"/&gt;
                        &lt;Tool
                                Name="VCLinkerTool"
                                AdditionalDependencies="gadget.lib jccl.lib vpr.lib libnspr4.lib libplc4.lib ws2_32.lib $(NOINHERIT)"
                                OutputFile="$(OutDir)/button_drv.dll"
                                LinkIncremental="1"
                                AdditionalLibraryDirectories="&amp;quot;$(VJ_BASE_DIR)\lib&amp;quot;;&amp;quot;$(VJ_DEPS_DIR)\lib&amp;quot;"
                                GenerateDebugInformation="TRUE"
                                ProgramDatabaseFile="$(OutDir)/button_drv.pdb"
                                SubSystem="1"
                                OptimizeReferences="2"
                                EnableCOMDATFolding="2"
                                ImportLibrary="$(OutDir)/button_drv.lib"
                                TargetMachine="1"/&gt;
                        &lt;Tool
                                Name="VCMIDLTool"/&gt;
                        &lt;Tool
                                Name="VCPostBuildEventTool"/&gt;
                        &lt;Tool
                                Name="VCPreBuildEventTool"/&gt;
                        &lt;Tool
                                Name="VCPreLinkEventTool"/&gt;
                        &lt;Tool
                                Name="VCResourceCompilerTool"/&gt;
                        &lt;Tool
                                Name="VCWebServiceProxyGeneratorTool"/&gt;
                        &lt;Tool
                                Name="VCWebDeploymentTool"/&gt;
                &lt;/Configuration&gt;
        &lt;/Configurations&gt;
        &lt;Files&gt;
                &lt;Filter
                        Name="Source Files"
                        Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm"&gt;
                        &lt;File
                                RelativePath="buttondevice.cpp"&gt;
                        &lt;/File&gt;
                &lt;/Filter&gt;
                &lt;Filter
                        Name="Header Files"
                        Filter="h;hpp;hxx;hm;inl;inc"&gt;
                        &lt;File
                                RelativePath="buttondevice.h"&gt;
                        &lt;/File&gt;
                &lt;/Filter&gt;
                &lt;Filter
                        Name="Resource Files"
                        Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"&gt;
                &lt;/Filter&gt;
        &lt;/Files&gt;
        &lt;Globals&gt;
        &lt;/Globals&gt;
&lt;/VisualStudioProject&gt;</programlisting>
        </example>
      </section>
    </appendix>

    <appendix id="appendix.gfdl">
      <title>GNU Free Documentation License</title>

      <subtitle>Version 1.2, November 2002</subtitle>

      <blockquote id="fsf-copyright">
        <title>FSF Copyright note</title>

        <para>Copyright (C) 2000,2001,2002 Free Software Foundation, Inc. 59
        Temple Place, Suite 330, Boston, MA 02111-1307 USA Everyone is
        permitted to copy and distribute verbatim copies of this license
        document, but changing it is not allowed.</para>
      </blockquote>

      <section id="gfdl-0">
        <title>PREAMBLE</title>

        <para>The purpose of this License is to make a manual, textbook, or
        other functional and useful document "free" in the sense of freedom:
        to assure everyone the effective freedom to copy and redistribute it,
        with or without modifying it, either commercially or noncommercially.
        Secondarily, this License preserves for the author and publisher a way
        to get credit for their work, while not being considered responsible
        for modifications made by others.</para>

        <para>This License is a kind of "copyleft", which means that
        derivative works of the document must themselves be free in the same
        sense. It complements the GNU General Public License, which is a
        copyleft license designed for free software.</para>

        <para>We have designed this License in order to use it for manuals for
        free software, because free software needs free documentation: a free
        program should come with manuals providing the same freedoms that the
        software does. But this License is not limited to software manuals; it
        can be used for any textual work, regardless of subject matter or
        whether it is published as a printed book. We recommend this License
        principally for works whose purpose is instruction or
        reference.</para>
      </section>

      <section id="gfdl-1">
        <title>APPLICABILITY AND DEFINITIONS</title>

        <para id="gfdl-doc">This License applies to any manual or other work,
        in any medium, that contains a notice placed by the copyright holder
        saying it can be distributed under the terms of this License. Such a
        notice grants a world-wide, royalty-free license, unlimited in
        duration, to use that work under the conditions stated herein. The
        "Document", below, refers to any such manual or work. Any member of
        the public is a licensee, and is addressed as "you". You accept the
        license if you copy, modify or distribute the work in a way requiring
        permission under copyright law.</para>

        <para id="gfdl-mod-ver">A "Modified Version" of the Document means any
        work containing the Document or a portion of it, either copied
        verbatim, or with modifications and/or translated into another
        language.</para>

        <para id="gfdl-secnd-sect">A "Secondary Section" is a named appendix
        or a front-matter section of the Document that deals exclusively with
        the relationship of the publishers or authors of the Document to the
        Document's overall subject (or to related matters) and contains
        nothing that could fall directly within that overall subject. (Thus,
        if the Document is in part a textbook of mathematics, a Secondary
        Section may not explain any mathematics.) The relationship could be a
        matter of historical connection with the subject or with related
        matters, or of legal, commercial, philosophical, ethical or political
        position regarding them.</para>

        <para id="gfdl-inv-sect">The "Invariant Sections" are certain
        Secondary Sections whose titles are designated, as being those of
        Invariant Sections, in the notice that says that the Document is
        released under this License. If a section does not fit the above
        definition of Secondary then it is not allowed to be designated as
        Invariant. The Document may contain zero Invariant Sections. If the
        Document does not identify any Invariant Sections then there are
        none.</para>

        <para id="gfdl-cov-text">The "Cover Texts" are certain short passages
        of text that are listed, as Front-Cover Texts or Back-Cover Texts, in
        the notice that says that the Document is released under this License.
        A Front-Cover Text may be at most 5 words, and a Back-Cover Text may
        be at most 25 words.</para>

        <para id="gfdl-transparent">A "Transparent" copy of the Document means
        a machine-readable copy, represented in a format whose specification
        is available to the general public, that is suitable for revising the
        document straightforwardly with generic text editors or (for images
        composed of pixels) generic paint programs or (for drawings) some
        widely available drawing editor, and that is suitable for input to
        text formatters or for automatic translation to a variety of formats
        suitable for input to text formatters. A copy made in an otherwise
        Transparent file format whose markup, or absence of markup, has been
        arranged to thwart or discourage subsequent modification by readers is
        not Transparent. An image format is not Transparent if used for any
        substantial amount of text. A copy that is not "Transparent" is called
        "Opaque".</para>

        <para>Examples of suitable formats for Transparent copies include
        plain ASCII without markup, Texinfo input format, LaTeX input format,
        SGML or XML using a publicly available DTD, and standard-conforming
        simple HTML, PostScript or PDF designed for human modification.
        Examples of transparent image formats include PNG, XCF and JPG. Opaque
        formats include proprietary formats that can be read and edited only
        by proprietary word processors, SGML or XML for which the DTD and/or
        processing tools are not generally available, and the
        machine-generated HTML, PostScript or PDF produced by some word
        processors for output purposes only.</para>

        <para id="gfdl-title-page">The "Title Page" means, for a printed book,
        the title page itself, plus such following pages as are needed to
        hold, legibly, the material this License requires to appear in the
        title page. For works in formats which do not have any title page as
        such, "Title Page" means the text near the most prominent appearance
        of the work's title, preceding the beginning of the body of the
        text.</para>

        <para id="gfdl-entitled">A section "Entitled XYZ" means a named
        subunit of the Document whose title either is precisely XYZ or
        contains XYZ in parentheses following text that translates XYZ in
        another language. (Here XYZ stands for a specific section name
        mentioned below, such as "Acknowledgements", "Dedications",
        "Endorsements", or "History".) To "Preserve the Title" of such a
        section when you modify the Document means that it remains a section
        "Entitled XYZ" according to this definition.</para>

        <para>The Document may include Warranty Disclaimers next to the notice
        which states that this License applies to the Document. These Warranty
        Disclaimers are considered to be included by reference in this
        License, but only as regards disclaiming warranties: any other
        implication that these Warranty Disclaimers may have is void and has
        no effect on the meaning of this License.</para>
      </section>

      <section id="gfdl-2">
        <title>VERBATIM COPYING</title>

        <para>You may copy and distribute the Document in any medium, either
        commercially or noncommercially, provided that this License, the
        copyright notices, and the license notice saying this License applies
        to the Document are reproduced in all copies, and that you add no
        other conditions whatsoever to those of this License. You may not use
        technical measures to obstruct or control the reading or further
        copying of the copies you make or distribute. However, you may accept
        compensation in exchange for copies. If you distribute a large enough
        number of copies you must also follow the conditions in section
        3.</para>

        <para>You may also lend copies, under the same conditions stated
        above, and you may publicly display copies.</para>
      </section>

      <section id="gfdl-3">
        <title>COPYING IN QUANTITY</title>

        <para>If you publish printed copies (or copies in media that commonly
        have printed covers) of the Document, numbering more than 100, and the
        Document's license notice requires Cover Texts, you must enclose the
        copies in covers that carry, clearly and legibly, all these Cover
        Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
        the back cover. Both covers must also clearly and legibly identify you
        as the publisher of these copies. The front cover must present the
        full title with all words of the title equally prominent and visible.
        You may add other material on the covers in addition. Copying with
        changes limited to the covers, as long as they preserve the title of
        the Document and satisfy these conditions, can be treated as verbatim
        copying in other respects.</para>

        <para>If the required texts for either cover are too voluminous to fit
        legibly, you should put the first ones listed (as many as fit
        reasonably) on the actual cover, and continue the rest onto adjacent
        pages.</para>

        <para>If you publish or distribute Opaque copies of the Document
        numbering more than 100, you must either include a machine-readable
        Transparent copy along with each Opaque copy, or state in or with each
        Opaque copy a computer-network location from which the general
        network-using public has access to download using public-standard
        network protocols a complete Transparent copy of the Document, free of
        added material. If you use the latter option, you must take reasonably
        prudent steps, when you begin distribution of Opaque copies in
        quantity, to ensure that this Transparent copy will remain thus
        accessible at the stated location until at least one year after the
        last time you distribute an Opaque copy (directly or through your
        agents or retailers) of that edition to the public.</para>

        <para>It is requested, but not required, that you contact the authors
        of the Document well before redistributing any large number of copies,
        to give them a chance to provide you with an updated version of the
        Document.</para>
      </section>

      <section id="gfdl-4">
        <title>MODIFICATIONS</title>

        <para>You may copy and distribute a Modified Version of the Document
        under the conditions of sections 2 and 3 above, provided that you
        release the Modified Version under precisely this License, with the
        Modified Version filling the role of the Document, thus licensing
        distribution and modification of the Modified Version to whoever
        possesses a copy of it. In addition, you must do these things in the
        Modified Version:</para>

        <orderedlist id="gfdl-modif-cond" numeration="upperalpha">
          <title>GNU FDL Modification Conditions</title>

          <listitem>
            <simpara>Use in the Title Page (and on the covers, if any) a title
            distinct from that of the Document, and from those of previous
            versions (which should, if there were any, be listed in the
            History section of the Document). You may use the same title as a
            previous version if the original publisher of that version gives
            permission.</simpara>
          </listitem>

          <listitem>
            <simpara>List on the Title Page, as authors, one or more persons
            or entities responsible for authorship of the modifications in the
            Modified Version, together with at least five of the principal
            authors of the Document (all of its principal authors, if it has
            fewer than five), unless they release you from this
            requirement.</simpara>
          </listitem>

          <listitem>
            <simpara>State on the Title page the name of the publisher of the
            Modified Version, as the publisher.</simpara>
          </listitem>

          <listitem>
            <simpara>Preserve all the copyright notices of the
            Document.</simpara>
          </listitem>

          <listitem>
            <simpara>Add an appropriate copyright notice for your
            modifications adjacent to the other copyright notices.</simpara>
          </listitem>

          <listitem>
            <simpara>Include, immediately after the copyright notices, a
            license notice giving the public permission to use the Modified
            Version under the terms of this License, in the form shown in the
            <link linkend="gfdl-addendum">Addendum</link> below.</simpara>
          </listitem>

          <listitem>
            <simpara>Preserve in that license notice the full lists of
            Invariant Sections and required Cover Texts given in the
            Document's license notice.</simpara>
          </listitem>

          <listitem>
            <simpara>Include an unaltered copy of this License.</simpara>
          </listitem>

          <listitem>
            <simpara>Preserve the section Entitled "History", Preserve its
            Title, and add to it an item stating at least the title, year, new
            authors, and publisher of the Modified Version as given on the
            Title Page. If there is no section Entitled "History" in the
            Document, create one stating the title, year, authors, and
            publisher of the Document as given on its Title Page, then add an
            item describing the Modified Version as stated in the previous
            sentence.</simpara>
          </listitem>

          <listitem>
            <simpara>Preserve the network location, if any, given in the
            Document for public access to a Transparent copy of the Document,
            and likewise the network locations given in the Document for
            previous versions it was based on. These may be placed in the
            "History" section. You may omit a network location for a work that
            was published at least four years before the Document itself, or
            if the original publisher of the version it refers to gives
            permission.</simpara>
          </listitem>

          <listitem>
            <simpara>For any section Entitled "Acknowledgements" or
            "Dedications", Preserve the Title of the section, and preserve in
            the section all the substance and tone of each of the contributor
            acknowledgements and/or dedications given therein.</simpara>
          </listitem>

          <listitem>
            <simpara>Preserve all the Invariant Sections of the Document,
            unaltered in their text and in their titles. Section numbers or
            the equivalent are not considered part of the section
            titles.</simpara>
          </listitem>

          <listitem>
            <simpara>Delete any section Entitled "Endorsements". Such a
            section may not be included in the Modified Version.</simpara>
          </listitem>

          <listitem>
            <simpara>Do not retitle any existing section to be Entitled
            "Endorsements" or to conflict in title with any Invariant
            Section.</simpara>
          </listitem>

          <listitem>
            <simpara>Preserve any Warranty Disclaimers.</simpara>
          </listitem>
        </orderedlist>

        <para>If the Modified Version includes new front-matter sections or
        appendices that qualify as Secondary Sections and contain no material
        copied from the Document, you may at your option designate some or all
        of these sections as invariant. To do this, add their titles to the
        list of Invariant Sections in the Modified Version's license notice.
        These titles must be distinct from any other section titles.</para>

        <para>You may add a section Entitled "Endorsements", provided it
        contains nothing but endorsements of your Modified Version by various
        parties--for example, statements of peer review or that the text has
        been approved by an organization as the authoritative definition of a
        standard.</para>

        <para>You may add a passage of up to five words as a Front-Cover Text,
        and a passage of up to 25 words as a Back-Cover Text, to the end of
        the list of Cover Texts in the Modified Version. Only one passage of
        Front-Cover Text and one of Back-Cover Text may be added by (or
        through arrangements made by) any one entity. If the Document already
        includes a cover text for the same cover, previously added by you or
        by arrangement made by the same entity you are acting on behalf of,
        you may not add another; but you may replace the old one, on explicit
        permission from the previous publisher that added the old one.</para>

        <para>The author(s) and publisher(s) of the Document do not by this
        License give permission to use their names for publicity for or to
        assert or imply endorsement of any Modified Version.</para>
      </section>

      <section id="gfdl-5">
        <title>COMBINING DOCUMENTS</title>

        <para>You may combine the Document with other documents released under
        this License, under the terms defined in <link
        linkend="gfdl-4">section 4</link> above for modified versions,
        provided that you include in the combination all of the Invariant
        Sections of all of the original documents, unmodified, and list them
        all as Invariant Sections of your combined work in its license notice,
        and that you preserve all their Warranty Disclaimers.</para>

        <para>The combined work need only contain one copy of this License,
        and multiple identical Invariant Sections may be replaced with a
        single copy. If there are multiple Invariant Sections with the same
        name but different contents, make the title of each such section
        unique by adding at the end of it, in parentheses, the name of the
        original author or publisher of that section if known, or else a
        unique number. Make the same adjustment to the section titles in the
        list of Invariant Sections in the license notice of the combined
        work.</para>

        <para>In the combination, you must combine any sections Entitled
        "History" in the various original documents, forming one section
        Entitled "History"; likewise combine any sections Entitled
        "Acknowledgements", and any sections Entitled "Dedications". You must
        delete all sections Entitled "Endorsements".</para>
      </section>

      <section id="gfdl-6">
        <title>COLLECTIONS OF DOCUMENTS</title>

        <para>You may make a collection consisting of the Document and other
        documents released under this License, and replace the individual
        copies of this License in the various documents with a single copy
        that is included in the collection, provided that you follow the rules
        of this License for verbatim copying of each of the documents in all
        other respects.</para>

        <para>You may extract a single document from such a collection, and
        distribute it individually under this License, provided you insert a
        copy of this License into the extracted document, and follow this
        License in all other respects regarding verbatim copying of that
        document.</para>
      </section>

      <section id="gfdl-7">
        <title>AGGREGATION WITH INDEPENDENT WORKS</title>

        <para>A compilation of the Document or its derivatives with other
        separate and independent documents or works, in or on a volume of a
        storage or distribution medium, is called an "aggregate" if the
        copyright resulting from the compilation is not used to limit the
        legal rights of the compilation's users beyond what the individual
        works permit. When the Document is included in an aggregate, this
        License does not apply to the other works in the aggregate which are
        not themselves derivative works of the Document.</para>

        <para>If the Cover Text requirement of section 3 is applicable to
        these copies of the Document, then if the Document is less than one
        half of the entire aggregate, the Document's Cover Texts may be placed
        on covers that bracket the Document within the aggregate, or the
        electronic equivalent of covers if the Document is in electronic form.
        Otherwise they must appear on printed covers that bracket the whole
        aggregate.</para>
      </section>

      <section id="gfdl-8">
        <title>TRANSLATION</title>

        <para>Translation is considered a kind of modification, so you may
        distribute translations of the Document under the terms of section 4.
        Replacing Invariant Sections with translations requires special
        permission from their copyright holders, but you may include
        translations of some or all Invariant Sections in addition to the
        original versions of these Invariant Sections. You may include a
        translation of this License, and all the license notices in the
        Document, and any Warranty Disclaimers, provided that you also include
        the original English version of this License and the original versions
        of those notices and disclaimers. In case of a disagreement between
        the translation and the original version of this License or a notice
        or disclaimer, the original version will prevail.</para>

        <para>If a section in the Document is Entitled "Acknowledgements",
        "Dedications", or "History", the requirement (section 4) to Preserve
        its Title (section 1) will typically require changing the actual
        title.</para>
      </section>

      <section id="gfdl-9">
        <title>TERMINATION</title>

        <para>You may not copy, modify, sublicense, or distribute the Document
        except as expressly provided for under this License. Any other attempt
        to copy, modify, sublicense or distribute the Document is void, and
        will automatically terminate your rights under this License. However,
        parties who have received copies, or rights, from you under this
        License will not have their licenses terminated so long as such
        parties remain in full compliance.</para>
      </section>

      <section id="gfdl-10">
        <title>FUTURE REVISIONS OF THIS LICENSE</title>

        <para>The Free Software Foundation may publish new, revised versions
        of the GNU Free Documentation License from time to time. Such new
        versions will be similar in spirit to the present version, but may
        differ in detail to address new problems or concerns. See
        http://www.gnu.org/copyleft/.</para>

        <para>Each version of the License is given a distinguishing version
        number. If the Document specifies that a particular numbered version
        of this License "or any later version" applies to it, you have the
        option of following the terms and conditions either of that specified
        version or of any later version that has been published (not as a
        draft) by the Free Software Foundation. If the Document does not
        specify a version number of this License, you may choose any version
        ever published (not as a draft) by the Free Software
        Foundation.</para>
      </section>

      <section id="gfdl-addendum">
        <title>ADDENDUM: How to use this License for your documents</title>

        <para>To use this License in a document you have written, include a
        copy of the License in the document and put the following copyright
        and license notices just after the title page:</para>

        <blockquote id="copyright-sample">
          <title>Sample Invariant Sections list</title>

          <para>Copyright (c) YEAR YOUR NAME. Permission is granted to copy,
          distribute and/or modify this document under the terms of the GNU
          Free Documentation License, Version 1.2 or any later version
          published by the Free Software Foundation; with no Invariant
          Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of
          the license is included in the section entitled "GNU Free
          Documentation License".</para>
        </blockquote>

        <para>If you have Invariant Sections, Front-Cover Texts and Back-Cover
        Texts, replace the "with...Texts." line with this:</para>

        <blockquote id="inv-cover-sample">
          <title>Sample Invariant Sections list</title>

          <para>with the Invariant Sections being LIST THEIR TITLES, with the
          Front-Cover Texts being LIST, and with the Back-Cover Texts being
          LIST.</para>
        </blockquote>

        <para>If you have Invariant Sections without Cover Texts, or some
        other combination of the three, merge those two alternatives to suit
        the situation.</para>

        <para>If your document contains nontrivial examples of program code,
        we recommend releasing these examples in parallel under your choice of
        free software license, such as the GNU General Public License, to
        permit their use in free software.</para>
      </section>
    </appendix>
  </part>

  <bibliography>
    <biblioentry id="ref.pthreads.programming">
      <abbrev>Nic96</abbrev>

      <authorgroup>
        <author>
          <firstname>Bradford</firstname>

          <surname>Nichols</surname>
        </author>

        <author>
          <firstname>Dick</firstname>

          <surname>Buttlar</surname>
        </author>

        <author>
          <firstname>Jacqueline</firstname>

          <othername>Proulx</othername>

          <surname>Farrell</surname>
        </author>
      </authorgroup>

      <title>Pthreads Programming</title>

      <subtitle>A POSIX Standard for Better Multiprocessing</subtitle>

      <publisher>
        <publishername>O'Reilly &amp; Associates</publishername>
      </publisher>

      <pubdate>1996</pubdate>
    </biblioentry>

    <biblioentry id="ref.eolson.thesis">
      <abbrev>Ols92</abbrev>

      <author>
        <firstname>Eric</firstname>

        <surname>Olson</surname>
      </author>

      <title>Cluster Juggler: PC cluster virtual reality</title>

      <publisher>
        <publishername>Iowa State University</publishername>
      </publisher>

      <orgname>Dept. of Electrical and Computer Engineering</orgname>

      <pubdate>2002</pubdate>
    </biblioentry>

    <biblioentry id="ref.advanced.prog.unix">
      <abbrev>Ste92</abbrev>

      <author>
        <firstname>W. Richard</firstname>

        <surname>Stevens</surname>
      </author>

      <title>Advanced Programming in the UNIX Environment</title>

      <publisher>
        <publishername>Addison-Wesley</publishername>
      </publisher>

      <pubdate>1992</pubdate>
    </biblioentry>

    <biblioentry id="ref.unix.network.programming">
      <abbrev>Ste98</abbrev>

      <author>
        <firstname>W. Richard</firstname>

        <surname>Stevens</surname>
      </author>

      <title>UNIX Network Programming</title>

      <volumenum>Volume 1</volumenum>

      <subtitle>Network APIS: Sockets and XTI</subtitle>

      <edition>Second Edition</edition>

      <publisher>
        <publishername>Prentice-Hall PTR</publishername>
      </publisher>

      <pubdate>1998</pubdate>
    </biblioentry>
  </bibliography>

  <glossary>
    <title>Glossary of Terms</title>

    <glossdiv>
      <title>B</title>

      <glossentry id="gloss.bsd.sockets">
        <glossterm>BSD sockets</glossterm>

        <glossdef>
          <para>The socket programming interface introduced with the Berkeley
          Software Distribution version of the UNIX operating system. It is
          made up of a collection of system calls that allow highly flexible
          socket programming. Most UNIX variants in use today use the BSD
          sockets API. Moreover, the Winsock API used on Windows is based on
          this API.</para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>N</title>

      <glossentry id="gloss.nspr">
        <glossterm>Netscape Portable Runtime</glossterm>

        <acronym>NSPR</acronym>

        <glossdef>
          <para>More information can be found at <ulink
          url="http://www.mozilla.org/projects/nspr/index.html">http://www.mozilla.org/projects/nspr/index.html</ulink></para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>V</title>

      <glossentry id="gloss.vpr">
        <glossterm>VR Juggler Portable Runtime</glossterm>

        <acronym>VPR</acronym>

        <glossdef>
          <para>More information can be found at <ulink
          url="http://www.vrjuggler.org/vapor/">http://www.vrjuggler.org/vapor/</ulink></para>
        </glossdef>
      </glossentry>
    </glossdiv>
  </glossary>

  <index></index>
</book>

<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="../../../../../../../../../../../home/users/patrick/src/Juggler/docs/stylesheet/docbook_ab.css" type="text/css"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<book>
   <bookinfo>
      <title>Tweek</title>
      <subtitle>The Programmer's Guide</subtitle>
      <authorgroup>
         <author>
            <firstname>Patrick</firstname>
            <surname>Hartling</surname>
         </author>
      </authorgroup>
      <releaseinfo>0.0.2</releaseinfo>
      <pubdate>$Date$</pubdate>
   </bookinfo>
   <preface>
      <title>Preface</title>
      <para>This book is the programmer's guide for Tweek. The main focus is how to use the features and capabilities of Tweek to enable cross-platform Java graphical user interfaces (GUIs) to communicate with C++ applications.</para>
      <para>The history of Tweek dates back to April 2000, though the basis for its existence comes from circa 1997. At Iowa State University's Virtual Reality Applications Center, the idea of using a Java GUI to communicate with, and possibly perform manipulations on, C++ applications is the foundation for dynamic reconfiguration of VR Juggler. To that end, the Java application VjControl was developed specifically for that purpose. VjControl was started in 1997 and has been under development ever since.</para>
      <para>Building on the basic idea of a Java GUI that could communicate with a C++ application, a viewer was written for the Distributed Shared Object (DSO) software system written in April 2000. This iteration of DSO was for a class project (Computer Science 552 taught by Dr. Johnny Wong). At the time, we (Allen Bierbaum and I) felt that CORBA could be used as a way to share arbitrary object-based information between applications on a network. The Java GUI was used to visualize the network of CORBA-connected nodes and to manipulate the network by disconnecting and reconnecting the nodes. In the end, CORBA was not the right solution to this problem, but the basis for network visualization was founded. Using CORBA for communication between the C++ code and Java code was relatively easy, however.</para>
      <para>In April 2001, we were again faced with a class project. Based on the results of the CORBA-based DSO, we felt that it would be best to implement a peer-to-peer software multicasting system that would be more efficient than CORBA. This new system, called Plexus, would still offer the same capabilities of cross-platform data distribution, but we had to give up the inherent cross-language support offered by CORBA. Again, we wanted a Java GUI for visualizing the network, and we started with the DSO viewer code. Instead of using CORBA, which we had had some difficulties with the previous year, we chose to use Java's built-in Remote Method Invocation (RMI) system. While RMI is very easy to use between two Java applications, Java to C++ communication is difficult. It requires the use of the Java Native Interface (JNI) so that natively compiled C++ code can communicate in memory with a loaded Java virtual machine (JVM). All of the Java code and RMI was collected into a package called PlxView (<quote>plex-view</quote>).</para>
      <para>Despite the difficulty of writing JNI code, the RMI solution was effective, for the most part. In September 2001, yet another project loomed. By this time, we were fed up with RMI, and we decided to go back to CORBA solely for communicating between Java and C++. Indeed, by using CORBA, we could write network visualization software in <emphasis>any</emphasis> language and communicate through the same channels.</para>
      <para>Beyond just communicating with the C++ applications, we had high hopes for using RMI to download Java code at run time to add custom visualization panels to the Java GUI dynamically. The Java code would come in the form of JavaBeans. While PlxView was designed to be modular from the start, we had not implemented the code for downloading the JavaBeans. To begin that work, I started writing code on a flight from Dallas/Ft. Worth to London, England, the evening of October 1, 2001. While at a CAVE workshop in Stockholm, Sweden, I took advantage of down time and late nights to extend PlxView to load and use JavaBeans.</para>
      <para>When I returned to the United States after the week in Stockholm, PlxView had evolved into what could be called version 0.0.0 of the Tweek Java GUI (sans CORBA, however). Its primary purpose was still Plexus network visualization. Design discussions with other members of the Juggler Team evolved the code into what is now the Tweek Java API. The Plexus-specific parts were separated into what is now the PlxView Bean, and the remaining code was moved into the new Tweek source tree.</para>
      <para>The only remaining piece was CORBA support. Another student, Andrew Schwantes, had been experimenting with CORBA in a smaller system, and his C++ CORBA code was used as a starting point for the Tweek C++ API. After much discussion with Allen Bierbaum, the code was re-implementing to implement the subject/observer design pattern, and the Subject Manager was added. After all of that, the Java CORBA code was relatively trivial to add. And thus, the foundation for Tweek was in place by November 2001. By this time, it was already in use by the Fall 2001 Plexus class project.</para>
   </preface>
   <part>
      <title>Introduction</title>
      <chapter id="intro.tweek.chapter">
         <title>Tweek</title>
         <para>Programmers using Tweek must first understand what it is and what at does, at least at a conceptual level. Tweek has two parts: a Java <glossterm linkend="gloss.api">API</glossterm> and a C++ API. The two provide very distinct functionality, but they share a common bond through the use of remote method calls on shared objects. Objects defined in the C++ programming language can be accessed by objects defined in the Java programming language. Similarly, objects defined in Java can be accessed by C++ code. The C++ objects may be visualized and manipulated using the Tweek Java <glossterm linkend="gloss.gui">graphical user interface</glossterm> (GUI), a tool written using the Tweek Java API. This cross-language functionality is achieved through the use of remote method calls.</para>
         <para>Some readers may be familiar with remote procedure calls (RPC), a remote programming system first introduced by Sun Microsystems that uses the procedural programming paradigm. Remote method calls differ primarily through the use of the object-oriented programming paradigm. Tweek is implemented in two object-oriented languages and thus lends itself very well to a system implementing remote method calls.</para>
         <para>In the remainder of this chapter, we present a high-level description of the Tweek C++ API. The Java API design is much more complex and is not included in this revision. Most users of Tweek need to know more about the C++ side of Tweek than the Java side. This is because Tweek is designed around the philosophy of a simple Java GUI interacting with a potentially complex C++ application.</para>
         <section id="intro.design.section">
            <title>C++ API Design Overview</title>
            <para>The heart of the Tweek software system implements a subject/observer pattern <xref linkend="Gam95"/>. This pattern is used to define the relationship between the Java GUI (observer) and the C++ application (subject). Within this section, we explain how the subject and observer are used. Moving beyond the subject/observer pattern, we also explain the <firstterm>Subject Manager</firstterm><indexterm>
                  <primary>Subject Manager</primary>
               </indexterm> and the <firstterm>CORBA Manager</firstterm><indexterm>
                  <primary>CORBA Manager</primary>
               </indexterm>. These four components make up the entirety of the C++ design.</para>
            <section>
               <title>Subject</title>
               <indexterm>
                  <primary>subject</primary>
                  <secondary>design and use</secondary>
               </indexterm>
               <para>The subjects in Tweek are part of the C++ applications. The communication <quote>channels</quote> are defined by the subjects' interfaces. An observer is attached to a subject, and whenever the state of a subject changes, it notifies all of its attached observers.</para>
               <para>The Tweek C++ API defines the basic subject interface (<interfacename>tweek::Subject</interfacename><indexterm>
                     <primary>interfaces</primary>
                     <secondary>tweek::Subject</secondary>
                  </indexterm>) that implements the subject pattern <xref linkend="Gam95"/>. Users of the Tweek C++ API derive from the base subject implementation (<classname>tweek::SubjectImpl</classname><indexterm>
                     <primary>classes</primary>
                     <secondary>tweek::SubjectImpl</secondary>
                  </indexterm>) and extend it by adding their own interface methods. This extension is twofold. First, an interface must be defined using the <glossterm linkend="gloss.idl">Interface Definition Language</glossterm> (IDL)<indexterm>
                     <primary>IDL</primary>
                  </indexterm>. Then, the interface must be implemented in C++ code. (Refer to <xref linkend="intro.corba.idl.section"/> for more information about IDL in Tweek.)</para>
            </section>
            <section>
               <title>Observer</title>
               <indexterm>
                  <primary>observer</primary>
                  <secondary>design and use</secondary>
               </indexterm>
               <para>The observers in Tweek are part of the Java GUI. They observe the state of the remote subjects and can provide a visual rendering of that state.</para>
               <para>Programmers <emphasis>do not</emphasis> define interfaces for the observers. Similar to subjects, the Tweek C++ API defines a basic observer interface called <interfacename>tweek::Observer</interfacename><indexterm>
                     <primary>interfaces</primary>
                     <secondary>tweek::Observer</secondary>
                  </indexterm>. There is no <quote>standard</quote> observer implementation that corresponds to <classname>tweek::SubjectImpl</classname><indexterm>
                     <primary>classes</primary>
                     <secondary>tweek::SubjectImpl</secondary>
                  </indexterm>, however. By design, observers must correspond directly with subjects, but there is no need to extend the basic observer interface. Observer implementations simply inherit from the basic observer class (<classname>tweek.ObserverPOA</classname><indexterm>
                     <primary>classes</primary>
                     <secondary>tweek.ObserverPOA</secondary>
                  </indexterm>) and implement the <methodname>update()</methodname> method. Other extensions can be added in the custom Java class, of course, but an implementation of <methodname>update()</methodname> is always required.</para>
            </section>
            <section>
               <title>CORBA Manager</title>
               <indexterm>
                  <primary>CORBA Manager</primary>
                  <secondary>design and use</secondary>
               </indexterm>
               <para><glossterm linkend="gloss.corba">CORBA</glossterm> tends to have a high learning curve. It is a very powerful system, but that power leads to a lot of complexity. To reduce the complexity of starting and using an <glossterm linkend="gloss.orb">ORB</glossterm>, Tweek provides a CORBA Manager. Its primary function is to initialize a local ORB. It does this by creating the <glossterm linkend="gloss.poa">Portable Object Adapter</glossterm> (POA), resolving the initial reference to the Naming Service, and starting a thread for the ORB to handle requests.</para>
               <note>
                  <para>An explanation of the POA is beyond the scope of this book. Users of Tweek do not have to use the POA directly because the CORBA Manager and Subject Manager hide these details. Interested readers are referred to <xref linkend="Hen99"/> for more information about the POA and CORBA in general.</para>
               </note>
               <para>Once the local ORB is initialized, the Subject Manager (discussed next) must be created. This is also done through the CORBA Manager because the Subject Manager is a CORBA object. The newly created Subject Manager will be a <glossterm linkend="gloss.servant">servant</glossterm> object to which CORBA references can be created.</para>
               <para>Refer to <xref linkend="intro.corba.section"/> for more information about CORBA and its use in Tweek. For the most part, the use of CORBA is an implementation detail. Users of the Tweek C++ API must initialize the CORBA Manager, however, and it is important to understand its place in the overall system.</para>
            </section>
            <section>
               <title>Subject Manager</title>
               <indexterm>
                  <primary>Subject Manager</primary>
                  <secondary>design and use</secondary>
               </indexterm>
               <para>The Tweek Subject Manager exists to simplify the use of CORBA further. At a very high level, it acts as a simplified, specialized CORBA Naming Service. Users of Tweek register subject servants with the Subject Manager. The Subject Manager handles the CORBA registration and activation of the servants. After being registered, subjects are accessed using symbolic strings. The strings are user-defined and do not necessarily conform to any CORBA-related standard. They are, in essence, identifiers used to look up the subject within the Subject Manager's collection of known subjects.</para>
            </section>
         </section>
         <section id="intro.corba.section">
            <title>CORBA</title>
            <indexterm>
               <primary>CORBA</primary>
               <secondary>use in Tweek</secondary>
            </indexterm>
            <para>CORBA, the <glossterm linkend="gloss.corba">Common Object Request Broker Architecture</glossterm>, is a powerful tool for <glossterm linkend="gloss.distrib-programming">distributed programming</glossterm>. It is a <emphasis>language-independent</emphasis> standard specified by the <ulink url="http://www.omg.org/">Object Management Group</ulink> (OMG). Many CORBA implementations, both free and commercial, exist for a wide variety of languages (e.g., C, C++, Java, Perl, Python, and Smalltalk). CORBA allows communication between software written in any programming language running on any operating system on any hardware architecture. It handles all serialization and de-serialization of objects and method parameters so that programmers do not have to worry about endian issues and other system incompatibilities.</para>
            <para>Before going further with the discussion of CORBA in Tweek, readers must be familiar with some terminology. In CORBA, the physical object to which references are made is called a <glossterm linkend="gloss.servant"><firstterm>servant</firstterm></glossterm>. The servant is an instance of some class that implements an interface and derives from <classname>CORBA::Object</classname> (or <classname>org.omg.CORBA.Object</classname> in Java). The actual details of servant implementations are postponed for later sections. For now, it is important to remember that there will be an object located in physical memory on some machine, and <emphasis>references</emphasis> will be made to that object through CORBA. Users acquire references by looking up the object by name in what is known as the CORBA <firstterm>Naming Service</firstterm>. The Naming Service has objects registered within its database, and clients request references from the database. When the reference is made available, methods may be invoked on it. Since the physical object resides in another memory space, this will create network traffic, though it is entirely transparent to the programmer.</para>
            <para>CORBA uses <glossterm linkend="gloss.orb">Object Request Brokers</glossterm> (ORBs) to manage locally registered objects and to communicate with remote objects. The remote objects are managed by ORBs that reside locally on the machines that have the servants. Two ORBs communicate with each other using a standard protocol. In this case, that protocol is the <glossterm linkend="gloss.iiop">Internet Inter-ORB Protocol</glossterm> (IIOP). IIOP is a new addition to Version 2.3 of the CORBA standard. It allows two ORBs written by different vendors to communicate and inter-operate. This capability is crucial to the correct functionality of Tweek and many other CORBA-based software systems.</para>
            <para>Within the scope of Tweek, CORBA is used to enable transparent communication between C++ applications and the Tweek Java GUI. C++ objects registered with a local ORB are made available to the Java GUI through the Subject Manager. Beyond this, CORBA exists mostly "behind the scenes" so that developers of Tweek-based software do not have to learn very much about CORBA. Programmers must understand the Interface Definition Language, however, and this is explained next.</para>
            <section id="intro.corba.idl.section">
               <title>Interface Definition Language</title>
               <para>The <glossterm linkend="gloss.idl">Interface Definition Language</glossterm> (IDL)<indexterm>
                     <primary>IDL</primary>
                  </indexterm> is used by the CORBA standard to define the <emphasis>interfaces</emphasis> for remotely accessible objects. An IDL file looks very much like a simple C++ class declaration in a header file, though data members are not allowed in the interface. Thus, IDL is used exclusively to define the methods of the objects and external data structures that may be passed as arguments to those methods.</para>
               <para>The interfaces alone are not sufficient to implement objects that may be handled by CORBA. A language-specific implementation must be written so that servants can be instantiated and registered with an ORB. To implement an interface, an <glossterm linkend="gloss.idl-compiler">IDL compiler</glossterm> must first be used to generate skeleton code for a specific language from the IDL file. Using the generated code, an implementation is then written. In <xref linkend="prog.idl.chapter"/>, we explain in more detail how to use IDL to define interfaces.</para>
            </section>
            <section>
               <title>Supported Languages</title>
               <para>As discussed above, a very powerful feature of CORBA is its language independence. Tweek itself supports only C++ and Java as of this writing. There is no restriction, other than time and resources, that prevents the addition of support for other languages. In this section, we explain how C++ and Java are used in Tweek.</para>
               <section>
                  <title>C++</title>
                  <para>A key part of the overall Tweek design is that complex, high-performance applications will be written in C++. While this may not necessarily be the case in every situation, this is the assumption made for the design and implementation of the Tweek C++ API. As mentioned previously, support could be added for other languages so that they too may fulfill the role of C++ in Tweek.</para>
                  <para>Using the C++ API, programmers activate a local ORB. Once an ORB is available, servants that will act as subjects can be registered with the Subject Manager. The subjects are activated within the local POA by the Subject Manager, thus alleviating some work for programmers. Once activated, the subjects may be accessed remotely through CORBA by code written in any language&mdash;including C++.</para>
               </section>
               <section>
                  <title>Java</title>
                  <para>In the Java programming language, the Swing API provides developers with a very nice suite of classes for writing cross-platform GUIs called Swing. When developing Tweek, we took advantage of Swing and JavaBeans technology <xref linkend="Jbe02"/> to write a generalized GUI framework. Users can plug components (Beans) into this framework at runtime to extend its functionality. The Beans can get access to remote C++ objects through the CORBA services provided by the Tweek Java API. Similar to the C++ API, the use of CORBA in Java has been simplified so that programmers can use it with little effort and without a comprehensive understanding of CORBA in general.</para>
                  <para>Programmers will use Java as part of their Tweek programming to write JavaBeans. Compared to the potential complexity of the GUI code for Beans, little CORBA programming must be done in Java. Beans may be as simple or as complex as necessary to meet the needs of individual projects. More information about JavaBeans is provided in <xref linkend="intro.javabeans.chapter"/>.</para>
               </section>
            </section>
         </section>
      </chapter>
      <chapter id="intro.javabeans.chapter">
         <title>JavaBeans</title>
         <para>The Tweek Java GUI uses JavaBeans to be more flexible and accessible to programmers. The GUI is a framework into which graphical and non-graphical components may be <quote>plugged</quote>. Graphical components add interaction functionality. Non-graphical components extend internal functionality, oftentimes needed by the graphical components. Conceptually, this follows the traditional use of plug-in architectures wherein the components are discovered dynamically and added into the larger framework. In the case of the Tweek Java GUI, the plug-ins will fit into one of four categories, the most important of which is <firstterm>Panel Bean</firstterm>.</para>
         <section>
            <title>Bean Categories</title>
            <para>There are four types of Beans that may be loaded by the Tweek Java GUI. They are categorized based on functionality and what is known about them in advance. The following lists the four categories in order of decreasing <foreignphrase>a priori</foreignphrase> knowledge.</para>
            <orderedlist>
               <listitem>
                  <para>Service Beans</para>
               </listitem>
               <listitem>
                  <para>Viewer Beans</para>
               </listitem>
               <listitem>
                  <para>Panel Beans</para>
               </listitem>
               <listitem>
                  <para>Generic Beans</para>
               </listitem>
            </orderedlist>
            <section>
               <title>Service Beans</title>
               <indexterm>
                  <primary>Service Beans</primary>
               </indexterm>
               <para>Services encapsulate functionality that may be useful to other parts of the Tweek system or dynamically loaded code. The entire interface for Service Beans must be known when the code using the service is compiled. This is because the using code needs to be able to take advantage of the service. Because Service Beans may be loaded dynamically, using code must be prepared for the case when the Bean containing the service was not found. In other words, code that uses services cannot necessarily assume that the service will be available.</para>
               <para>Not all services are loaded dynamically as Beans. Some services are loaded statically because they are needed by core components. These include the Environment Service and the Global Preferences Service. There is a guarantee that the code for these services will always be available. This guarantee is especially important because the Tweek core needs to add information to the Environment Service at startup. The Global Preferences Service is needed to configure the overall behavior of the Tweek GUI.</para>
            </section>
            <section>
               <title>Viewer Beans</title>
               <indexterm>
                  <primary>Viewer Beans</primary>
               </indexterm>
               <para>Viewer Beans provide a rendering of the tree of Panel Beans (discussed next). They provide the viewer component of the model/view pattern <xref linkend="Gam95"/>. All Viewer Beans are loaded dynamically, and the active viewer can be changed at runtime by editing the global preferences. This feature is realized through the flexibility of the model/view pattern.</para>
               <para>Viewer Beans must implement the <interfacename>org.vrjuggler.tweek.beans.BeanModelViewer</interfacename> interface. To simplify implementation, they may be derived from <classname>org.vrjuggler.tweek.beans.DefaultBeanModelViewer</classname>, a class that implements aspects of the interface that are unlikely to vary between viewer implementations. The use of the interface is needed so that the GUI frame can assume certain behaviors about the viewer.</para>
            </section>
            <section>
               <title>Panel Beans</title>
               <indexterm>
                  <primary>Panel Beans</primary>
               </indexterm>
               <para>Most programmers using Tweek will write Panel Beans. These provide custom interfaces for whatever users need. In most cases, a Panel Bean will provide a graphical interface that can manipulate and/or control a C++ application, but developers are not strictly limited to this use.</para>
               <para>Only one assumption is made about Panel Beans: the primary class for the Bean must be a subclass of <classname>javax.swing.JComponent</classname>. Optionally, the primary class may implement one or more publicly provided interfaces that provide the Java GUI with more information about the capabilities of the Bean. When loaded, the GUI checks to see what, if any, interfaces are implemented by the Bean. Based on the results, special actions may be taken to provide the Bean with extended functionality.</para>
               <para>For example, Beans that can load files should implement <interfacename>org.vrjuggler.tweek.beans.FileLoader</interfacename>. When the Bean is focused in the viewer, the <guimenu>File</guimenu> menu will be modified to enable the <guimenuitem>Open</guimenuitem>, <guimenuitem>Save</guimenuitem>, and <guimenuitem>Close</guimenuitem> items. If the user selects one of these items, the Bean is informed and can take appropriate customized actions. The result in this case is context-specific loading and unloading of files.</para>
            </section>
            <section>
               <title>Generic Beans</title>
               <indexterm>
                  <primary>Generic Beans</primary>
               </indexterm>
               <para>Nothing at all is assumed about Generic Beans. This Bean category is provided so that other Beans can do their own dynamic code loading. For example, a Bean that uses a factory pattern may want to have the <quote>workers</quote> loaded dynamically based on some criteria. Thus, the functionality of the factory can be changed dynamically.</para>
               <para>The Tweek Java GUI does not use Generic Beans itself. These are provided more for users of the Tweek Java API. It is up to those programmers to decide how to handle the Generic Beans on a case-by-case basis.</para>
            </section>
         </section>
         <section>
            <title>XML</title>
            <indexterm>
               <primary>Bean descriptions</primary>
               <secondary>using XML</secondary>
            </indexterm>
            <para>All JavaBeans loaded by the Tweek Java GUI are describe by at least one <glossterm linkend="gloss.xml.main">XML</glossterm> file<indexterm>
                  <primary>XML</primary>
               </indexterm>. The XML file can contain information about many Beans or about a single Bean. The XML file itself is a <quote>beanlist</quote> document. The four Bean categories, described above, each have an XML element that has children giving information about the specific Bean. The elements are <sgmltag>&lt;service&gt;</sgmltag>, <sgmltag>&lt;viewer&gt;</sgmltag>, <sgmltag>&lt;guipanel&gt;</sgmltag>, and <sgmltag>&lt;generic&gt;</sgmltag>.</para>
            <para>All Bean XML entries must contain a <sgmltag>&lt;file&gt;</sgmltag> element. Through its <literal>source</literal> attribute, this element provides the path to the JAR file that contains the full Bean code. When specifying the JAR file path, environment variables may be used. They must use the syntax <varname>${ENV_VAR}</varname> (the curly braces are required). The <literal>class</literal> element gives the fully qualified name of the class stored within the JAR file that will be instantiated. The extension <filename>.class</filename> must not be specified. This is to allow the use of serialized classes which have the extension <filename>.ser</filename>. The Tweek Bean-loading code will figure out what is available and take the right actions.</para>
            <para>In addition to the <sgmltag>&lt;file&gt;</sgmltag> element, there may be zero or more <sgmltag>&lt;dependency&gt;</sgmltag> elements. These list dependencies of the Bean named as other external JAR files. The <sgmltag>&lt;dependency&gt;</sgmltag> element has two attributes: <literal>file</literal> and <literal>path</literal>. The attribute <literal>file</literal> names the JAR file; <literal>path</literal> gives the path (a semi-colon separated list of directories) where the JAR file may be found.</para>
            <para>Of the four Bean categories, the XML for Panel Beans can contain the most information. In addition to the previously mentioned elements, Panel Bean entries may have two optional elements: <sgmltag>&lt;tree&gt;</sgmltag> and <sgmltag>&lt;icon&gt;</sgmltag>. The element <sgmltag>&lt;tree&gt;</sgmltag> specifies the path within the Bean tree hierarchy where the Panel Bean will be placed. The path is given as a /-separated list of directories. If the named path does not exist when the Bean is loaded, it will be created. The element <sgmltag>&lt;icon&gt;</sgmltag> names a custom icon for the Bean and a tool-tip. An example of a Panel Bean XML entry is shown in <xref linkend="PlexusGraphView.xml.example"/>. Note that this is not the full file--it is only the <sgmltag>&lt;guipanel&gt;</sgmltag> element for a single Bean.</para>
            <example id="PlexusGraphView.xml.example">
               <title>PlexusGraphView.xml snippet</title>
               <programlisting>&lt;guipanel name="Graph View"&gt;
  &lt;file name="${PLX_BASE_DIR}/bin/beans/PlexusGraphView.jar" 
        class="plx.graphview.GraphView" /&gt;
  &lt;tree path="/" /&gt;
  &lt;dependency file="openjgraph.jar" path="${PLX_BASE_DIR}/bin" /&gt;
  &lt;dependency file="jgraph.jar" path="${PLX_BASE_DIR}/bin" /&gt;
  &lt;dependency file="PlexusComm.jar" path="${PLX_BASE_DIR}/bin" /&gt;
  &lt;icon source="jar:file:${PLX_BASE_DIR}/bin/beans/PlexusGraphView.jar!/plx/graphview/icon.gif"
        tooltip="Plexus Network Graph Visualization" /&gt;
&lt;/guipanel&gt;</programlisting>
            </example>
            <para>This shows the use of all the elements that may be children of <sgmltag>&lt;guipanel&gt;</sgmltag>. Note that the <literal>source</literal> attribute of <sgmltag>&lt;icon&gt;</sgmltag> gets its icon image using a JAR URL.</para>
            <para>Another example XML file is shown in <xref linkend="Viewers.xml.example"/>. This is the actual file used to load the two Viewer Beans that come with the Tweek distribution. This is a complete file containing two Viewer Bean entries.</para>
            <example id="Viewers.xml.example">
               <title>Viewers.xml</title>
               <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beanlist xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:noNamespaceSchemaLocation="http://www.vrjuggler.org/tweek/xsd/1.0/beanlist.xsd"&gt;
  &lt;viewer name="Tree Viewer"&gt;
    &lt;file name="${TWEEK_BASE_DIR}/bin/beans/Viewers.jar" 
          class="org.vrjuggler.tweek.treeviewer.BeanTreeViewer" /&gt;
  &lt;/viewer&gt;
  &lt;viewer name="Icon Viewer"&gt;
    &lt;file name="${TWEEK_BASE_DIR}/bin/beans/Viewers.jar" 
          class="org.vrjuggler.tweek.iconviewer.BeanIconViewer" /&gt;
  &lt;/viewer&gt;
&lt;/beanlist&gt;</programlisting>
            </example>
         </section>
      </chapter>
   </part>
   <part>
      <title>Programming</title>
      <chapter>
         <title>Programming Basics</title>
         <para>In the following chapters, we present the basic information needed to start programming with Tweek. There will be discussion covering IDL, C++, Java, and CORBA. To use Tweek effectively, a good understanding of C++ and Java is required. The IDL aspect of Tweek is minimal, and programmers familiar with basic object-oriented concepts should be able to understand IDL code easily. Discussion related to CORBA is based on the brief introduction given in <xref linkend="intro.corba.section"/>. The Tweek Java and C++ APIs are designed to hide most CORBA details. Whenever possible, references are given to good sources of information on all of the aforementioned topics.</para>
         <para>Before proceeding, it is important to know that Tweek is designed and implemented to work with VR Juggler 1.1 and 2.0. It can be used with VR Juggler 1.0, but there have been reports of conflicts occurring between VR Juggler 1.0 and the VR Juggler Portable Runtime (VPR) that is part of VR Juggler 1.1. The Tweek C++ code uses VPR for threading, but it is possible to replace the VPR objects with VR Juggler 1.0 thread objects.</para>
      </chapter>
      <chapter id="prog.idl.chapter">
         <title>IDL</title>
         <para>In this chapter, we present the basic information needed to define interfaces that will be used by Tweek. This is not a detailed introduction to IDL programming. Readers are referred to <xref linkend="Hen99"/>.</para>
         <para>IDL <quote>programming</quote> means defining <glossterm linkend="gloss.interface">interfaces</glossterm>. In the scope of Tweek and CORBA, the interfaces declare what operations may be performed on CORBA references. The arguments and return values may be of several basic types including, but not limited to, <type>string</type>, <type>int</type>, <type>long</type>, and <type>float</type>. These types are specified in a language-independent manner. When the IDL compiler generates the code for a specific language, the language-specific types that correspond to the IDL types are used.</para>
         <para>In <xref linkend="Subject.idl.example"/>, we show the Tweek <interfacename>Subject</interfacename><indexterm>
               <primary>interfaces</primary>
               <secondary>tweek::Subject</secondary>
            </indexterm> interface. Note the similarity to a C++ header file. The IDL file can be included by other IDL files, and thus it must <quote>protect</quote> the contents in the same manner as a header file. The actual <interfacename>Subject</interfacename> interface is defined within the <literal>tweek</literal> module. An IDL module corresponds to a C++ namespace or to a Java package. The interface itself has three methods: <methodname>attach()</methodname>, <methodname>detach()</methodname>, and <methodname>notify()</methodname>. The first two take a read-only argument of type <interfacename>Observer</interfacename>. The fact that the argument is read-only (to the server) is specified by the <literal>in</literal> modifier. Other modifiers are <literal>out</literal> (sent from server to client) and <literal>inout</literal> (initialized by the client, writable by the server). The third method, <methodname>notify()</methodname>, takes no arguments, and none of the methods have a return type.</para>
         <example id="Subject.idl.example">
            <title>Subject.idl</title>
            <indexterm>
               <primary>tweek::Subject</primary>
               <secondary>IDL definition</secondary>
            </indexterm>
            <programlisting>#ifndef _TWEEK_SUBJECT_IDL_
#define _TWEEK_SUBJECT_IDL_

#include &lt;tweek/idl/Observer.idl&gt;


module tweek
{

interface Subject
{
   void attach(in Observer o);
   void detach(in Observer o);
   void notify();
};

};

#endif</programlisting>
         </example>
         <para>By definition, all objects are passed by reference in CORBA. The modifier stating the readability and/or writability in the IDL file determines how the referenced object may be modified, if at all, within the method.</para>
      </chapter>
      <chapter id="prog.cplusplus.chapter">
         <title>C++</title>
         <para></para>
         <section>
            <title>Deriving from <classname>tweek::SubjectImpl</classname></title>
            <para></para>
         </section>
         <section>
            <title>Using the CORBA Manager</title>
            <para></para>
         </section>
         <section>
            <title>Using the Subject Manager</title>
            <para></para>
         </section>
      </chapter>
      <chapter id="prog.java.chapter">
         <title>Java</title>
         <para></para>
         <section>
            <title>Java Libraries</title>
            <para>The Tweek Java API is broken up into a collection of Java class libraries, each packaged in a unique JAR file. Programmers can choose the library or libraries they need when writing Java code that uses Tweek. It is possible to write JavaBeans that do not use any of the Tweek Java libraries, but such Beans may not be very full-featured. On the other hand, because the Tweek Java GUI is capable of loading any JavaBean, there is no reason that a fully functional Bean must be written to take advantage of Tweek services and utilities.</para>
            <section id="bean.library.section">
               <title>Bean Library</title>
               <indexterm>
                  <primary>Java libraries</primary>
                  <secondary>Bean</secondary>
               </indexterm>
               <para></para>
            </section>
            <section id="event.library.section">
               <title>Event Library</title>
               <indexterm>
                  <primary>Java libraries</primary>
                  <secondary>Event</secondary>
               </indexterm>
               <para></para>
            </section>
            <section id="gui.library.section">
               <title>GUI Library</title>
               <indexterm>
                  <primary>Java libraries</primary>
                  <secondary>GUI</secondary>
               </indexterm>
               <para></para>
            </section>
            <section id="network.library.section">
               <title>Network Library</title>
               <indexterm>
                  <primary>Java libraries</primary>
                  <secondary>Network</secondary>
               </indexterm>
               <para></para>
            </section>
         </section>
      </chapter>
      <chapter id="prog.all.chapter">
         <title>Putting It All Together</title>
         <para>Based on the information presented in the previous chapters, we can combine everything into an examples. In this chapter, we present the step-by-step process for using the Tweek Java and C++ APIs.</para>
         <section id="collab.slider.section">
            <title>Collaborative Slider</title>
            <para>In this example, we explain how to develop a simple Tweek interface. The goal is to have a <quote>collaborative</quote> slider in a Java GUI component. The value displayed by the slider is retained by a C++ application so that multiple independent sliders can show the same value. The steps explained here are highly representative of the normal steps to be followed when using the Tweek Java and C++ APIs. The structure of the following sections lays out the order of the steps taken. An example makefile that goes along with the code presented can be found in <xref linkend="SliderSubject.makefile.section"/> of <xref linkend="makefile.appendix"/>. The full source for the examples presented in this section can be found in <filename>$TWEEK_BASE_DIR/share/test/NetworkTestBean</filename>.</para>
            <section>
               <title>The Subject</title>
               <para>To begin, the subject interface must be defined in IDL and implemented in C++. The interface itself will be <quote>compiled</quote> into Java and C++ code. Both ends of the communication channels must know the interface in order for the references to be used, thus requiring the generation of code for both languages.</para>
               <section>
                  <title>Creating the Interface</title>
                  <para>Creating an IDL interface involves writing an IDL file. For this example, we will be storing an integer variable in a C++ servant. The Java GUIs will need to read and write the value, so we need two methods: <methodname>getValue()</methodname> and <methodname>setValue()</methodname>. The type being passed between <glossterm linkend="gloss.orb">ORBs</glossterm> will be <type>long</type>, a 32-bit integer. Depending on the target language, this will map to the corresponding type of the same size.</para>
                  <example id="SliderSubject.idl.example">
                     <title>SliderSubject.idl</title>
                     <programlistingco>
                        <areaspec>
                           <areaset coords="" id="cpp.protection">
                              <area coords="1" id="cpp.ifndef.line"/>
                              <area coords="2" id="cpp.define.line"/>
                              <area coords="13" id="cpp.endif.line"/>
                           </areaset>
                           <area coords="4" id="tweek.subject.idl.include"/>
                           <area coords="6" id="idl.module.block"/>
                           <area coords="8" id="idl.interface.decl"/>
                           <areaset coords="" id="SliderSubject.methods">
                              <area coords="10" id="SliderSubject.setValue.decl"/>
                              <area coords="11" id="SliderSubject.getValue.decl"/>
                           </areaset>
                        </areaspec>
                        <programlisting linenumbering="numbered">#ifndef _NETWORK_TEST_SLIDER_SUBJECT_IDL_
#define _NETWORK_TEST_SLIDER_SUBJECT_IDL_

#include &lt;tweek/idl/Subject.idl&gt;

module networktest
{
   interface SliderSubject : tweek::Subject
   {
      void setValue(in long val);
      long getValue();
   };
};

#endif</programlisting>
                        <calloutlist>
                           <callout arearefs="cpp.protection">
                              <para>IDL files are run through the C preprocessor so that they may include external files. To prevent including the same source multiple times, the file must be enclosed in the traditional preprocessor protection block. This is exactly what is done in C/C++ header files.</para>
                           </callout>
                           <callout arearefs="tweek.subject.idl.include">
                              <para>All Tweek subject IDL files must include <filename>tweek/idl/Subject.idl</filename>. This is required so that the interface being defined can inherit from <interfacename>tweek::Subject</interfacename>.</para>
                           </callout>
                           <callout arearefs="idl.module.block">
                              <para>Typically, using a module to contain the interface is recommended. Using a module defines a Java package and a C++ namespace (named <literal>networktest</literal> in this case).</para>
                           </callout>
                           <callout arearefs="idl.interface.decl">
                              <para>The definition of the subject interface must inherit from <interfacename>tweek::Subject</interfacename>. If this is not done, there is no way that the subject interface will plug into the Subject Manager.</para>
                           </callout>
                           <callout arearefs="SliderSubject.methods">
                              <para>This simple interface has only two functions: <methodname>setValue()</methodname> and <methodname>getValue()</methodname>. The method getValue() takes a single read-only parameter of type <type>long</type>; <methodname>getValue()</methodname> returns a value of the same type.</para>
                           </callout>
                        </calloutlist>
                     </programlistingco>
                  </example>
                  <para>The file <filename>SliderSubject.idl</filename> must be <quote>compiled</quote> by an <glossterm linkend="gloss.idl-compiler">IDL compiler</glossterm>. For use with Tweek, the interface must be compiled into Java and C++ code. The generated Java code will be used solely for communicating with CORBA <interfacename>networktest.SliderSubject</interfacename> references. The generated C++ code will be extended to provide an implementation of the <interfacename>networktest::SliderSubject</interfacename> interface. (The implementation will be a CORBA <glossterm linkend="gloss.servant">servant</glossterm> object to which references will be made by remote Java code.)</para>
               </section>
               <section>
                  <title>Implementing the Interface in C++</title>
                  <para>After running an IDL compiler to generate the stub CORBA code, the interface must be implemented. In particular, there will be pure virtual methods in <filename>SliderSubject.h</filename> that must be implemented. The implementing class will be the CORBA <glossterm linkend="gloss.servant">servant</glossterm> holding the actual data visualized in the Java GUI slider.</para>
                  <example id="SliderSubjectImpl.h.example">
                     <title>SliderSubjectImpl.h</title>
                     <programlistingco>
                        <areaspec>
                           <areaset coords="" id="SliderSubjectImpl.h.includes">
                              <area coords="8 68" id="SliderSubjectImpl.h.includes.subjimpl"/>
                              <area coords="9 68" id="SliderSubjectImpl.h.includes.obs"/>
                           </areaset>
                           <area coords="10 68" id="SliderSubjectImpl.h.include.subj"/>
                           <area coords="13 68" id="SliderSubjectImpl.h.namespace"/>
                           <area coords="21 68" id="SliderSubjectImpl.h.class.decl"/>
                           <areaset coords="" id="SliderSubjectImpl.h.virtuals">
                              <area coords="39 68" id="SliderSubjectImpl.h.setValue"/>
                              <area coords="44 68" id="SliderSubjectImpl.h.getValue"/>
                           </areaset>
                           <area coords="53 68" id="SliderSubjectImpl.h.hack"/>
                           <area coords="59 68" id="SliderSubjectImpl.h.mValue"/>
                        </areaspec>
                        <programlisting linenumbering="numbered">#ifndef _SLIDER_SUBJECT_IMPL_H_
#define _SLIDER_SUBJECT_IMPL_H_

#include &lt;tweek/tweekConfig.h&gt;

#include &lt;vector&gt;

#include &lt;tweek/CORBA/SubjectImpl.h&gt;
#include &lt;tweek/CORBA/Observer.h&gt;
#include &lt;SliderSubject.h&gt;


namespace networktest
{

/**
 * This class is an extension to the base Tweek SubjectImpl class.  It uses
 * multiple inheritance with that class and with the generated CORBA class
 * corresponding to the IDL for SliderSubject.
 */
class SliderSubjectImpl : public POA_networktest::SliderSubject,
                          public tweek::SubjectImpl
{
public:
   SliderSubjectImpl()
      : tweek::SubjectImpl(), mValue(0)
   {
      /* Do nothing. */ ;
   }

   virtual ~SliderSubjectImpl()
   {
      /* Do nothing. */ ;
   }

   /**
    * Sets this subject's internal value.
    */
   virtual void setValue(long value);

   /**
    * Returns this subject's internal value.
    */
   virtual long getValue();

   /**
    * This overriding method is needed so that the correct type is returned
    * when the _this() method is invoked.  Without this method, an object of
    * type tweek::Subject_ptr would be returned.
    *
    * XXX: It may be possible to remove this requirement in the future.
    */
   networktest::SliderSubject_ptr _this()
   {
      return POA_networktest::SliderSubject::_this();
   }

private:
   long mValue;   /**&lt; Our value */
};

} // End of networktest namespace


#endif /* _SLIDER_SUBJECT_IMPL_H_ */</programlisting>
                        <calloutlist>
                           <callout arearefs="SliderSubjectImpl.h.includes">
                              <para>These files will always be included by implementations of Tweek subject derived classes. The first contains the declaration for the basic Tweek subject implementation. The second contains the C++ code generated from the Tweek <filename>Observer.idl</filename> file.</para>
                           </callout>
                           <callout arearefs="SliderSubjectImpl.h.include.subj">
                              <para>This header is generated by the IDL compiler from <filename>SliderSubject.idl</filename>. In particular, it defines the class from which <classname>networktest::SliderSubjectImpl</classname> must inherit.</para>
                           </callout>
                           <callout arearefs="SliderSubjectImpl.h.namespace">
                              <para>In <filename>SliderSubject.idl</filename>, shown in <xref linkend="SliderSubject.idl.example"/>, the interface is in the <literal>networktest</literal> module. In the C++ implementation code, the module name corresponds to a namespace.</para>
                           </callout>
                           <callout arearefs="SliderSubjectImpl.h.class.decl">
                              <para>The interface implementation class must inherit from the IDL-generated class <classname>POA_networktest::SliderSubject</classname> and from <classname>tweek::SubjectImpl</classname>.</para>
                           </callout>
                           <callout arearefs="SliderSubjectImpl.h.virtuals">
                              <para><classname>POA_networktest::SliderSubject</classname> defines two pure virtual methods that must be implemented. These correspond to the methods in <filename>SliderSubject.idl</filename>.</para>
                           </callout>
                           <callout arearefs="SliderSubjectImpl.h.hack">
                              <para>As of this writing, all subject implementations must contain an overriding version of the <methodname>_this()</methodname> method. This is due to the use of multiple inheritance. Note the return type and the <literal>return</literal> statement. These will vary for each subject implementation based on the name of the IDL-defined interface.</para>
                           </callout>
                           <callout arearefs="SliderSubjectImpl.h.mValue">
                              <para>This is the actual value being stored by the C++ servant.</para>
                           </callout>
                        </calloutlist>
                     </programlistingco>
                  </example>
                  <para>In <filename>SliderSubjectImpl.h</filename>, the most important parts to note are the use of multiple inheritance, the declarations of the <interfacename>SliderSubject</interfacename> interface methods, and the implementation of <methodname>_this()</methodname>. The implementations of <methodname>setValue()</methodname> and <methodname>getValue()</methodname> are shown next in <xref linkend="SliderSubjectImpl.cpp.example"/>.</para>
                  <example id="SliderSubjectImpl.cpp.example">
                     <title>SliderSubjectImpl.cpp</title>
                     <programlistingco>
                        <areaspec>
                           <area coords="2" id="SliderSubjectImpl.cpp.inc"/>
                           <area coords="10" id="SliderSubjectImpl.cpp.mValue.assign"/>
                           <area coords="14" id="SliderSubjectImpl.cpp.notify"/>
                           <area coords="19" id="SliderSubjectImpl.cpp.mValue.return"/>
                        </areaspec>
                        <programlisting linenumbering="numbered">#include &lt;vpr/Util/Debug.h&gt;
#include &lt;SliderSubjectImpl.h&gt;


namespace networktest
{

void SliderSubjectImpl::setValue(long value)
{
   mValue = value;

   // Notify any observers that our value has changed.  This is very
   // important.
   tweek::SubjectImpl::notify();
}

long SliderSubjectImpl::getValue()
{
   return mValue;
}

} // End networktest namespace</programlisting>
                        <calloutlist>
                           <callout arearefs="SliderSubjectImpl.cpp.inc">
                              <para>Include the class declaration file, shown in <xref linkend="SliderSubjectImpl.h.example"/>.</para>
                           </callout>
                           <callout arearefs="SliderSubjectImpl.cpp.mValue.assign">
                              <para>When invoked, the remote caller will pass a <type>long</type> value, and this saves the result into the servant's storage.</para>
                           </callout>
                           <callout arearefs="SliderSubjectImpl.cpp.notify">
                              <para>Because the subject's state has been modified, all attached observers must be notified. This is a very important step that must be taken in this method. Note that it invokes the <methodname>notify()</methodname> method of the parent class.</para>
                           </callout>
                           <callout arearefs="SliderSubjectImpl.cpp.mValue.return">
                              <para>Observers will invoke this method when requesting the current <varname>mValue</varname>.</para>
                           </callout>
                        </calloutlist>
                     </programlistingco>
                  </example>
               </section>
            </section>
            <section>
               <title>The Observer</title>
               <para>The observer does not define its own specialized IDL interface. Instead, it makes use of the existing Tweek basic observer (<classname>tweek.ObserverPOA</classname><indexterm>
                     <primary>classes</primary>
                     <secondary>tweek.ObserverPOA</secondary>
                  </indexterm> in Java). The method <methodname>update()</methodname> must be implemented. The remainder of the observer implementation is centered around communication with a <interfacename>SliderSubject</interfacename> object reference. All observer code is written in Java. The only C++ code for observers is part of the Tweek library, and it is generated entirely by the <glossterm linkend="gloss.idl-compiler">IDL compiler</glossterm>.</para>
               <section>
                  <title>Implementing the Observer in Java</title>
                  <para>For every subject interface defined in IDL, a corresponding observer class must be written in Java. Without an observer, there is no way for the Java and C++ sides to conduct useful two-way communication. At best, the Java GUI could request a subject reference and manipulate the C++ application through the reference, but the communication would be entirely one-way.</para>
                  <para>In <xref linkend="SliderObserverImpl.java.example"/>, we show the complete Java implementation of an observer corresponding to the <interfacename>tweek::SliderSubject</interfacename> interface defined earlier. (The JavaBean that uses this observer is explained in <xref linkend="slider.subject.bean.section"/>.) The main focus of this observer is to update its contained <classname>JSlider</classname> whenever the state of the corresponding subject changes.</para>
                  <example id="SliderObserverImpl.java.example">
                     <title>SliderObserverImpl.java</title>
                     <programlistingco>
                        <areaspec>
                           <area coords="14 70" id="SliderObserverImpl.java.class.decl"/>
                           <area coords="16 70" id="SliderObserverImpl.java.constructor"/>
                           <area coords="26 70" id="SliderObserverImpl.java.update"/>
                           <area coords="34 70" id="SliderObserverImpl.java.getValue"/>
                           <area coords="45 70" id="SliderObserverImpl.java.detach"/>
                        </areaspec>
                        <programlisting linenumbering="numbered">package networktest;

import javax.swing.DefaultBoundedRangeModel;
import javax.swing.JSlider;
import tweek.*;


/**
 * Implementation of the Observer side of the Tweek Subject/Observer pattern.
 * It must extend tweek.ObserverPOA so that instances of this class can be
 * registered as CORBA servants.  In addition, CORBA references to the
 * servants must be capable of being attached to remote subjects.
 */
public class SliderObserverImpl extends ObserverPOA
{
   public SliderObserverImpl(JSlider slider, SliderSubject subject)
   {
      mSlider        = slider;
      mSliderSubject = subject;
   }

   /**
    * Implements the required method in tweek.ObserverPOA.  The remote subject
    * will invoke this method whenever it is notified of a change.
    */
   public void update()
   {
      // If we have a valid slider object, we need to update its value to
      // whatever our subject has.
      if ( mSlider != null )
      {
         DefaultBoundedRangeModel model =
            (DefaultBoundedRangeModel) mSlider.getModel();
         model.setValue(mSliderSubject.getValue());
         mSlider.repaint();
      }
   }

   /**
    * Detaches this observer from our subject.  This is needed when shutting
    * down a CORBA connection.
    */
   public void detach()
   {
      mSliderSubject.detach(this._this());
   }

   private SliderSubject mSliderSubject = null;
   private JSlider       mSlider        = null;
}</programlisting>
                        <calloutlist>
                           <callout arearefs="SliderObserverImpl.java.class.decl">
                              <para>As an observer, this class must derive from <classname>tweek.ObserverPOA</classname>. This class is generated by the IDL compiler and is part of the Tweek Network Library (see <xref linkend="network.library.section"/>).</para>
                           </callout>
                           <callout arearefs="SliderObserverImpl.java.constructor">
                              <para>The constructor for this observer takes two arguments: a <classname>JSlider</classname> object reference and a <interfacename>networktest.SliderSubject</interfacename> object reference. The observer needs the latter argument so that it can query state information from the subject when notified of state changes. This is part of the subject/observer design pattern <xref linkend="Gam95"/>.</para>
                           </callout>
                           <callout arearefs="SliderObserverImpl.java.update">
                              <para>As stated, all observers must implement <methodname>update()</methodname>. This will be invoked by the remote subject when its <methodname>notify()</methodname> method is invoked.</para>
                           </callout>
                           <callout arearefs="SliderObserverImpl.java.getValue">
                              <para>To get the updated state of the remote subject, the encapsulated subject reference's <methodname>getValue()</methodname> method is invoked. The value returned will be the most up-to-date information from the subject.</para>
                           </callout>
                           <callout arearefs="SliderObserverImpl.java.detach">
                              <para>It may be convenient for the observer to implement a <methodname>detach()</methodname> method (though the name may vary). This is used when the Java application is shutting down to ensure that the remote subject does not have dangling references to observers that no longer exist. The only action required here is invoking the subject's <methodname>detach()</methodname> method to inform the subject that this observer is going away.</para>
                           </callout>
                        </calloutlist>
                     </programlistingco>
                  </example>
                  <para>This example demonstrates that observers do not have to be complex to be usable. While this example is purposely simple, it should illustrate that developers of observers do not necessarily have to make their implementations complicated. As will be shown in <xref linkend="slider.subject.bean.section"/>, the JavaBean that uses this observer completes the picture and provides users with a GUI slider that can be manipulated by any number of simultaneous users.</para>
               </section>
            </section>
            <section>
               <title>The Application</title>
               <para>Now that we have the subject and observer ready to go, we can make an application that uses them. The following example is a (relatively) simple C++ application that starts the CORBA Manager<indexterm>
                     <primary>CORBA Manager</primary>
                     <secondary>initialization</secondary>
                     <tertiary>example of</tertiary>
                  </indexterm>, creates the Subject Manager<indexterm>
                     <primary>Subject Manager</primary>
                     <secondary>creation</secondary>
                     <tertiary>example of</tertiary>
                  </indexterm>, registers a <interfacename>networktest::SliderSubject</interfacename> servant, and then waits for the user to press '<literal>x</literal>' to exit. The use of exceptions may appear unfamiliar to some C++ programmers. CORBA makes use of exceptions as a cross-language mechanism to report errors, and thus, there must be proper exception handling code for the application to work correctly.</para>
               <example id="SliderSubjectApp.cpp.example">
                  <title>SliderSubjectApp.cpp</title>
                  <programlistingco>
                     <areaspec>
                        <areaset coords="" id="SliderSubjectApp.cpp.includes">
                           <area coords="1 78" id="SliderSubjectApp.cpp.includes.tweek"/>
                           <area coords="5 78" id="SliderSubjectApp.cpp.includes.gen"/>
                        </areaset>
                        <areaset coords="" id="SliderSubjectApp.cpp.corbamgr">
                           <area coords="13 78" id="SliderSubjectApp.cpp.corbamgr.decl"/>
                           <area coords="19 78" id="SliderSubjectApp.cpp.corbamgr.init"/>
                        </areaset>
                        <area coords="27 78" id="SliderSubjectApp.cpp.subjectmgr.create"/>
                        <area coords="36 78" id="SliderSubjectApp.cpp.subject.create"/>
                        <area coords="43 78" id="SliderSubjectApp.cpp.subject.register"/>
                        <area coords="70 78" id="SliderSubjectApp.cpp.loop"/>
                     </areaspec>
                     <programlisting linenumbering="numbered">#include &lt;tweek/CORBA/CorbaManager.h&gt;
#include &lt;vpr/Thread/Thread.h&gt;
#include &lt;vpr/Util/Debug.h&gt;

#include &lt;SliderSubjectImpl.h&gt;


/**
 * This application starts the CORBA server for the C++ side of the test.
 */
int main(int argc, char* argv[])
{
   tweek::CorbaManager mgr;

   // The first thing we have to do is initialize the Tweek CORBA Manager.
   // If this fails, we're out of luck.
   try
   {
      if ( mgr.init("corba_test", argc, argv).success() )
      {
         vpr::ReturnStatus status;

         // Once the CORBA Manager is initialized, we need to create a
         // Subject Manager.  This will hold our SliderSubject object.
         try
         {
            status = mgr.createSubjectManager();

            // If we were able to create the Subject Manager, now we register
            // our objects with it.
            if ( status.success() )
            {
               // First, create real instances of the C++ object that will
               // be the CORBA servant.  This must be allocated on the heap.
               networktest::SliderSubjectImpl* slider_subj =
                  new networktest::SliderSubjectImpl();

               // Now we try to register the subject and give it a symbolic,
               // easy-to-remember name.
               try
               {
                  mgr.getSubjectManager()-&gt;registerSubject(slider_subj,
                                                           "SliderSubject");
               }
               catch (...)
               {
                  vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
                     &lt;&lt; "Failed to register subject\n" &lt;&lt; vprDEBUG_FLUSH;
               }
            }
         }
         catch (CORBA::Exception&amp; ex)
         {
            vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
               &lt;&lt; "Caught an unknown CORBA exception when trying to register!\n"
               &lt;&lt; vprDEBUG_FLUSH;
         }

         if ( ! status.success() )
         {
            vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
               &lt;&lt; "Failed to register Subject Manager instance\n"
               &lt;&lt; vprDEBUG_FLUSH;
         }

         std::cout &lt;&lt; "Press 'x' to exit" &lt;&lt; std::endl;
         char input;

         // Loop forever so that we can act sort of like a server.
         while ( 1 )
         {
            std::cin &gt;&gt; input;
            if ( input == 'x' )
            {
               break;
            }
            else
            {
               vpr::Thread::msleep(100);
            }
         }
      }
      else
      {
         vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
            &lt;&lt; "CORBA failed to initialize\n" &lt;&lt; vprDEBUG_FLUSH;
      }
   }
   catch (...)
   {
      vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
         &lt;&lt; "Caught an unknown exception!\n" &lt;&lt; vprDEBUG_FLUSH;
   }

   vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL) &lt;&lt; "Exiting\n" &lt;&lt; vprDEBUG_FLUSH;

   return 0;
}</programlisting>
                     <calloutlist>
                        <callout arearefs="SliderSubjectApp.cpp.includes">
                           <para>These two headers are typically needed. The first includes the declaration of the Tweek CORBA Manager, and the second is the subject implementation declaration, shown in <xref linkend="SliderSubjectImpl.h.example"/>.</para>
                        </callout>
                        <callout arearefs="SliderSubjectApp.cpp.corbamgr">
                           <para>In order to use CORBA through Tweek, the CORBA Manager must be created and initialized. Any number of these may be created, but in general, only one is needed per application</para>
                        </callout>
                        <callout arearefs="SliderSubjectApp.cpp.subjectmgr.create">
                           <para>After the COBRA Manager has been initialized successfully, the Tweek Subject Manager must be created.</para>
                        </callout>
                        <callout arearefs="SliderSubjectApp.cpp.subject.create">
                           <para>Once we have a valid Subject Manager, we must register subjects with it in order for object references to be passed out by CORBA. This creates the <glossterm linkend="gloss.servant">servant</glossterm> to which <interfacename>networktest::SliderSubject</interfacename> references will be made.</para>
                        </callout>
                        <callout arearefs="SliderSubjectApp.cpp.subject.register">
                           <para>Once the servant is created, it is registered with the Subject Manager. The Subject Manager will activate the servant within the POA so that references to it can be created and returned to clients.</para>
                        </callout>
                        <callout arearefs="SliderSubjectApp.cpp.loop">
                           <para>After the subject is registered, all the work is done. This application now just waits for clients to request references. It will exit when the user enters '<literal>x</literal>'.</para>
                        </callout>
                     </calloutlist>
                  </programlistingco>
               </example>
               <para>The application shown in <xref linkend="SliderSubjectApp.cpp.example"/> is purposely simple. There are many ways to use the CORBA Manager and the Subject Manager. For example, an object registry could be built on top of the Subject Manager so that only specific types of servant objects may be registered. Servant registration could be automated in object constructors. The C++ API is intended to be simple to enhance its usability and flexibility, and the application shown in the example is just that: an example.</para>
            </section>
            <section id="slider.subject.bean.section">
               <title>The JavaBean</title>
               <para>We have finally reached the point at which we implement a JavaBean that can visualize the numeric data held by the C++ slider subject. Such a JavaBean must be defined as a Tweek Panel Bean. (Refer back to <xref linkend="intro.javabeans.chapter"/> if these statements seem unfamiliar or confusing.)</para>
               <para>The JavaBean shown in the following example is typical of one that uses the Tweek Network library to take advantage of CORBA facilities. The code for the Bean is longer than previous examples, and because of this, it will be split into multiple code blocks. Each will be discussed in turn. The full code is in one file: <filename>NetworkTest.java</filename>.</para>
               <para>Please note that the details of setting up the GUI elements used by the Bean are left out. The code in this case was generated by JBuilder and could easily vary from Bean to Bean. For the full code, please refer to the aforementioned locations.</para>
               <section>
                  <title>Imports</title>
                  <para>The slider JavaBean uses common Java Swing classes, a CORBA exception class, the Tweek Event library, the Tweek Network library, and the Java code generated by an IDL compiler. The following explains how each of these are imported into the main Bean class.</para>
                  <programlistingco>
                     <areaspec>
                        <area coords="1" id="NetworkTest.java.package"/>
                        <areaset coords="" id="NetworkTest.java.imports.gui">
                           <area coords="3" id="NetworkTest.java.imports.gui.awt"/>
                           <area coords="4" id="NetworkTest.java.imports.gui.swing"/>
                           <area coords="5" id="NetworkTest.java.imports.gui.swing.events"/>
                        </areaset>
                        <area coords="6" id="NetworkTest.java.imports.corba"/>
                        <areaset coords="" id="NetworkTest.java.imports.tweek">
                           <area coords="7" id="NetworkTest.java.imports.tweek.event"/>
                           <area coords="8" id="NetworkTest.java.imports.tweek.net"/>
                           <area coords="9" id="NetworkTest.java.imports.tweek.net.corba"/>
                        </areaset>
                        <area coords="10" id="NetworkTest.java.imports.tweek-gen"/>
                     </areaspec>
                     <programlisting>package networktest;

import java.awt.*;
import javax.swing.*;
import javax.swing.event.*;
import org.omg.CORBA.BAD_PARAM;
import org.vrjuggler.tweek.event.*;
import org.vrjuggler.tweek.net.*;
import org.vrjuggler.tweek.net.corba.*;
import tweek.*;
</programlisting>
                     <calloutlist>
                        <callout arearefs="NetworkTest.java.package">
                           <para>This Bean is in a package corresponding to the IDL module defined in <filename>SliderSubject.idl</filename>. Using a consistent name throughout makes the code easier to manage and understand.</para>
                        </callout>
                        <callout arearefs="NetworkTest.java.imports.gui">
                           <para>These imports bring in common Swing and AWT GUI classes. Different Beans will use different classes and packages.</para>
                        </callout>
                        <callout arearefs="NetworkTest.java.imports.corba">
                           <para>In order to do proper narrowing of reference types, the exception <exceptionname>org.omg.CORBA.BAD_PARAM</exceptionname> must be caught.</para>
                        </callout>
                        <callout arearefs="NetworkTest.java.imports.tweek">
                           <para>These imports bring in the classes of the Tweek Event and Network libraries.</para>
                        </callout>
                        <callout arearefs="NetworkTest.java.imports.tweek-gen">
                           <para>Tweek Java code generated by an IDL compiler will always be in the package <classname>tweek</classname>. This corresponds to the IDL module and to the C++ namespace.</para>
                        </callout>
                     </calloutlist>
                  </programlistingco>
               </section>
               <section>
                  <title>Class Declaration</title>
                  <para>Now we can begin writing the Bean code. Besides the class <classname>SliderObserverImpl</classname>, this Bean has only one class: <classname>NetworkTest</classname>. It will provide the GUI representation of the numeric data. The declaration of the class follows.</para>
                  <programlistingco>
                     <areaspec>
                        <area coords="9" id="NetworkTest.java.superclass"/>
                        <area coords="10" id="NetworkTest.java.interfaces"/>
                     </areaspec>
                     <programlisting>/**
 * This is an example of a JavaBean that Tweek can load dynamically.  It holds
 * a JSlider that acts as an Observer in the Tweek CORBA Subject/Observer
 * pattern implementation.
 *
 * @version 1.0
 */
public class NetworkTest
   extends JPanel
   implements CommunicationListener, TweekFrameListener
{
...
}</programlisting>
                     <calloutlist>
                        <callout arearefs="NetworkTest.java.superclass">
                           <para>As a Tweek Panel Bean, there must be a class that derives from <classname>javax.swing.JComponent</classname> or some subclass thereof. In this case, the superclass is <classname>javax.swing.JPanel</classname>.</para>
                        </callout>
                        <callout arearefs="NetworkTest.java.interfaces">
                           <para>Since this Bean needs to access the remote Subject Manager, it needs to know when a CORBA service is available. By implementing <interfacename>org.vrjuggler.tweek.net.CommunicationListener</interfacename>, the Bean will be informed by the Tweek Java GUI whenever the communication state with a CORBA service changes. This Bean also listens for <classname>TweekFrameEvents</classname> so that it can shut itself down cleanly. To be informed of such events, it must implement <interfacename>org.vrjuggler.tweek.event.TweekFrameListener</interfacename>.</para>
                        </callout>
                     </calloutlist>
                  </programlistingco>
               </section>
               <section>
                  <title>Member Variables</title>
                  <para>Before delving into the methods of the <classname>networktest.NetworkTest</classname> class, it will be helpful to review the member variables used throughout the class. Refer back to this section if there is any confusion regarding the use or the type of some member variable in the method implementations.</para>
                  <programlistingco>
                     <areaspec>
                        <area coords="1" id="NetworkTest.java.members.layout"/>
                        <areaset coords="" id="NetworkTest.java.members.slider-group">
                           <area coords="3" id="NetworkTest.java.members.slider-group.panel"/>
                           <area coords="4" id="NetworkTest.java.members.slider-group.slider"/>
                        </areaset>
                        <area coords="6" id="NetworkTest.java.members.observer"/>
                     </areaspec>
                     <programlisting>private BorderLayout mBeanLayout = new BorderLayout();

private JPanel mSliderPanel = new JPanel();
private JSlider mDataSlider = new JSlider();

private SliderObserverImpl mSliderObserver = null;
</programlisting>
                     <calloutlist>
                        <callout arearefs="NetworkTest.java.members.layout">
                           <para>This is the containing layout for the entire Bean.</para>
                        </callout>
                        <callout arearefs="NetworkTest.java.members.slider-group">
                           <para>The <classname>JSlider</classname> used for visually representing the subject's numeric data is <varname>mDataSlider</varname>, and it will be contained within <varname>mSliderPanel</varname>.</para>
                        </callout>
                        <callout arearefs="NetworkTest.java.members.observer">
                           <para>The <interfacename>networktest::SliderSubject</interfacename> observer will be stored within <varname>mSliderObserver</varname>.</para>
                        </callout>
                     </calloutlist>
                  </programlistingco>
                  <para>Note that the observer is stored in a member variable initialized to <symbol>null</symbol>. It will be assigned a value when a CORBA service becomes available and the corresponding subject can be requested. The object itself is stored as a member variable so that it can be accessed by all the methods of the class.</para>
               </section>
               <section>
                  <title>Handling CORBA Communications</title>
                  <para>The most complex part of this Bean is the handling of CORBA communication events delivered by the Tweek GUI. All of the handling in this example will be done in the method <methodname>connectionStateChanged()</methodname>. The steps that must be followed are straightforward, but there are errors that must be handled properly. It is the error handling that can make the code look daunting, not the use of the Tweek Network library.</para>
                  <programlistingco>
                     <areaspec>
                        <areaset coords="" id="NetworkTest.java.corba">
                           <area coords="11 75" id="NetworkTest.java.corba.service"/>
                           <area coords="12 75" id="NetworkTest.java.corba.subjectmgr"/>
                        </areaset>
                        <area coords="14 75" id="NetworkTest.java.getSubject"/>
                        <areaset coords="" id="NetworkTest.java.narrow">
                           <area coords="22 75" id="NetworkTest.java.narrow-subject"/>
                           <area coords="24 75" id="NetworkTest.java.narrow-exception"/>
                        </areaset>
                        <area coords="33 75" id="NetworkTest.java.connect"/>
                        <area coords="41 75" id="NetworkTest.java.observer.create"/>
                        <area coords="42 75" id="NetworkTest.java.observer.register"/>
                        <area coords="47 75" id="NetworkTest.java.observer.attach"/>
                        <area coords="51 75" id="NetworkTest.java.setValue"/>
                        <area coords="54 75" id="NetworkTest.java.addChangeListener"/>
                        <areaset coords="" id="NetworkTest.java.shutdown">
                           <area coords="58 75" id="NetworkTest.java.disconnect"/>
                           <area coords="62 75" id="NetworkTest.java.observer.detach"/>
                        </areaset>
                     </areaspec>
                     <programlisting linenumbering="numbered">/**
 * Implements the Tweek CommunicationListener interface needed for being
 * informed of connections and disconnections with remote CORBA servers.
 */
public void connectionStateChanged(CommunicationEvent e)
{
   // The first thing to do is get the CORBA service object from the
   // event.  We need this so we know to whom we are are connecting.  Once
   // we have the CORBA service, we get its Subject Manager since that's
   // what contains the actual subjects we need.
   CorbaService corba_service = e.getCorbaService();
   SubjectManager mgr         = corba_service.getSubjectManager();

   Subject subject = mgr.getSubject("SliderSubject");
   SliderSubject slider_subject = null;

   // Try to narrow the Subject object to a SliderSubject object.  If this
   // fails, it throws a CORBA BAD_PARAM exception.  In that case, we open
   // a dialog box saying that the narrowing failed.
   try
   {
      slider_subject = SliderSubjectHelper.narrow(subject);
   }
   catch (BAD_PARAM narrow_ex)
   {
      JOptionPane.showMessageDialog(null,
                                    "Failed to narrow subject to SliderSubject",
                                    "SliderSubject Narrow Error",
                                    JOptionPane.ERROR_MESSAGE);
   }

   // Handle a CORBA connection event from Tweek.
   if ( CommunicationEvent.CONNECT == e.getType() )
   {
      // Ensure that slider_subject is a valid object just to be safe.
      if ( slider_subject != null )
      {
         // First, we need a Java object that implements the Observer.  That
         // object must be registered with the Java CORBA service.
         m_slider_observer = new SliderObserverImpl(mDataSlider,
                                                    slider_subject);
         corba_service.registerObject(mSliderObserver, "SliderObserver");

         // Now that the observer is registered, we can attach it to the
         // subject.  The subject needs to know who its observers are so
         // that it can notify them of updates.
         slider_subject.attach(mSliderObserver._this());

         // Now we set the slider in our GUI to be whatever value the
         // remote subject is holding for us.
         mDataSlider.setValue(slider_subject.getValue());
         mDataSlider.addChangeListener(
            new SliderChangeListener(slider_subject)
         );
      }
   }
   // Handle a CORBA disconnect event from Tweek.
   else if ( CommunicationEvent.DISCONNECT == e.getType() )
   {
      if ( slider_subject != null )
      {
         slider_subject.detach(mSliderObserver._this());
      }
   }
}</programlisting>
                     <calloutlist>
                        <callout arearefs="NetworkTest.java.corba">
                           <para>The first step that must be taken is retrieving the <classname>org.vrjuggler.tweek.net.corba.CorbaService</classname> object from the event. This is needed as the basis for all further actions. With the CORBA service reference, we can request the Subject Manager reference. The result is a CORBA reference to the remote Subject Manager, a servant within the C++ application.</para>
                        </callout>
                        <callout arearefs="NetworkTest.java.getSubject">
                           <para>Through the Subject Manager, we request subjects using symbolic names. In this case, we request the subject with the hard-coded name <quote>SliderSbuject</quote>.</para>
                        </callout>
                        <callout arearefs="NetworkTest.java.narrow">
                           <para>The call to <methodname>getSubject()</methodname> returns a reference of type <interfacename>tweek.Subject</interfacename>, but we need to narrow it to <interfacename>networktest.SliderSubject</interfacename> so we can use it. Among the code generated by the IDL compiler is a class named <classname>networktest.SliderSubjectHelper</classname>. Its <methodname>narrow()</methodname> method is used to narrow the CORBA reference type to a more specific type. If the narrowing fails, an exception of type <exceptionname>org.omg.CORBA.BAD_PARAM</exceptionname> is thrown, and it is best to handle it here.</para>
                        </callout>
                        <callout arearefs="NetworkTest.java.connect">
                           <para>If the event delivered to the Bean was of type <constant>org.vrjuggler.tweek.net.CommunicationEvent.CONNECT</constant>, there is a new CORBA service available, so we will create a new observer to communicate through that service.</para>
                        </callout>
                        <callout arearefs="NetworkTest.java.observer.create">
                           <para>Once we have the subject reference, we create an observer servant that we will attach to the subject. This is where <classname>networktest.SliderObserverImpl</classname> comes into the picture.</para>
                        </callout>
                        <callout arearefs="NetworkTest.java.observer.register">
                           <para>The observer servant must be registered with the local CORBA service so that references to it can be created. This single statement takes care of all the POA activation behind the scenes.</para>
                        </callout>
                        <callout arearefs="NetworkTest.java.observer.attach">
                           <para>Now that the servant is registered with the CORBA service, a reference to it can be passed to the remote subject in order to attach the observer to the subject.</para>
                        </callout>
                        <callout arearefs="NetworkTest.java.setValue">
                           <para>Once the initial references are passed around, we need to update the GUI slider to the current value held by the subject.</para>
                        </callout>
                        <callout arearefs="NetworkTest.java.addChangeListener">
                           <para>As part of the collaborative slider, we need to register a change listener with the GUI slider so that it will be informed of changes made by the local user. These changes are reported to the remote subject so that other users get the update. The class <classname>SliderChangeListener</classname> is shown later.</para>
                        </callout>
                        <callout arearefs="NetworkTest.java.shutdown">
                           <para>If the event delivered to the Bean was of type <constant>org.vrjuggler.tweek.net.CommunicationEvent.DISCONNECT</constant>, the CORBA service is being shut down. When the CORBA service is shut down, we need to detach the local observer from the remote subject to prevent further update notification attempts for this observer.</para>
                        </callout>
                     </calloutlist>
                  </programlistingco>
                  <para>It is important to note that the use of hard-coded subject names is not recommended. In this example, the subject name is hard-coded for simplicity. The Tweek Subject Manager allows accessing code to request a list of all registered subjects. Using this information, it is possible to present the Java GUI user with a list of subjects from which they can make a selection.</para>
               </section>
               <section>
                  <title>Handling Frame Events</title>
                  <para>This Bean makes an effort to shut down open CORBA connections when the Tweek GUI is closed. It does this by implementing <interfacename>org.vrjuggler.tweek.event.TweekFrameListener</interfacename> which has a single method, <methodname>frameStateChanged()</methodname>.</para>
                  <programlistingco>
                     <areaspec>
                        <area coords="3" id="NetworkTest.java.frame.close"/>
                        <area coords="7" id="NetworkTest.java.frame.detach"/>
                     </areaspec>
                     <programlisting>public void frameStateChanged(TweekFrameEvent e)
{
   if ( e.getType() == TweekFrameEvent.FRAME_CLOSE )
   {
      if ( mSliderObserver != null )
      {
         mSliderObserver.detach();
         mSliderObserver = null;
      }
   }
}</programlisting>
                     <calloutlist>
                        <callout arearefs="NetworkTest.java.frame.close">
                           <para>If the event is the closing of the Tweek GUI frame, the CORBA reference clean-up steps will be taken.</para>
                        </callout>
                        <callout arearefs="NetworkTest.java.frame.detach">
                           <para>If the slider observer is defined, we assume that the observer is attached. The handy <methodname>detach()</methodname> method is invoked to detach this observer from the remote subject.</para>
                        </callout>
                     </calloutlist>
                  </programlistingco>
               </section>
               <section>
                  <title>Handling Local Slider Change Events</title>
                  <para>A helper class is used to handle local change events in the slider. The class is a private inner class within the Bean and is defined as follows:</para>
                  <programlistingco>
                     <areaspec>
                        <areaset coords="" id="NetworkTest.java.SliderChangeListener.stateChanged">
                           <area coords="12" id="NetworkTest.java.SliderChangeListener.stateChanged.adjust"/>
                           <area coords="14" id="NetworkTest.java.SliderChangeListener.stateChanged.setValue"/>
                        </areaset>
                     </areaspec>
                     <programlisting>private class SliderChangeListener implements ChangeListener
{
   public SliderChangeListener(SliderSubject subject)
   {
      mSliderSubject = subject;
   }

   public void stateChanged(javax.swing.event.ChangeEvent e)
   {
      JSlider source = (JSlider) e.getSource();

      if ( ! source.getValueIsAdjusting() )
      {
         mSliderSubject.setValue(source.getValue());
      }
   }

   private SliderSubject mSliderSubject = null;
}</programlisting>
                     <calloutlist>
                        <callout arearefs="NetworkTest.java.SliderChangeListener.stateChanged">
                           <para>Within the <methodname>stateChanged()</methodname> method, we check to see if the user is done adjusting the slider. If so, the remote subject is updated so that its internal value matches that of the local slider. Other users are automatically updated when this happens.</para>
                        </callout>
                     </calloutlist>
                  </programlistingco>
               </section>
               <section>
                  <title>XML File</title>
                  <para>With the Bean implementation done, the XML file that describes the Bean must be written. All Beans loaded by the Tweek Java GUI are described by an XML file. In <xref linkend="NetworkTestBean.xml.example"/>, we show the XML file for the Bean we have been developing.</para>
                  <example id="NetworkTestBean.xml.example">
                     <title>NetworkTestBean.xml</title>
                     <programlistingco>
                        <areaspec>
                           <area coords="1 70" id="NetworkTestBean.xml.version"/>
                           <area coords="2 70" id="NetworkTestBean.xml.beanlist"/>
                           <area coords="4 70" id="NetworkTestBean.xml.guipanel"/>
                           <area coords="5 70" id="NetworkTestBean.xml.file"/>
                           <area coords="7 70" id="NetworkTestBean.xml.tree"/>
                        </areaspec>
                        <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beanlist xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:noNamespaceSchemaLocation="http://www.vrjuggler.org/tweek/xsd/1.0/beanlist.xsd"&gt;
&lt;guipanel name="Network Tester"&gt;
&lt;file name="${TWEEK_BASE_DIR}/bin/beans/NetworkTestBean.jar"
      class="networktest.NetworkTest" /&gt;
&lt;tree path="/Beans" /&gt;
&lt;/guipanel&gt;
&lt;/beanlist&gt;</programlisting>
                        <calloutlist>
                           <callout arearefs="NetworkTestBean.xml.version">
                              <para>Well-formed XML requires this line.</para>
                           </callout>
                           <callout arearefs="NetworkTestBean.xml.beanlist">
                              <para>Tweek XML Bean files are <sgmltag>beanlist</sgmltag> documents. There must be exactly one <sgmltag>beanlist</sgmltag> per file, but the list itself can contain multiple Beans. In this element, we also provide the information needed to validate this document using the XML Schema <filename>beanlist.xsd</filename>. In this case, we use the schema that does not employ XML namespaces. Use of the schema for validation is optional, but it is recommended.</para>
                           </callout>
                           <callout arearefs="NetworkTestBean.xml.guipanel">
                              <para>The Bean we have been developing is a GUI Panel Bean, and this indicates that fact.</para>
                           </callout>
                           <callout arearefs="NetworkTestBean.xml.file">
                              <para>To find the Bean, a path must be specified. In this example, we will put the XML and JAR files in <filename>$TWEEK_BASE_DIR/bin/beans</filename>. Note the use of curly braces around the environment variable. This is required. The class attribute names the class that will be instantiated, and in this case, that is <filename>networktest.NetworkTest</filename>. This name corresponds more to the fully qualified name of the class stored within the JAR file.</para>
                           </callout>
                           <callout arearefs="NetworkTestBean.xml.tree">
                              <para>Panel Beans are loaded into a tree data structure and visualized using a viewer. This specifies the path within the tree using a UNIX-style path. The path is arbitrary and will be constructed as needed when the Bean is loaded.</para>
                           </callout>
                        </calloutlist>
                     </programlistingco>
                  </example>
                  <para>After the Bean is compiled into a JAR file, the JAR file and XML file need to be copied into <filename>$TWEEK_BASE_DIR/bin/beans</filename>. This is the default path that Tweek searches for Beans at startup, and it is a convenient place to put this example Bean.</para>
               </section>
            </section>
            <section>
               <title>Running the Example</title>
               <para>With all the coding done and the code compiled, we can run the C++ application and connect multiple instances of the Tweek Java GUI to it. The steps to run the C++ application are as follows:</para>
               <orderedlist>
                  <listitem>
                     <para>Run a CORBA Naming Service. This is required so that the C++ and Java ORBs can resolve symbolic references.</para>
                  </listitem>
                  <listitem>
                     <para>Since Tweek uses omniORB for a C++ ORB (see <xref linkend="orb-impl.appendix"/> for more information on this), the environment variable <varname>$OMNIORB_CONFIG</varname> must be set. This gives the full path to an omniORB configuration file that omniORB will load at runtime.</para>
                  </listitem>
                  <listitem>
                     <para>Run the C++ application.</para>
                  </listitem>
                  <listitem>
                     <para>Run the Tweek Java GUI. This will find and load all the Beans in <filename>$TWEEK_BASE_DIR/bin/beans</filename>.</para>
                  </listitem>
                  <listitem>
                     <para>Within the Java GUI, connect to the CORBA Naming Service started in step 1. The way the Bean is written, it will request the subject held by the C++ application automatically, and the slider will be updated to the current value.</para>
                  </listitem>
               </orderedlist>
            </section>
         </section>
         <section id="file.loader.section">
            <title>File Loader</title>
            <para>Not everything written in Tweek must use Java, C++, IDL, and CORBA. The Tweek Java GUI is a generalized Bean-loading environment, and as such, its main focus is to load JavaBeans and present them to the user. Those Beans may take advantage of CORBA, but they are not required to do so. In this section, we show another sample Bean that is much simpler than the previous example.</para>
            <para>The Bean shown in this example can open and close multiple text files. To do this, the Bean implements the interface <interfacename>org.vrjuggler.tweek.beans.FileLoader</interfacename>. The Java code will be shown in separate pieces to make it easier to understand. The full code is in <filename>$TWEEK_BASE_DIR/share/test/FileOpenTestBean/fileopentestbean/FileOpenTestBean.java</filename>. An example makefile can be found in <xref linkend="FileLoader.makefile.section"/>. within <xref linkend="makefile.appendix"/>..</para>
            <section>
               <title>The JavaBean</title>
               <para>As in the previous example, we focus on the imported classes first. They are as follows:</para>
               <programlistingco>
                  <areaspec>
                     <area coords="1" id="FileOpenTestBean.java.package"/>
                     <areaset coords="" id="FileOpenTestBean.java.std-imports">
                        <area coords="3" id="FileOpenTestBean.java.import.awt"/>
                        <area coords="4" id="FileOpenTestBean.java.import.io-File"/>
                        <area coords="5" id="FileOpenTestBean.java.import.io-FileInputStream"/>
                        <area coords="6" id="FileOpenTestBean.java.import.swing"/>
                     </areaset>
                     <area coords="7" id="FileOpenTestBean.java.import.ext-filter"/>
                     <area coords="8" id="FileOpenTestBean.java.import.FileLoader"/>
                  </areaspec>
                  <programlisting>package fileopentestbean;

import java.awt.*;
import java.io.File;
import java.io.FileInputStream;
import javax.swing.*;
import org.vrjuggler.tweek.services.ExtensionFileFilter;
import org.vrjuggler.tweek.beans.FileLoader;
</programlisting>
                  <calloutlist>
                     <callout arearefs="FileOpenTestBean.java.package">
                        <para>This Bean will be in the package <literal>fileopentestbean</literal>.</para>
                     </callout>
                     <callout arearefs="FileOpenTestBean.java.std-imports">
                        <para>These are the imports of standard Java classes. In this Bean, we need two Java file I/O classes so that we may load files.</para>
                     </callout>
                     <callout arearefs="FileOpenTestBean.java.import.ext-filter">
                        <para>This line imports the Tweek Service Bean known as the <classname>ExtensionFileFilter</classname>. This provides a simplified mechanism for making file filters typically used with <classname>JFileChooser</classname> instances.</para>
                     </callout>
                     <callout arearefs="FileOpenTestBean.java.import.FileLoader">
                        <para>This line imports the interface from the Tweek Bean library that we will implement.</para>
                     </callout>
                  </calloutlist>
               </programlistingco>
               <para>Next, we show the class declaration and the member variables.</para>
               <programlistingco>
                  <areaspec>
                     <area coords="1 75" id="FileOpenTestBean.java.superclass"/>
                     <area coords="2 75" id="FileOpenTestBean.java.interfaces"/>
                     <area coords="6 75" id="FileOpenTestBean.java.openFileCount"/>
                     <area coords="10 75" id="FileOpenTestBean.java.mTextContainer"/>
                  </areaspec>
                  <programlisting>public class FileOpenTestBean extends JPanel
                              implements java.io.Serializable, FileLoader
{
   // Methods ...

   private int openFileCount = 0;

   private BorderLayout mMainLayout    = new BorderLayout();
   private JLabel       mBeanTitle     = new JLabel();
   private JTabbedPane  mTextContainer = new JTabbedPane();
}</programlisting>
                  <calloutlist>
                     <callout arearefs="FileOpenTestBean.java.superclass">
                        <para>As the primary class for a Panel Bean, this class must from <classname>javax.swing.JComponent</classname> or some subclass thereof. In this case, the class will be <classname>javax.swing.JPanel</classname>.</para>
                     </callout>
                     <callout arearefs="FileOpenTestBean.java.interfaces">
                        <para>JavaBeans are expected to implement <interfacename>java.io.Serializable</interfacename>, and this class does that. The more interesting interface for this example is <interfacename>org.vrjuggler.tweek.beans.FileLoader</interfacename>. By implementing this interface, the Tweek Java GUI will know that this Bean can manage files.</para>
                     </callout>
                     <callout arearefs="FileOpenTestBean.java.openFileCount">
                        <para>This is a property of the class that keeps track of the number of currently open files.</para>
                     </callout>
                     <callout arearefs="FileOpenTestBean.java.mTextContainer">
                        <para>This Bean is capable of opening multiple files, and it will manage them with a <classname>JTabbedPane</classname>.</para>
                     </callout>
                  </calloutlist>
               </programlistingco>
               <para>Now that we have the basics for the class, we can start implementing the <interfacename>FileLoader</interfacename> interface. Of the methods that must be implemented, the most complex is <methodname>openRequested()</methodname>. It will be shown last because of its length. We will begin instead with the simplest methods.</para>
               <programlistingco>
                  <areaspec>
                     <area coords="3 70" id="FileOpenTestBean.java.getFileType"/>
                     <area coords="8 70" id="FileOpenTestBean.java.canOpenMultiple"/>
                     <area coords="13 70" id="FileOpenTestBean.java.canSave"/>
                     <area coords="18 70" id="FileOpenTestBean.java.saveRequested"/>
                     <area coords="23 70" id="FileOpenTestBean.java.closeRequested"/>
                     <area coords="30 70" id="FileOpenTestBean.java.getOpenFileCount"/>
                  </areaspec>
                  <programlisting linenumbering="numbered">public String getFileType()
{
   return "Text";
}

public boolean canOpenMultiple()
{
   return true;
}

public boolean canSave()
{
   return false;
}

public boolean saveRequested()
{
   return false;
}

public boolean closeRequested()
{
   mTextContainer.remove(mTextContainer.getSelectedComponent());
   openFileCount--;
   return true;
}

public int getOpenFileCount ()
{
   return openFileCount;
}</programlisting>
                  <calloutlist>
                     <callout arearefs="FileOpenTestBean.java.getFileType">
                        <para>This returns the type of file (or files) that can be loaded by the Bean. In this case, we are just loading plain text files.</para>
                     </callout>
                     <callout arearefs="FileOpenTestBean.java.canOpenMultiple">
                        <para>This method is used to determine if the Bean can open multiple files at one time. This Bean can because of its tabbed pane.</para>
                     </callout>
                     <callout arearefs="FileOpenTestBean.java.canSave">
                        <para>This method is used to determine if the Bean can save files, and this Bean does not.</para>
                     </callout>
                     <callout arearefs="FileOpenTestBean.java.saveRequested">
                        <para>Because this Bean does not save files, it simply returns <constant>false</constant> if a save is requested.</para>
                     </callout>
                     <callout arearefs="FileOpenTestBean.java.closeRequested">
                        <para>When a close is requested, the currently selected tab is removed and the open file count is decremented.</para>
                     </callout>
                     <callout arearefs="FileOpenTestBean.java.getOpenFileCount">
                        <para>This simply returns the number of currently open files.</para>
                     </callout>
                  </calloutlist>
               </programlistingco>
               <para>The above are all the methods of the <interfacename>FileLoader</interfacename> interface except <methodname>openRequested()</methodname>. We are now ready to move on to it.</para>
               <programlistingco>
                  <areaspec>
                     <area coords="8 75" id="FileOpenTestBean.java.openRequested.chooser"/>
                     <area coords="14 75" id="FileOpenTestBean.java.openRequested.filter"/>
                     <area coords="18 75" id="FileOpenTestBean.java.openRequested.show-chooser"/>
                     <areaset coords="" id="FileOpenTestBean.java.openRequested.read">
                        <area coords="24 75" id="FileOpenTestBean.java.openRequested.canRead"/>
                        <area coords="31 75" id="FileOpenTestBean.java.openRequested.do-read"/>
                     </areaset>
                     <area coords="34 75" id="FileOpenTestBean.java.openRequested.text-area"/>
                     <area coords="41 75" id="FileOpenTestBean.java.openRequested.scroll-pane"/>
                     <area coords="46 75" id="FileOpenTestBean.java.openRequested.open-inc"/>
                  </areaspec>
                  <programlisting linenumbering="numbered">public boolean openRequested()
{
   // Initialize this to false since a lot of things can go wrong in the
   // process of opening files.  Once the file is opened and read
   // successfully, this can be changed to true.
   boolean opened = false;

   JFileChooser chooser = new JFileChooser();
   chooser.setMultiSelectionEnabled(false);
   chooser.setDialogTitle("Text File Loader");
   chooser.setFileSelectionMode(JFileChooser.FILES_ONLY);

   // Only load .txt files.
   ExtensionFileFilter filter = new ExtensionFileFilter("Text Files");
   filter.addExtension("txt");
   chooser.addChoosableFileFilter(filter);

   int status = chooser.showOpenDialog(this);

   if ( status == JFileChooser.APPROVE_OPTION )
   {
      File file = chooser.getSelectedFile();

      if ( file.canRead() )
      {
         try
         {
            // Read the contents of the file into a byte[] object.
            FileInputStream input_file = new FileInputStream(file);
            byte[] file_data = new byte[(int) file.length()];
            input_file.read(file_data);

            // Create a text area to hold the contents of the file.
            JTextArea text_area = new JTextArea();
            text_area.setEditable(false);
            text_area.insert(new String(file_data), 0);

            // Create a scroll pane to hold the text area; add it to the
            // tabbed pane with all the other previously loaded scroll
            // panes; and make the new scroll pane the selected component.
            JScrollPane text_comp = new JScrollPane(text_area);
            mTextContainer.add(text_comp, file.getName());
            mTextContainer.setSelectedComponent(text_comp);

            // Our work is done.
            openFileCount++;
            opened = true;
         }
         catch (java.io.FileNotFoundException ex)
         {
            JOptionPane.showMessageDialog(null, "Cannot find '" +
                                          file.getAbsolutePath() + "'",
                                          "Read Error",
                                          JOptionPane.ERROR_MESSAGE);
         }
         catch (java.io.IOException ex)
         {
            JOptionPane.showMessageDialog(null, "Error reading from '" +
                                          file.getAbsolutePath() + "':" +
                                          ex.getMessage(), "Read Error",
                                          JOptionPane.ERROR_MESSAGE);
         }
      }
      else
      {
         JOptionPane.showMessageDialog(null, "Cannot read from file '" +
                                       file.getAbsolutePath() + "'",
                                       "Read Error",
                                       JOptionPane.ERROR_MESSAGE);
      }
   }

   return opened;
}</programlisting>
                  <calloutlist>
                     <callout arearefs="FileOpenTestBean.java.openRequested.chooser">
                        <para>First, we create a <classname>JFileChooser</classname> that will be used to select a text file. It is configured to allow selection of only a single file each time.</para>
                     </callout>
                     <callout arearefs="FileOpenTestBean.java.openRequested.filter">
                        <para>Next, we create a filter for <filename>.txt</filename> files that will be used by the file chooser.</para>
                     </callout>
                     <callout arearefs="FileOpenTestBean.java.openRequested.show-chooser">
                        <para>With those steps taken, we now open the chooser and wait for the user to select a file.</para>
                     </callout>
                     <callout arearefs="FileOpenTestBean.java.openRequested.read">
                        <para>If a readable file was chosen, we open it and read its contents into an array of <type>byte</type>s.</para>
                     </callout>
                     <callout arearefs="FileOpenTestBean.java.openRequested.text-area">
                        <para>With the bytes read, we can now put the contents of the text file into a read-only <classname>JTexArea</classname> object.</para>
                     </callout>
                     <callout arearefs="FileOpenTestBean.java.openRequested.scroll-pane">
                        <para>Next, we put the <classname>JTextArea</classname> in a <classname>JScrollPane</classname> so that long files can be viewed more easily. The scroll pane is added to the tabbed pane and made the currently selected panel.</para>
                     </callout>
                     <callout arearefs="FileOpenTestBean.java.openRequested.open-inc">
                        <para>At this point, we are done, so we increment the number of open files and set the return value to <constant>true</constant> to indicate that a file was opened successfully.</para>
                     </callout>
                  </calloutlist>
               </programlistingco>
               <para>This Bean uses no CORBA code and does not require C++ code to act as a peer. This may be the case for many Panel Beans written for Tweek. Of course, this Bean could be extended to open files that are then handed off to C++ code through CORBA.</para>
            </section>
            <section>
               <title>XML File</title>
               <para>The XML file for this Bean is very simple. It simply lists the Bean file information and puts the Bean at the root of the Bean tree. The full file is shown in <xref linkend="FileOpenTestBean.xml.example"/>.</para>
               <example id="FileOpenTestBean.xml.example">
                  <title>FileOpenTestBean.xml</title>
                  <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beanlist xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:noNamespaceSchemaLocation="http://www.vrjuggler.org/tweek/xsd/1.0/beanlist.xsd"&gt;
  &lt;guipanel name="File Open Test Bean"&gt;
    &lt;file name="${TWEEK_BASE_DIR}/bin/beans/FileOpenTestBean.jar" 
          class="fileopentestbean.FileOpenTestBean" /&gt;
    &lt;tree path="/" /&gt;
  &lt;/guipanel&gt;
&lt;/beanlist&gt;</programlisting>
               </example>
            </section>
         </section>
      </chapter>
   </part>
   <part>
      <title>Appendices</title>
      <appendix id="makefile.appendix">
         <title>Makefiles for Example Code</title>
         <para>This appendix provides makefiles that can be used as starting points for compiling the example code shown earlier. These can also be used as the basis for future projects using Tweek.</para>
         <section id="SliderSubject.makefile.section">
            <title>SliderSubject</title>
            <para>The following is a makefile that shows how to compile the code related to the <interfacename>SliderSubject</interfacename> example presented in <xref linkend="collab.slider.section"/>. It runs the IDL compiler, the C++ compiler, and the Java compiler. It assumes the use of <command>omniidl</command>, the JacORB compiler, and GCC in a Linux environment.</para>
            <programlisting>default: all

# Basic options.
srcdir		= .
CFLAGS		= $(EXTRA_CFLAGS) $(INCLUDES) $(DEFS)
CXXFLAGS		= -Wall -Werror-implicit-function-declaration \
                    -I$(VPR_BASE_DIR/include -I$(TWEEK_BASE_DIR)/include/tweek/CORBA \
                    $(EXTRA_CFLAGS) $(INCLUDES) $(DEFS)
CXX_IDL_OPTS	= -bcxx -Wbh=.h,s=.cpp -C$(srcdir)
CXX_IDL_INCLUDES	= -I$(TWEEK_BASE_DIR)/include
JAVAC_FLAGS	= -classpath $(CLASSPATH) -sourcepath $(srcdir) -d .
JAVA_IDL_OPTS	=  -d $(srcdir)
JAVA_IDL_INCLUDES	= -I$(TWEEK_BASE_DIR)/include

JAVA_ORB_JAR	= $(HOME)/OpenORB-1.2.0/lib/openorb-1.2.0.jar

TWEEK_EVENT_LIB	= $(TWEEK_BASE_DIR)/bin/TweekEvents.jar
TWEEK_NET_LIB	= $(TWEEK_BASE_DIR)/bin/TweekNet.jar
CLASSPATH	= $(TWEEK_EVENT_LIB):$(TWEEK_NET_LIB):$(JAVA_ORB_JAR)
DEFS		= -D__linux__ -D__OSVERSION__=2 -D__x86__
EXTRA_CFLAGS	= $(DEBUG_CFLAGS)
DEBUG_CFLAGS	= -g -D_DEBUG
OPTIM_CFLAGS	= -O2 -fno-strict-aliasing -D_OPT
INCLUDES		= -I$(TWEEK_BASE_DIR)/include -I$(HOME)/omni/include -I$(srcdir)

EXTRA_LFLAGS	= $(DEBUG_LFLAGS)
DEBUG_LFLAGS	= 
OPTIM_LFLAGS	= 
LINK_FLAGS	= $(EXTRA_LFLAGS)

# Libraries needed for linking.
BASIC_LIBS	= -Wl,-Bstatic $(LINKALL_ON) -L$(TWEEK_BASE_DIR)/lib -ltweek \
                    $(LINKALL_OFF) -Wl,-Bdynamic
EXTRA_LIBS	= -Wl,-Bdynamic  -L$(HOME)/omni/lib/i586_linux_2.0_glibc \
                    -lomniORB3 -lomnithread -lomniDynamic3 -lomniGK_stub   \
                    -L$(VPR_BASE_DIR)/lib -lvpr  -pthread   

# Commands to execute.
C_COMPILE	= gcc $(CFLAGS)
CXX_IDL		= $(HOME)/omni/bin/i586_linux_2.0_glibc/omniidl
CXX_COMPILE	= c++ $(CXXFLAGS)
JAVA_COMPILE	= /usr/java/jdk1.3.1_02/bin/javac $(JAVAC_FLAGS)
JAVA_IDL		= JACORB_PATH="$(TWEEK_BASE_DIR)/bin" "$(TWEEK_BASE_DIR)/bin/idl"
JAR		= /usr/java/jdk1.3.1_02/bin/jar
LINK		= c++ $(LINK_FLAGS)
LINKALL_ON	= -W,--whole-archive
LINKALL_OFF	= -W,--no-whole-archive

VPATH = $(srcdir):$(srcdir)/networktest:$(srcdir)/tweek:$(TWEEK_BASE_DIR)/include/tweek/idl

IDL_CXX_FILES	= SliderSubject.cpp SliderSubject.h
IDL_JAVA_FILES	= SliderSubject.java		\
                    Observer.java

OBJS		= SliderSubject.o SliderSubjectImpl.o	\
                    SliderSubjectApp.o
CLASSES		= networktest/NetworkTest.class		\
                    networktest/SliderObserverImpl.class	\
                    networktest/SliderSubjectHolder.class	\
                    tweek/ObserverHolder.class

NETWORK_TEST_CLASSES = networktest/*.class tweek/*.class

# -----------------------------------------------------------------------------
# Application build targets.
# -----------------------------------------------------------------------------
all:
	$(MAKE) cxx_idl
	$(MAKE) java_idl
	$(MAKE) cxx
	$(MAKE) server
	$(MAKE) java
	$(MAKE) NetworkTestBean.jar
	-$(MAKE) install

cxx_idl: $(IDL_CXX_FILES)

java_idl: $(IDL_JAVA_FILES)

cxx: $(OBJS)

java: $(CLASSES)

server: $(OBJS)
	$(LINK) -o $@ $(OBJS) $(BASIC_LIBS) $(EXTRA_LIBS)

NetworkTestBean.jar: $(CLASSES)
	$(JAR) cvfm $@ $(srcdir)/networktest.MF $(NETWORK_TEST_CLASSES)

install:
	cp NetworkTestBean.jar $(TWEEK_BASE_DIR)/bin/beans
	cp $(srcdir)/NetworkTestBean.xml $(TWEEK_BASE_DIR)/bin/beans

# Suffix rules for building object files.
.SUFFIXES: .cpp .o .java .class .idl .h

.cpp.o:
	$(CXX_COMPILE) -o $@ -c $&lt;

.java.class:
	$(JAVA_COMPILE) $&lt;

.idl.cpp:
	$(CXX_IDL) $(CXX_IDL_OPTS) $(CXX_IDL_INCLUDES) $&lt;

.idl.h:
	$(CXX_IDL) $(CXX_IDL_OPTS) $(CXX_IDL_INCLUDES) $&lt;

SliderSubject.java: SliderSubject.idl
	$(JAVA_IDL) $(JAVA_IDL_OPTS) -noskel $(JAVA_IDL_INCLUDES) $&lt;

.idl.java:
	$(JAVA_IDL) $(JAVA_IDL_OPTS) $(JAVA_IDL_INCLUDES) $&lt;

# -----------------------------------------------------------------------------
# Clean-up targets.
# -----------------------------------------------------------------------------
clean:
	rm -f Makedepend *.o networktest.ilk  so_locations *.?db	\
          core* $(addprefix $(srcdir)/, $(IDL_CXX_FILES))		\
          $(addprefix $(srcdir)/networktest/, $(IDL_JAVA_FILES))
	rm -rf ii_files $(srcdir)/tweek

clobber:
	@$(MAKE) clean
	rm -f server </programlisting>
         </section>
         <section id="FileLoader.makefile.section">
            <title>File Loader</title>
            <para>The following is a makefile that shows how to compile the code related to the file loader Bean example presented in <xref linkend="file.loader.section"/>. All it must do is compile the Java code for the Bean.</para>
            <programlisting># Generated automatically from Makefile.in by configure.
default: all

# Basic options.
srcdir		= .
JAVAC_FLAGS	= -classpath $(CLASSPATH) -sourcepath $(srcdir) -d .
JCPS		= :

JDOM_JAR		= $(JDOM_ROOT)/jdom.jar:$(JDOM_ROOT)/xerces.jar

TWEEK_SERV_LIB	= $(TWEEK_BASE_DIR)/bin/TweekServices.jar
TWEEK_NET_LIB	= $(TWEEK_BASE_DIR)/bin/TweekEvents.jar
CLASSPATH	= $(TWEEK_SERV_LIB):$(TWEEK_NET_LIB):$(JDOM_JAR)

# Commands to execute.
JAVA_COMPILE	= javac $(JAVAC_FLAGS)
JAR		= jar

VPATH		= .

CLASSES		= fileopentestbean/FileOpenTestBean.class
ALL_CLASSES	= fileopentestbean/*.class

# -----------------------------------------------------------------------------
# Application build targets.
# -----------------------------------------------------------------------------
all:
	$(MAKE) java
	$(MAKE) FileOpenTestBean.jar
	-$(MAKE) install

java: $(CLASSES)

FileOpenTestBean.jar: $(CLASSES)
	$(JAR) cvfm $@ $(srcdir)/opener_test.MF $(ALL_CLASSES)

install:
	cp FileOpenTestBean.jar $(TWEEK_BASE_DIR)/bin/beans
	cp $(srcdir)/FileOpenTestBean.xml $(TWEEK_BASE_DIR)/bin/beans

# Suffix rules for building object files.
.SUFFIXES: .java .class

.java.class:
	$(JAVA_COMPILE) $&lt;

# -----------------------------------------------------------------------------
# Clean-up targets.
# -----------------------------------------------------------------------------
clean:
	rm -rf fileopentestbean

clobber:
	@$(MAKE) clean
	rm -f FileOpenTestBean.jar</programlisting>
         </section>
      </appendix>
      <appendix id="orb-impl.appendix">
         <title>CORBA Implementations</title>
         <para>In order to use CORBA, a CORBA implementation must be available. As of this writing, Tweek uses omniORB 3.0.4 <xref linkend="Omn02"/> for a C++ ORB. Since Tweek uses POA, any C++ ORB may be used with only a few changes to the code.</para>
         <para>For the Java side, OpenORB 1.2.0 <xref linkend="Ope02"/> has been used. Java IDL <xref linkend="Jid02"/>, the CORBA implementation that comes with the Java Development Kit (JDK), does not fully implement POA as of JDK 1.3.1. With the release of JDK 1.4.0, Java IDL has a complete implementation and can be used without taking any special steps.</para>
         <para>To use an alternate ORB with Java, two arguments must be passed to the Java virtual machine. They are based on the ORB implementation. For example, if using OpenORB, the following two arguments must be specified:</para>
         <orderedlist>
            <listitem>
               <para><option>-Dorg.omg.CORBA.ORBClass=org.openorb.CORBA.ORB</option></para>
            </listitem>
            <listitem>
               <para><option>-Dorg.omg.CORBA.ORBSingletonClass=org.openorb.CORBA.ORB</option>Singleton</para>
            </listitem>
         </orderedlist>
         <para>Other ORBs will vary in the location of the <classname>ORBClass</classname> and the <classname>ORBSingletonClass</classname>. Refer to the documentation of the specific ORB to find out more about using it instead of Java IDL.</para>
      </appendix>
   </part>
   <bibliography>
      <biblioentry id="Gam95">
         <biblioset relation="book">
            <authorgroup>
               <author>
                  <firstname>Erich</firstname>
                  <surname>Gamma</surname>
               </author>
               <author>
                  <firstname>Richard</firstname>
                  <surname>Helm</surname>
               </author>
               <author>
                  <firstname>Ralph</firstname>
                  <surname>Johnson</surname>
               </author>
               <author>
                  <firstname>John</firstname>
                  <surname>Vlissides</surname>
               </author>
            </authorgroup>
            <title>Design Patterns</title>
            <copyright>
               <year>1995</year>
               <holder>Addison Wesley Longman, Inc.</holder>
            </copyright>
            <isbn>0-201-63361-2</isbn>
            <publisher>
               <publishername>Addison-Wesley</publishername>
            </publisher>
         </biblioset>
      </biblioentry>
      <biblioentry id="Hen99">
         <biblioset relation="book">
            <authorgroup>
               <author>
                  <firstname>Michi</firstname>
                  <surname>Henning</surname>
               </author>
               <author>
                  <firstname>Steve</firstname>
                  <surname>Vinoski</surname>
               </author>
            </authorgroup>
            <title>Advanced CORBA Programming with C++</title>
            <copyright>
               <year>1999</year>
               <holder>Addison Wesley Longman, Inc.</holder>
            </copyright>
            <isbn>0-201-37927-9</isbn>
            <publisher>
               <publishername>Addison Wesley Longman, Inc.</publishername>
            </publisher>
         </biblioset>
      </biblioentry>
      <biblioentry id="Jbe02">
         <biblioset relation="website">
            <address><otheraddr><ulink url="http://java.sun.com/products/javabeans/">JavaBeans website</ulink></otheraddr></address>
         </biblioset>
      </biblioentry>
      <biblioentry id="Jid02">
         <biblioset relation="website">
            <address><otheraddr><ulink url="http://java.sun.com/products/jdk/idl/">Java IDL website</ulink></otheraddr></address>
         </biblioset>
      </biblioentry>
      <biblioentry id="Omn02">
         <biblioset relation="website">
            <address><otheraddr><ulink url="http://www.uk.research.att.com/omniORB/">omniORB website</ulink></otheraddr></address>
         </biblioset>
      </biblioentry>
      <biblioentry id="Ope02">
         <biblioset relation="website">
            <address><otheraddr><ulink url="http://www.openorb.com/">OpenORB website</ulink></otheraddr></address>
         </biblioset>
      </biblioentry>
   </bibliography>
   <glossary>
      <title>Glossary</title>
      <glossdiv>
         <title>A</title>
         <glossentry id="gloss.api">
            <glossterm>application programmer interface</glossterm>
            <acronym>API</acronym>
            <glossdef>
               <para>An application programmer interface is the documented, programatic interface used by programmers to access a software library.</para>
            </glossdef>
         </glossentry>
      </glossdiv>
      <glossdiv>
         <title>C</title>
         <glossentry id="gloss.corba">
            <glossterm>Common Object Request Broker Architecture</glossterm>
            <acronym>CORBA</acronym>
            <glossdef>
               <para>The Common Object Request Broker Architecture (CORBA) is a standard specified by the Object Management Group for distributed object-oriented programming. It is both platform- and language-independent. Implementations of CORBA are available from many vendors for a wide variety of programming languages.</para>
            </glossdef>
         </glossentry>
      </glossdiv>
      <glossdiv>
         <title>D</title>
         <glossentry id="gloss.distrib-programming">
            <glossterm>distributed programming</glossterm>
            <glossdef>
               <para>Distributed programming is a paradigm in which software components are installed on physically separated computers and accessed remotely though a network. Examples of distributed programming include Sun's Remote Procedure Calls (RPC), Java's Remote Method Invocation (RMI), Microsoft's Component Object Model (COM), and the Common Object Request Broker Architecture (CORBA). RPC is based on the procedural programming paradigm used by languages such as C and Pascal. With RPC, procedures residing in memory on remote machines are accessed. The other examples listed are based on the object-oriented programming paradigm used by languages such as C++, Java, Smalltalk, and Python. In this case, software objects and their methods are accessed remotely.</para>
            </glossdef>
         </glossentry>
      </glossdiv>
      <glossdiv>
         <title>E</title>
         <glossentry id="gloss.xml.main">
            <glossterm>Extensible Markup Language</glossterm>
            <acronym>XML</acronym>
            <glossdef>
               <para>The eXtensible Markup Language (XML) is a specification from the World Wide Web Consortium. XML itself is a language for specifying well-defined, structured document markup.</para>
            </glossdef>
         </glossentry>
      </glossdiv>
      <glossdiv>
         <title>G</title>
         <glossentry id="gloss.gui">
            <glossterm>graphical user interface</glossterm>
            <acronym>GUI</acronym>
            <glossdef>
               <para>Graphical user interfaces are used in modern operating systems that support the concept of <quote>windows</quote>. The windows provide a visual representation of an application and usually have a border and a title to distinguish one window from another. Within the window, there are graphical elements known as <quote>widgets</quote> that make up the full interface. Widgets include pull-down menus, clickable buttons, and scroll bars.</para>
            </glossdef>
         </glossentry>
      </glossdiv>
      <glossdiv>
         <title>I</title>
         <glossentry id="gloss.idl-compiler">
            <glossterm>IDL compiler</glossterm>
            <glossdef>
               <para>A software tool that reads an IDL file and generates code in a specific language (e.g., Java, C++, Smalltalk, etc.). This code may be anything, but typically, it is stub or skeleton code that is extended by user-defined code that completes the interface implementation.</para>
            </glossdef>
         </glossentry>
         <glossentry id="gloss.interface">
            <glossterm>interface</glossterm>
            <glossdef>
               <para>Several types of <quote>interfaces</quote> exist within the scope of Tweek:</para>
               <itemizedlist>
                  <listitem>
                     <para>In Java. there is a keyword <literal>interface</literal> that can be used to define a set of methods that must be part of an implementing class. Classes that claim to implement a given interface must define the methods described by the interface or declare themselves abstract.</para>
                  </listitem>
                  <listitem>
                     <para>In <glossterm linkend="gloss.idl">IDL</glossterm>, an interface is essentially identical to a Java interface, but an IDL compiler can generate code from the IDL. The interface methods must still be implemented (by a C++ class, for example), and thus, the main function of an IDL interface is to define a language-independent signature through which CORBA communication may occur.</para>
                  </listitem>
                  <listitem>
                     <para>In C++, there is no <literal>interface</literal> keyword as in Java and IDL. The term <quote>interface</quote> is typically applied to abstract classes (those with pure virtual methods). More generally, it is use to refer to the collection of methods defined by a class.</para>
                  </listitem>
               </itemizedlist>
            </glossdef>
         </glossentry>
         <glossentry id="gloss.idl">
            <glossterm>Interface Definition Language</glossterm>
            <acronym>IDL</acronym>
            <glossdef>
               <para>The Interface Definition Language is a simple language used to define the interface (or signature) an object will have. An interface is composed solely of methods (functions) that may be invoked on an object (data element). No data members are present in the interface definition. IDL is not tied to a specific language but instead must be compiled into another language where the interface will be implemented.</para>
            </glossdef>
         </glossentry>
         <glossentry id="gloss.iiop">
            <glossterm>Internet Inter-ORB Protocol</glossterm>
            <acronym>IIOP</acronym>
            <glossdef>
               <para>The Internet Inter-ORB Protocol (IIOP) is part of the CORBA specification. It is used to standardize communication between ORBs so that ORBs from different vendors can inter-operate seamlessly.</para>
            </glossdef>
         </glossentry>
      </glossdiv>
      <glossdiv>
         <title>J</title>
         <glossentry id="gloss.javabean">
            <glossterm>JavaBean</glossterm>
            <glossdef>
               <para>JavaBeans are the component architecture of the Java programming language. There are no restrictions on the interfaces implemented by JavaBeans, though it is strongly recommended that they implement <interfacename>java.io.Serializable</interfacename>.</para>
            </glossdef>
         </glossentry>
         <glossentry id="gloss.jni">
            <glossterm>Java Native Interface</glossterm>
            <acronym>JNI</acronym>
            <glossdef>
               <para>The Java Native Interface is the bridge between a Java virtual machine (JVM) and natively compiled code. Native code can load a JVM and get access to Java objects through it, or Java classes may have native methods that are loaded by the JVM.</para>
            </glossdef>
         </glossentry>
      </glossdiv>
      <glossdiv>
         <title>O</title>
         <glossentry id="gloss.orb">
            <glossterm>Object Request Broker</glossterm>
            <acronym>ORB</acronym>
            <glossdef>
               <para>An Object Request Broker (ORB) is used by CORBA for management of interface implementation objects (servants) and the references made to those objects. ORBs communicate with each other using a client/server model, though two ORBs may both act as servers and clients during the transactions.</para>
            </glossdef>
         </glossentry>
      </glossdiv>
      <glossdiv>
         <title>P</title>
         <glossentry id="gloss.poa">
            <glossterm>Portable Object Adapter</glossterm>
            <acronym>POA</acronym>
            <glossdef>
               <para>The Portable Object Adapter (POA) the standard object adapter and is part of the CORBA 2.3 specification. It is used together with IIOP to allow ORB implementations from different vendors to communicate. A single ORB may have multiple POAs each tailored to a certain task using parameterized characteristics.</para>
            </glossdef>
         </glossentry>
      </glossdiv>
      <glossdiv>
         <title>R</title>
         <glossentry id="gloss.rmi">
            <glossterm>Remote Method Invocation</glossterm>
            <acronym>RMI</acronym>
            <glossdef>
               <para>Remote Method Invocation (RMI) is a mechanism for gaining access to remote Java code. It is implemented as part of the Java virtual machine and was originally intended to be comparable to CORBA. RMI allows easy access to code between two virtual machines, but it does not have the cross-language features of CORBA.</para>
            </glossdef>
         </glossentry>
      </glossdiv>
      <glossdiv>
         <title>S</title>
         <glossentry id="gloss.servant">
            <glossterm>servant</glossterm>
            <glossdef>
               <para>In CORBA, a servant is an instance of an interface implementation that is registered with an ORB. A servant receives method invocations through the CORBA object adapter.</para>
            </glossdef>
         </glossentry>
      </glossdiv>
      <glossdiv>
         <title>X</title>
         <glossentry id="gloss.xml">
            <glossterm>XML</glossterm>
            <glossdef>
               <para>See <glossterm linkend="gloss.xml.main">Extensible Markup Language</glossterm>.</para>
            </glossdef>
         </glossentry>
      </glossdiv>
   </glossary>
   <index/>
</book>

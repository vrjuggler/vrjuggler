<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<book>
   <bookinfo>
      <title>Tweek</title>

      <subtitle>The Programmer's Guide</subtitle>

      <authorgroup>
         <author>
            <firstname>Patrick</firstname>

            <surname>Hartling</surname>
         </author>
      </authorgroup>

      <copyright>
         <year>2002–2009</year>

         <holder>Iowa State University</holder>
      </copyright>

      <legalnotice>
         <para>Permission is granted to copy, distribute and/or modify this
         document under the terms of the GNU Free Documentation License,
         Version 1.2 or any later version published by the Free Software
         Foundation; with the Invariant Sections being <xref
         linkend="appendix.gfdl" />, with no Front-Cover Texts, and with no
         Back-Cover Texts. A copy of the license is included in <xref
         linkend="appendix.gfdl" />.</para>
      </legalnotice>

      <releaseinfo>1.3</releaseinfo>

      <pubdate>$Date$</pubdate>
   </bookinfo>

   <preface>
      <title>Preface</title>

      <para>This book is the programmer's guide for Tweek. The main focus is
      how to use the features and capabilities of Tweek to enable
      cross-platform Java graphical user interfaces (GUIs) to communicate with
      C++ applications.</para>

      <para>The history of Tweek dates back to April 2000, though the basis
      for its existence comes from circa 1997. At Iowa State University's
      Virtual Reality Applications Center, the idea of using a Java GUI to
      communicate with, and possibly perform manipulations on, C++
      applications is the foundation for dynamic reconfiguration of VR
      Juggler. To that end, the Java application VjControl was developed
      specifically for that purpose. VjControl was started in 1997 and has
      been under development ever since.</para>

      <para>Building on the basic idea of a Java GUI that could communicate
      with a C++ application, a viewer was written for the Distributed Shared
      Object (DSO) software system written in April 2000. This iteration of
      DSO was for a class project (Computer Science 552 taught by Dr. Johnny
      Wong). At the time, we (Allen Bierbaum and I) felt that CORBA could be
      used as a way to share arbitrary object-based information between
      applications on a network. The Java GUI was used to visualize the
      network of CORBA-connected nodes and to manipulate the network by
      disconnecting and reconnecting the nodes. In the end, CORBA was not the
      right solution to this problem, but the basis for network visualization
      was founded. Using CORBA for communication between the C++ code and Java
      code was relatively easy, however.</para>

      <para>In April 2001, we were again faced with a class project. Based on
      the results of the CORBA-based DSO, we felt that it would be best to
      implement a peer-to-peer software multicasting system that would be more
      efficient than CORBA. This new system, called Plexus, would still offer
      the same capabilities of cross-platform data distribution, but we had to
      give up the inherent cross-language support offered by CORBA. Again, we
      wanted a Java GUI for visualizing the network, and we started with the
      DSO viewer code. Instead of using CORBA, which we had had some
      difficulties with the previous year, we chose to use Java's built-in
      Remote Method Invocation (RMI) system. While RMI is very easy to use
      between two Java applications, Java to C++ communication is difficult.
      It requires the use of the Java Native Interface (JNI) so that natively
      compiled C++ code can communicate in memory with a loaded Java virtual
      machine (JVM). All of the Java code and RMI was collected into a package
      called PlxView (<quote>plex-view</quote>).</para>

      <para>Despite the difficulty of writing JNI code, the RMI solution was
      effective, for the most part. In September 2001, yet another project
      loomed. By this time, we were fed up with RMI, and we decided to go back
      to CORBA solely for communicating between Java and C++. Indeed, by using
      CORBA, we could write network visualization software in
      <emphasis>any</emphasis> language and communicate through the same
      channels.</para>

      <para>Beyond just communicating with the C++ applications, we had high
      hopes for using RMI to download Java code at run time to add custom
      visualization panels to the Java GUI dynamically. The Java code would
      come in the form of JavaBeans. While PlxView was designed to be modular
      from the start, we had not implemented the code for downloading the
      JavaBeans. To begin that work, I started writing code on a flight from
      Dallas/Ft. Worth to London, England, the evening of October 1, 2001.
      While at a CAVE workshop in Stockholm, Sweden, I took advantage of down
      time and late nights to extend PlxView to load and use JavaBeans.</para>

      <para>When I returned to the United States after the week in Stockholm,
      PlxView had evolved into what could be called version 0.0.0 of the Tweek
      Java GUI (sans CORBA, however). Its primary purpose was still Plexus
      network visualization. Design discussions with other members of the
      Juggler Team evolved the code into what is now the Tweek Java API. The
      Plexus-specific parts were separated into what is now the PlxView Bean,
      and the remaining code was moved into the new Tweek source tree.</para>

      <para>The only remaining piece was CORBA support. Another student,
      Andrew Schwantes, had been experimenting with CORBA in a smaller system,
      and his C++ CORBA code was used as a starting point for the Tweek C++
      API. After much discussion with Allen Bierbaum, the code was re-written
      entirely to make use of the Observer design pattern, and the Subject
      Manager was added. After all of that, the Java CORBA code was relatively
      trivial to add. And thus, the foundation for Tweek was in place by
      November 2001. By this time, it was already in use by the Fall 2001
      Plexus class project.</para>
   </preface>

   <part>
      <title>Introduction</title>

      <chapter id="intro.tweek.chapter">
         <title>Tweek</title>

         <para>Programmers using Tweek must first understand what it is and
         what at does, at least at a conceptual level. Tweek has two parts: a
         Java <glossterm linkend="gloss.api">API</glossterm> and a C++ API.
         The two provide very distinct functionality, but they share a common
         bond through the use of remote method calls on shared objects.
         Objects defined in the C++ programming language can be accessed by
         objects defined in the Java programming language. Similarly, objects
         defined in Java can be accessed by C++ code. The C++ objects may be
         visualized and manipulated using the Tweek Java <glossterm
         linkend="gloss.gui">graphical user interface</glossterm> (GUI), a
         tool written using the Tweek Java API. This cross-language
         functionality is achieved through the use of remote method
         calls.</para>

         <para>Some readers may be familiar with remote procedure calls (RPC),
         a remote programming system first introduced by Sun Microsystems that
         uses the procedural programming paradigm. Remote method calls differ
         primarily through the use of the object-oriented programming
         paradigm. Tweek is implemented in two object-oriented languages and
         thus lends itself very well to a system implementing remote method
         calls.</para>

         <para>In the remainder of this chapter, we present a high-level
         description of the Tweek C++ API. The Java API design is much more
         complex and is not included in this chapter. (Refer to <xref
         linkend="prog.java.chapter" /> for details on using the Java API.)
         Most users of Tweek need to know more about the C++ side of Tweek
         than the Java side. This is because Tweek is designed around the
         philosophy of a simple Java GUI interacting with a potentially
         complex C++ application.</para>

         <section id="intro.design.section">
            <title>C++ API Design Overview</title>

            <para>The heart of the Tweek software system implements the
            Observer pattern <xref linkend="Gam95" />. This design pattern is
            used to define the relationship between the Java GUI (observer)
            and the C++ application (subject). Within this section, we explain
            how the subject and observer are used. Moving beyond the
            subject/observer pattern, we also explain the <firstterm>Subject
            Manager</firstterm><indexterm>
                  <primary>Subject Manager</primary>
               </indexterm> and the <firstterm>CORBA
            Manager</firstterm><indexterm>
                  <primary>CORBA Manager</primary>
               </indexterm>. These four components make up the entirety of the
            C++ design.</para>

            <section>
               <title>Subject</title>

               <indexterm>
                  <primary>subject</primary>

                  <secondary>design and use</secondary>
               </indexterm>

               <para>The subjects in Tweek are part of the C++ applications.
               The communication <quote>channels</quote> are defined by the
               subjects' interfaces. An observer is attached to a subject, and
               whenever the state of a subject changes, it notifies all of its
               attached observers.</para>

               <para>The Tweek C++ API defines the basic subject interface
               (<interfacename>tweek::Subject</interfacename><indexterm>
                     <primary>interfaces</primary>

                     <secondary>tweek::Subject</secondary>
                  </indexterm>) that implements the subject pattern <xref
               linkend="Gam95" />. Users of the Tweek C++ API derive from the
               base subject implementation
               (<classname>tweek::SubjectImpl</classname><indexterm>
                     <primary>classes</primary>

                     <secondary>tweek::SubjectImpl</secondary>
                  </indexterm>) and extend it by adding their own interface
               methods. This extension is twofold. First, an interface must be
               defined using the <glossterm linkend="gloss.idl">Interface
               Definition Language</glossterm> (IDL)<indexterm>
                     <primary>IDL</primary>
                  </indexterm>. Then, the interface must be implemented in C++
               code. (Refer to <xref linkend="intro.corba.idl.section" /> for
               more information about IDL in Tweek.)</para>
            </section>

            <section>
               <title>Observer</title>

               <indexterm>
                  <primary>observer</primary>

                  <secondary>design and use</secondary>
               </indexterm>

               <para>The observers in Tweek are (traditionally) part of the
               Java GUI<footnote>
                     <para>Beginning with Tweek 0.13, helper classes for
                     writing C++ observers are included with the C++ API.
                     Users of older versions can make use of observers written
                     in C++ (or any other programming language with a CORBA
                     implementation), but the application developers will have
                     to write the CORBA client code entirely from
                     scratch.</para>
                  </footnote>. They observe the state of the remote subjects
               and can provide a visual rendering of that state.</para>

               <para>Programmers <emphasis>do not</emphasis> define interfaces
               for the observers. Instead, the Tweek C++ API defines a basic
               observer interface called
               <interfacename>tweek::Observer</interfacename><indexterm>
                     <primary>interfaces</primary>

                     <secondary>tweek::Observer</secondary>
                  </indexterm>. There is no <quote>standard</quote> observer
               implementation that corresponds to
               <classname>tweek::SubjectImpl</classname><indexterm>
                     <primary>classes</primary>

                     <secondary>tweek::SubjectImpl</secondary>
                  </indexterm>. By design, observers must correspond directly
               with subjects, but there is no need to extend the basic
               observer interface using IDL. Observer implementations simply
               inherit from the basic observer class
               (<classname>tweek.ObserverPOA</classname><indexterm>
                     <primary>classes</primary>

                     <secondary>tweek.ObserverPOA</secondary>
                  </indexterm> in Java or
               <classname>POA_tweek::Observer</classname><indexterm>
                     <primary>classes</primary>

                     <secondary>POA_tweek::Observer</secondary>
                  </indexterm> in C++) and implement the
               <methodname>update()</methodname> method. Other extensions can
               be added in the custom observer class, of course, but an
               implementation of <methodname>update()</methodname> is always
               required.</para>
            </section>

            <section>
               <title>CORBA Manager</title>

               <indexterm>
                  <primary>CORBA Manager</primary>

                  <secondary>design and use</secondary>
               </indexterm>

               <para><glossterm linkend="gloss.corba">CORBA</glossterm> tends
               to have a high learning curve. It is a very powerful system,
               but that power leads to a lot of complexity. To reduce the
               complexity of starting and using an <glossterm
               linkend="gloss.orb">ORB</glossterm>, Tweek provides a CORBA
               Manager. Its primary function is to initialize a local ORB. It
               does this by creating the <glossterm
               linkend="gloss.poa">Portable Object Adapter</glossterm> (POA),
               resolving the initial reference to the Naming Service, and
               starting a thread for the ORB to handle requests.</para>

               <note>
                  <para>An explanation of the POA is beyond the scope of this
                  book. Users of Tweek do not have to use the POA directly
                  because the CORBA Manager and Subject Manager hide these
                  details. Interested readers are referred to <xref
                  linkend="Hen99" /> for more information about the POA and
                  CORBA in general.</para>
               </note>

               <para>Once the local ORB is initialized, the Subject Manager
               (discussed next) must be created. This is also done through the
               CORBA Manager because the Subject Manager is a CORBA object.
               The newly created Subject Manager will be a <glossterm
               linkend="gloss.servant">servant</glossterm> object to which
               CORBA references can be created.</para>

               <para>Refer to <xref linkend="intro.corba.section" /> for more
               information about CORBA and its use in Tweek. For the most
               part, the use of CORBA is an implementation detail. Users of
               the Tweek C++ API must initialize the CORBA Manager, however,
               and it is important to understand its place in the overall
               system.</para>
            </section>

            <section>
               <title>Subject Manager</title>

               <indexterm>
                  <primary>Subject Manager</primary>

                  <secondary>design and use</secondary>
               </indexterm>

               <para>The Tweek Subject Manager exists to simplify the use of
               CORBA further. At a very high level, it acts as a simplified,
               specialized CORBA Naming Service. Users of Tweek register
               subject servants with the Subject Manager. The Subject Manager
               handles the CORBA registration and activation of the servants.
               After being registered, subjects are accessed using symbolic
               strings. The strings are user-defined and do not necessarily
               conform to any CORBA-related standard. They are, in essence,
               identifiers used to look up the subject within the Subject
               Manager's collection of known subjects.</para>
            </section>
         </section>

         <section id="intro.corba.section">
            <title>CORBA</title>

            <indexterm>
               <primary>CORBA</primary>

               <secondary>use in Tweek</secondary>
            </indexterm>

            <para>CORBA, the <glossterm linkend="gloss.corba">Common Object
            Request Broker Architecture</glossterm>, is a powerful tool for
            <glossterm linkend="gloss.distrib-programming">distributed
            programming</glossterm>. It is a
            <emphasis>language-independent</emphasis> standard specified by
            the <ulink url="http://www.omg.org/">Object Management
            Group</ulink> (OMG). Many CORBA implementations, both free and
            commercial, exist for a wide variety of languages (e.g., C, C++,
            Java, Perl, Python, and Smalltalk). CORBA allows communication
            between software written in any programming language running on
            any operating system on any hardware architecture. It handles all
            serialization and de-serialization of objects and method
            parameters so that programmers do not have to worry about endian
            issues and other system incompatibilities.</para>

            <para>Before going further with the discussion of CORBA in Tweek,
            readers must be familiar with some terminology. In CORBA, the
            physical object to which references are made is called a
            <glossterm
            linkend="gloss.servant"><firstterm>servant</firstterm></glossterm>.
            The servant is an instance of some class that implements an
            interface and derives from <classname>CORBA::Object</classname>
            (or <classname>org.omg.CORBA.Object</classname> in Java). The
            actual details of servant implementations are postponed for later
            sections. For now, it is important to remember that there will be
            an object located in physical memory on some machine, and
            <emphasis>references</emphasis> will be made to that object
            through CORBA. Users acquire references by looking up the object
            by name in what is known as the CORBA <firstterm>Naming
            Service</firstterm>. The Naming Service has objects registered
            within its database, and clients request references from the
            database. When the reference is made available, methods may be
            invoked on it. Since the physical object resides in another memory
            space, this will create network traffic, though it is entirely
            transparent to the programmer.</para>

            <para>CORBA uses <glossterm linkend="gloss.orb">Object Request
            Brokers</glossterm> (ORBs) to manage locally registered objects
            and to communicate with remote objects. The remote objects are
            managed by ORBs that reside locally on the machines that have the
            servants. Two ORBs communicate with each other using a standard
            protocol. In this case, that protocol is the <glossterm
            linkend="gloss.iiop">Internet Inter-ORB Protocol</glossterm>
            (IIOP). IIOP is a new addition to Version 2.3 of the CORBA
            standard. It allows two ORBs written by different vendors to
            communicate and inter-operate. This capability is crucial to the
            correct functionality of Tweek and many other CORBA-based software
            systems.</para>

            <para>Within the scope of Tweek, CORBA is used to enable
            transparent communication between C++ applications and the Tweek
            Java GUI. C++ objects registered with a local ORB are made
            available to the Java GUI through the Subject Manager. Beyond
            this, CORBA exists mostly "behind the scenes" so that developers
            of Tweek-based software do not have to learn very much about
            CORBA. Programmers must understand the Interface Definition
            Language, however, and this is explained next.</para>

            <section id="intro.corba.idl.section">
               <title>Interface Definition Language</title>

               <para>The <glossterm linkend="gloss.idl">Interface Definition
               Language</glossterm> (IDL)<indexterm>
                     <primary>IDL</primary>
                  </indexterm> is used by the CORBA standard to define the
               <emphasis>interfaces</emphasis> for remotely accessible
               objects. An IDL file looks very much like a simple C++ class
               declaration in a header file, though data members are not
               allowed in the interface. Thus, IDL is used exclusively to
               define the methods of the objects and external data structures
               that may be passed as arguments to those methods.</para>

               <para>The interfaces alone are not sufficient to implement
               objects that may be handled by CORBA. A language-specific
               implementation must be written so that servants can be
               instantiated and registered with an ORB. To implement an
               interface, an <glossterm linkend="gloss.idl-compiler">IDL
               compiler</glossterm> must first be used to generate skeleton
               code for a specific language from the IDL file. Using the
               generated code, an implementation is then written. In <xref
               linkend="prog.idl.chapter" />, we explain in more detail how to
               use IDL to define interfaces.</para>
            </section>

            <section>
               <title>Supported Languages</title>

               <para>As discussed above, a very powerful feature of CORBA is
               its language independence. As of this writing, Tweek itself
               includes support for C++ and Java as the primary langauges.
               Support for generating the stub code needed to access Tweek
               Subjects through Python was added in early August 2003, and a
               PyQt-based GUI is being written so that developers can use
               Python and Qt for making GUI panels instead of Java. There is
               no restriction, other than time and resources, that prevents
               the addition of support for other languages. In this section,
               we explain how C++, Java, and Python are used in Tweek.</para>

               <section>
                  <title>C++</title>

                  <para>A key part of the overall Tweek design is that
                  complex, high-performance applications will be written in
                  C++. While this may not necessarily be the case in every
                  situation, this is the assumption made for the design and
                  implementation of the Tweek C++ API. As mentioned
                  previously, support could be added for other languages so
                  that they too may fulfill the role of C++ in Tweek.</para>

                  <section>
                     <title>C++ Subjects</title>

                     <para>Using the C++ API on the server side to create
                     subjects, programmers activate a local ORB using the
                     CORBA Manager. Once an ORB is available, servants that
                     will act as subjects can be registered with the Subject
                     Manager. The subjects are activated within the local POA
                     by the Subject Manager, thus alleviating some work for
                     programmers. Once activated, the subjects may be accessed
                     remotely through CORBA by code written in any
                     language—including C++.</para>
                  </section>

                  <section>
                     <title>C++ Observers</title>

                     <para>Using the C++ API on the client side to create
                     observers, programmers again activate a local ORB using
                     the CORBA Service. Once an ORB is available, servants
                     that will act as observers can be registered with the
                     local POA via the CORBA Service. Once activated, the
                     observers can be attached to remote subjects that may be
                     written in any langauge. C++ observer code is very
                     similar to Java observer code.</para>
                  </section>
               </section>

               <section>
                  <title>Java</title>

                  <para>In the Java programming language, the Swing API
                  provides developers with a very nice suite of classes for
                  writing cross-platform GUIs. When developing Tweek, we took
                  advantage of Swing and JavaBeans technology <xref
                  linkend="Jbe02" /> to write a generalized GUI framework.
                  Users can plug components (Beans) into this framework at
                  runtime to extend its functionality. The Beans can get
                  access to remote C++ objects through the CORBA services
                  provided by the Tweek Java API. Similar to the C++ API, the
                  use of CORBA in Java has been simplified so that programmers
                  can use it with little effort and without a comprehensive
                  understanding of CORBA in general.</para>

                  <para>Programmers will use Java as part of their Tweek
                  programming to write JavaBeans. Compared to the potential
                  complexity of the GUI code for Beans, little CORBA
                  programming must be done in Java. Beans may be as simple or
                  as complex as necessary to meet the needs of individual
                  projects. More information about JavaBeans is provided in
                  <xref linkend="intro.javabeans.chapter" />.</para>
               </section>

               <section>
                  <title>Python</title>

                  <para>With Python, we use PyQt <xref linkend="Pyq03" /> as
                  the GUI interface. PyQt is highly portable, and a GPL
                  version makes it easy to develop non-commercial,
                  high-performance user interfaces. Because PyQt wraps Qt
                  which in turn utilizes the native windowing system, user
                  interfaces developed with PyQt tend to perform much better
                  than Swing-based Java GUIs. Of course, natively compiled C++
                  that uses Qt directly would perform better still, but Python
                  provides a degree of portability not offered (directly) by
                  C++. We have used PyQt successfully to develop GUIs that run
                  on desktops as well as on PDAs that include Qtopia.</para>
               </section>
            </section>
         </section>
      </chapter>

      <chapter id="intro.javabeans.chapter">
         <title>JavaBeans</title>

         <para>The Tweek Java GUI uses JavaBeans to be more flexible and
         accessible to programmers. The GUI is a framework into which
         graphical and non-graphical components may be <quote>plugged</quote>.
         Graphical components add interaction functionality. Non-graphical
         components extend internal functionality, oftentimes needed by the
         graphical components. Conceptually, this follows the traditional use
         of plug-in architectures wherein the components are discovered
         dynamically and added into the larger framework. In the case of the
         Tweek Java GUI, the plug-ins will fit into one of four categories,
         the most important of which is <firstterm>Panel
         Bean</firstterm>.</para>

         <section>
            <title>Bean Categories</title>

            <para>There are four types of Beans that may be loaded by the
            Tweek Java GUI. They are categorized based on functionality and
            what is known about them in advance. The following lists the four
            categories in order of decreasing <foreignphrase>a
            priori</foreignphrase> knowledge.</para>

            <orderedlist>
               <listitem>
                  <para>Service Beans</para>
               </listitem>

               <listitem>
                  <para>Viewer Beans</para>
               </listitem>

               <listitem>
                  <para>Panel Beans</para>
               </listitem>

               <listitem>
                  <para>Generic Beans</para>
               </listitem>
            </orderedlist>

            <section>
               <title>Service Beans</title>

               <indexterm>
                  <primary>Service Beans</primary>
               </indexterm>

               <para>Services encapsulate functionality that may be useful to
               other parts of the Tweek system or dynamically loaded code. The
               entire interface for Service Beans must be known when the code
               using the service is compiled. This is because the using code
               needs to be able to take advantage of the service. Because
               Service Beans may be loaded dynamically, using code must be
               prepared for the case when the Bean containing the service was
               not found. In other words, code that uses services cannot
               necessarily assume that the service will be available.</para>

               <para>Not all services are loaded dynamically as Beans. Some
               services are loaded statically because they are needed by core
               components. These include the Environment Service and the
               Global Preferences Service. There is a guarantee that the code
               for these services will always be available. This guarantee is
               especially important because the Tweek core needs to add
               information to the Environment Service at startup. The Global
               Preferences Service is needed to configure the overall behavior
               of the Tweek GUI.</para>
            </section>

            <section>
               <title>Viewer Beans</title>

               <indexterm>
                  <primary>Viewer Beans</primary>
               </indexterm>

               <para>Viewer Beans provide a rendering of the tree of Panel
               Beans (discussed next). They provide the viewer component of
               the model/view pattern <xref linkend="Gam95" />. All Viewer
               Beans are loaded dynamically, and the active viewer can be
               changed at runtime by editing the global preferences. This
               feature is realized through the flexibility of the model/view
               pattern.</para>

               <para>Viewer Beans must implement the
               <interfacename>org.vrjuggler.tweek.beans.BeanModelViewer</interfacename>
               interface. To simplify implementation, they may be derived from
               <classname>org.vrjuggler.tweek.beans.DefaultBeanModelViewer</classname>,
               a class that implements aspects of the interface that are
               unlikely to vary between viewer implementations. The use of the
               interface is needed so that the GUI frame can assume certain
               behaviors about the viewer.</para>
            </section>

            <section>
               <title>Panel Beans</title>

               <indexterm>
                  <primary>Panel Beans</primary>
               </indexterm>

               <para>Most programmers using Tweek will write Panel Beans.
               These provide custom interfaces for whatever users need. In
               most cases, a Panel Bean will provide a graphical interface
               that can manipulate and/or control a C++ application, but
               developers are not strictly limited to this use.</para>

               <para>Only one assumption is made about Panel Beans: the
               primary class for the Bean must be a subclass of
               <classname>javax.swing.JComponent</classname>. Optionally, the
               primary class may implement one or more publicly provided
               interfaces that provide the Java GUI with more information
               about the capabilities of the Bean. When loaded, the GUI checks
               to see what, if any, interfaces are implemented by the Bean.
               Based on the results, special actions may be taken to provide
               the Bean with extended functionality.</para>

               <para>For example, Beans that can load files should implement
               <interfacename>org.vrjuggler.tweek.beans.FileLoader</interfacename>.
               When the Bean is focused in the viewer, the
               <guimenu>File</guimenu> menu will be modified to enable the
               <guimenuitem>Open</guimenuitem>,
               <guimenuitem>Save</guimenuitem>, and
               <guimenuitem>Close</guimenuitem> items. If the user selects one
               of these items, the Bean is informed and can take appropriate
               customized actions. The result in this case is context-specific
               loading and unloading of files.</para>
            </section>

            <section>
               <title>Generic Beans</title>

               <indexterm>
                  <primary>Generic Beans</primary>
               </indexterm>

               <para>Nothing at all is assumed about Generic Beans. This Bean
               category is provided so that other Beans can do their own
               dynamic code loading. For example, a Bean that uses a factory
               pattern may want to have the <quote>workers</quote> loaded
               dynamically based on some criteria. Thus, the functionality of
               the factory can be changed dynamically.</para>

               <para>The Tweek Java GUI does not use Generic Beans itself.
               These are provided more for users of the Tweek Java API. It is
               up to those programmers to decide how to handle the Generic
               Beans on a case-by-case basis.</para>
            </section>
         </section>

         <section>
            <title>XML</title>

            <indexterm>
               <primary>Bean descriptions</primary>

               <secondary>using XML</secondary>
            </indexterm>

            <para>All JavaBeans loaded by the Tweek Java GUI are describe by
            at least one <glossterm linkend="gloss.xml.main">XML</glossterm>
            file<indexterm>
                  <primary>XML</primary>
               </indexterm>. The XML file can contain information about many
            Beans or about a single Bean. The XML file itself is a
            <quote>beanlist</quote> document. The four Bean categories,
            described above, each have an XML element that has children giving
            information about the specific Bean. The elements are
            <sgmltag>&lt;service&gt;</sgmltag>,
            <sgmltag>&lt;viewer&gt;</sgmltag>,
            <sgmltag>&lt;guipanel&gt;</sgmltag>, and
            <sgmltag>&lt;generic&gt;</sgmltag>.</para>

            <para>All Bean XML entries must contain a
            <sgmltag>&lt;file&gt;</sgmltag> element. Through its
            <literal>source</literal> attribute, this element provides the
            path to the JAR file that contains the full Bean code. When
            specifying the JAR file path, environment variables may be used.
            They must use the syntax <envar>${ENV_VAR}</envar> (the curly
            braces are required). The <literal>class</literal> element gives
            the fully qualified name of the class stored within the JAR file
            that will be instantiated. The extension
            <filename>.class</filename> must not be specified. This is to
            allow the use of serialized classes which have the extension
            <filename>.ser</filename>. The Tweek Bean-loading code will figure
            out what is available and take the right actions.</para>

            <para>In addition to the <sgmltag>&lt;file&gt;</sgmltag> element,
            a &lt;dependencies&gt; element may be specified. Dependencies of
            the Bean may be named as external JAR files or other Beans may be
            listed therein. The &lt;dependencies&gt; element may contain zero
            of more elements of type &lt;jar&gt; and/or &lt;bean&gt;. The
            &lt;jar&gt; element has a single attribute,
            <literal>path</literal>, which gives the path (a semi-colon
            separated list of directories) where the JAR file may be found.
            The contents of the &lt;jar&gt; element defines the name of the
            JAR file. The &lt;bean&gt; element's contents defines the name of
            the Bean that the current Bean depends on.</para>

            <para>Of the four Bean categories, the XML for Panel Beans can
            contain the most information. In addition to the previously
            mentioned elements, Panel Bean entries may have two optional
            elements: <sgmltag>&lt;tree&gt;</sgmltag> and
            <sgmltag>&lt;icon&gt;</sgmltag>. The element
            <sgmltag>&lt;tree&gt;</sgmltag> specifies the path within the Bean
            tree hierarchy where the Panel Bean will be placed. The path is
            given as a /-separated list of directories. If the named path does
            not exist when the Bean is loaded, it will be created. The element
            <sgmltag>&lt;icon&gt;</sgmltag> names a custom icon for the Bean
            and a tool-tip. An example of a Panel Bean XML entry is shown in
            <xref linkend="PlexusGraphView.xml.example" />. Note that this is
            not the full file—it is only the
            <sgmltag>&lt;guipanel&gt;</sgmltag> element for a single
            Bean.</para>

            <example id="PlexusGraphView.xml.example">
               <title>PlexusGraphView.xml snippet</title>

               <programlisting>&lt;guipanel name="Graph View"&gt;
  &lt;file name="${PLX_BASE_DIR}/share/plexus/beans/PlexusGraphView.jar" 
        class="plx.graphview.GraphView" /&gt;
  &lt;tree path="/" /&gt;
  &lt;dependencies&gt;
    &lt;jar path="${PLX_BASE_DIR}/share/plexus/beans"&gt;openjgraph.jar&lt;/jar&gt;
    &lt;jar path="${PLX_BASE_DIR}/share/plexus/beans"&gt;jgraph.jar&lt;/jar&gt;
    &lt;jar path="${PLX_BASE_DIR}/share/plexus/beans"&gt;PlexusComm.jar&lt;/jar&gt;
  &lt;/dependencies&gt;
  &lt;icon source="jar:file:${PLX_BASE_DIR}/share/plexus/beans/PlexusGraphView.jar!/plx/graphview/icon.gif"
        tooltip="Plexus Network Graph Visualization" /&gt;
&lt;/guipanel&gt;</programlisting>
            </example>

            <para>This shows the use of all the elements that may be children
            of <sgmltag>&lt;guipanel&gt;</sgmltag>. Note that the
            <literal>source</literal> attribute of
            <sgmltag>&lt;icon&gt;</sgmltag> gets its icon image using a JAR
            URL.</para>

            <para>Another example XML file is shown in <xref
            linkend="Viewers.xml.example" />. This is the actual file used to
            load the two Viewer Beans that come with the Tweek distribution.
            This is a complete file containing two Viewer Bean entries.</para>

            <example id="Viewers.xml.example">
               <title>Viewers.xml</title>

               <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beanlist xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:noNamespaceSchemaLocation="http://www.vrjuggler.org/tweek/xsd/1.1/beanlist.xsd"&gt;
  &lt;viewer name="Tree Viewer"&gt;
    &lt;file name="${TWEEK_BASE_DIR}/share/tweek/beans/Viewers.jar" 
          class="org.vrjuggler.tweek.treeviewer.BeanTreeViewer" /&gt;
  &lt;/viewer&gt;
  &lt;viewer name="Icon Viewer"&gt;
    &lt;file name="${TWEEK_BASE_DIR}/share/tweek/beans/Viewers.jar" 
          class="org.vrjuggler.tweek.iconviewer.BeanIconViewer" /&gt;
  &lt;/viewer&gt;
&lt;/beanlist&gt;</programlisting>
            </example>
         </section>
      </chapter>
   </part>

   <part>
      <title>Programming</title>

      <partintro>
         <para>In the following chapters, we present the basic information
         needed to start programming with Tweek. There will be discussion
         covering IDL, C++, Java, and CORBA. To use Tweek effectively, a good
         understanding of C++ and Java is required. The IDL aspect of Tweek is
         minimal, and programmers familiar with basic object-oriented concepts
         should be able to understand IDL code easily. Discussion related to
         CORBA is based on the brief introduction given in <xref
         linkend="intro.corba.section" />. The Tweek Java and C++ APIs are
         designed to hide most CORBA details. Whenever possible, references
         are given to good sources of information on all of the aforementioned
         topics.</para>

         <para>Before proceeding, it is important to know that Tweek is
         designed and implemented to work with VR Juggler 1.1 and 2.0. It can
         be used with VR Juggler 1.0, but there have been reports of conflicts
         occurring between VR Juggler 1.0 and the VR Juggler Portable Runtime
         (VPR) that is part of VR Juggler 1.1. The Tweek C++ code uses VPR for
         threading, but it is possible to replace the VPR objects with VR
         Juggler 1.0 thread objects.</para>
      </partintro>

      <chapter id="prog.idl.chapter">
         <title>IDL</title>

         <para>In this chapter, we present the basic information needed to
         define interfaces that will be used by Tweek. This is not a detailed
         introduction to IDL programming. Readers are referred to <xref
         linkend="Hen99" />.</para>

         <para>IDL <quote>programming</quote> means defining <glossterm
         linkend="gloss.interface">interfaces</glossterm>. In the scope of
         Tweek and CORBA, the interfaces declare what operations may be
         performed on CORBA references. The arguments and return values may be
         of several basic types including, but not limited to,
         <type>string</type>, <type>int</type>, <type>long</type>, and
         <type>float</type>. These types are specified in a
         language-independent manner. When the IDL compiler generates the code
         for a specific language, the language-specific types that correspond
         to the IDL types are used.</para>

         <para>In <xref linkend="Subject.idl.example" />, we show the Tweek
         <interfacename>Subject</interfacename><indexterm>
               <primary>interfaces</primary>

               <secondary>tweek::Subject</secondary>
            </indexterm> interface. Note the similarity to a C++ header file.
         The IDL file can be included by other IDL files, and thus it must
         <quote>protect</quote> the contents in the same manner as a header
         file. The actual <interfacename>Subject</interfacename> interface is
         defined within the <literal>tweek</literal> module. An IDL module
         corresponds to a C++ namespace or to a Java package. The interface
         itself has three methods: <methodname>attach()</methodname>,
         <methodname>detach()</methodname>, and
         <methodname>notify()</methodname>. The first two take a read-only
         argument of type <interfacename>Observer</interfacename>. The fact
         that the argument is read-only (to the server) is specified by the
         <literal>in</literal> modifier. Other modifiers are
         <literal>out</literal> (sent from server to client) and
         <literal>inout</literal> (initialized by the client, writable by the
         server). The third method, <methodname>notify()</methodname>, takes
         no arguments, and none of the methods have a return type.</para>

         <example id="Subject.idl.example">
            <title>Subject.idl</title>

            <indexterm>
               <primary>tweek::Subject</primary>

               <secondary>IDL definition</secondary>
            </indexterm>

            <programlisting>#ifndef _TWEEK_SUBJECT_IDL_
#define _TWEEK_SUBJECT_IDL_

#include &lt;tweek/idl/Observer.idl&gt;

module tweek
{

interface Subject
{
   void attach(in Observer o);
   void detach(in Observer o);
   void notify();
};

};

#endif</programlisting>
         </example>

         <para>By definition, all objects are passed by reference in CORBA.
         The modifier stating the readability and/or writability in the IDL
         file determines how the referenced object may be modified, if at all,
         within the method.</para>

         <para>Applications that make use of Tweek will define custom
         interfaces that extend the <interfacename>Subject</interfacename>
         interface. For example, consider a custom subject that maintains a
         floating-point value. It could have the following interface:</para>

         <example id="CustomSubject.idl.example">
            <title>CustomSubject.idl</title>

            <programlisting>#ifndef _CUSTOM_SUBJECT_IDL_
#define _CUSTOM_SUBJECT_IDL_

#include &lt;tweek/idl/Subject.idl&gt;

module mymod
{

interface CustomSubject : tweek::Subject
{
   float getValue();
   void setValue(in float v);
};

};

#endif</programlisting>
         </example>

         <para>In this interface, we define two methods:
         <methodname>getValue()</methodname> and
         <methodname>setValue()</methodname>. The implementation of this
         interface would of course include these methods and would derive from
         the implementation of the <interfacename>Subject</interfacename>
         interface.</para>
      </chapter>

      <chapter id="prog.cplusplus.chapter">
         <title>C++</title>

         <indexterm>
            <primary>C++ server API</primary>
         </indexterm>

         <para>Writing C++ code that makes use of Tweek is not difficult,
         though it often requires some good planning. With the current code
         base, the C++ side of things maintains the state information through
         an implementation of the Tweek
         <interfacename>Subject</interfacename><indexterm>
               <primary>interfaces</primary>

               <secondary>tweek::Subject</secondary>
            </indexterm> interface. Instances of such an implementation may
         need to communicate with other parts of a given application, and it
         is important to define these relationships well. In other words, as a
         maintainer of application state information, the subject
         implementation should have easy access to that state
         information.</para>

         <para>Furthermore, developers must keep in mind that there may be
         asynchronous execution of application code as a result of using
         Tweek. The local ORB runs in its own thread, and as such, it executes
         methods of <glossterm linkend="gloss.servant">servants</glossterm>
         from that thread. Whatever the servant does, it should be thread-safe
         with respect to the rest of the application.</para>

         <para>In this chapter, we cover each aspect of writing C++ code that
         uses the Tweek API. We begin by explaining how to make a custom
         subject implementation. Then, we discuss the use of the CORBA Manager
         from user-level code. We conclude the chapter with an overview of
         using the Subject Manager.</para>

         <section>
            <title>Deriving from
            <classname>tweek::SubjectImpl</classname></title>

            <indexterm>
               <primary>tweek::SubjectImpl</primary>

               <secondary>deriving from</secondary>
            </indexterm>

            <para>To create a custom subject implementation, you must derive
            from two classes: the abstract class that defines the custom
            interface and <classname>tweek::SubjectImpl</classname>. Referring
            back to the interface shown in <xref
            linkend="CustomSubject.idl.example" />, the basic C++ class
            declaration would appear as follows:</para>

            <example id="CustomSubjectImpl.h.example">
               <title>CustomSubjectImpl.h</title>

               <programlisting linenumbering="numbered">#ifndef _CUSTOM_SUBJECT_IMPL_H_
#define _CUSTOM_SUBJECT_IMPL_H_

#include &lt;tweek/CORBA/SubjectImpl.h&gt;
#include &lt;CustomSubject.h&gt;

namespace mymod
{

class CustomSubjectImpl : public POA_mymod::CustomSubject,      <co
                     id="CustomSubjectImpl.interface.line"
                     linkends="CustomSubjectImpl.superclass.co" />
                          public tweek::SubjectImpl             <co
                     id="CustomSubjectImpl.SubjectImpl.line"
                     linkends="CustomSubjectImpl.superclass.co" />
public:
   CustomSubjectImpl() : mValue(0.0f)
   {
      ;
   }

   virtual ~CustomSubjectImpl()
   {
      ;
   }

   virtual float getValue();                                    <co
                     id="CustomSubjectImpl.setValue.decl"
                     linkends="CustomSubjectImpl.interface.methods.co" />

   virtual void setValue(float v);                              <co
                     id="CustomSubjectImpl.getValue.decl"
                     linkends="CustomSubjectImpl.interface.methods.co" />

   mymod::CustomSubject_ptr _this()                             <co
                     id="CustomSubjectImpl._this.decl"
                     linkends="CustomSubjectImpl._this.hack.co" />
   {
      return POA_mymod::CustomSubject::_this();
   }

private:
   float mValue;
};

}

#endif</programlisting>

               <calloutlist>
                  <callout arearefs="CustomSubjectImpl.interface.line CustomSubjectImpl.SubjectImpl.line"
                           id="CustomSubjectImpl.superclass.co">
                     <para>Here we declare our parent classes,
                     <classname>POA_mymod::CustomSubject</classname> and
                     <classname>tweek::SubjectImpl</classname>. The first is
                     code generated by the IDL compiler, and the second is
                     included as part of the Tweek C++ API. Both are necessary
                     for this custom interface to work correctly as a Tweek
                     subject.</para>
                  </callout>

                  <callout arearefs="CustomSubjectImpl.setValue.decl CustomSubjectImpl.getValue.decl"
                           id="CustomSubjectImpl.interface.methods.co">
                     <para>These two declarations correspond to the
                     <interfacename>CustomSubject</interfacename> interface
                     defined in <xref linkend="CustomSubject.idl.example" />.
                     The implementations of these methods are not shown here,
                     but they are required for the code to compile. That is,
                     the declarations in
                     <classname>POA_mymod::CustomSubject</classname> are pure
                     virtual methods, and an instance of
                     <classname>mymod::CustomSubjectImpl</classname> cannot be
                     created unless these methods are implemented.</para>
                  </callout>

                  <callout arearefs="CustomSubjectImpl._this.decl"
                           id="CustomSubjectImpl._this.hack.co">
                     <para>Overriding the method named
                     <methodname>_this()</methodname> is required due to the
                     diamond inheritance tree created by deriving from
                     <classname>POA_mymod::CustomSubject</classname> and
                     <classname>tweek::SubjectImpl</classname>. Both of these
                     classes derive from
                     <classname>tweek::Subject</classname>. The
                     <methodname>_this()</methodname> method plays a critical
                     role in the CORBA communication, and it is imperative
                     that it return the correct type to the caller when
                     invoked on a servant instance. Without this override, the
                     returned type will be
                     <classname>tweek::Subject_ptr</classname>, and attempts
                     to narrow to
                     <classname>mymod::CustomSubject_ptr</classname> will
                     fail.</para>

                     <para>Note the namespaces used on this method. The return
                     type is <classname>mymod::CustomSubject_ptr</classname>,
                     which corresponds to the namespace in which the classes
                     <classname>CustomSubjectImpl</classname> and
                     <classname>CustomSubject</classname> are defined. To get
                     the actual value to return,
                     <classname>POA_mymod::CustomSubject</classname> (one of
                     the two parent classes) is used.</para>
                  </callout>
               </calloutlist>
            </example>

            <para>The implementations of <methodname>getValue()</methodname>
            and <methodname>setValue()</methodname> are fairly obvious, though
            they are presented here for the sake of completeness. Note,
            however, that <methodname>setValue()</methodname> changes the
            state of the subject, and thus any observers must be notified of
            the change. The implementations are shown in the following
            example.</para>

            <example>
               <title>CustomSubjectImpl.cpp</title>

               <programlisting>#include &lt;CustomSubjectImpl.h&gt;

namespace mymod
{

float CustomSubjectImpl::getValue()
{
   return mValue;
}

void CustomSubjectImpl::setValue(float v)
{
   mValue = v;
   tweek::SubjectImpl::notify();
}

}</programlisting>
            </example>

            <para>The key point to note is the call to
            <methodname>tweek::SubjectImpl::notify()</methodname> in the
            <methodname>setValue()</methodname> implementation. In general,
            anything that modifies the state of the subject requires that this
            method be invoked. Note also that the method is fully qualified so
            that we are sure to call the correct implementation.</para>
         </section>

         <section>
            <title>Using the CORBA Manager</title>

            <indexterm>
               <primary>CORBA Manager</primary>

               <secondary>use of</secondary>
            </indexterm>

            <para>Initializing the CORBA Manager is straightforward, but it
            does require exception handling. If the exceptions are not handled
            correctly, applications will abort if an exception is thrown but
            not caught. Refer to a C++ reference for more information about
            exceptions and exception handling in C++.</para>

            <para>With Tweek 1.3.4 and newer, there are two ways to initialize
            the CORBA Manager. The choice of which initialization approach to
            use impacts how client-side code makes the connection to the
            Subject Manager. The ways to initialize the CORBA Manager are as
            follows:</para>

            <orderedlist>
               <listitem>
                  <para>Initialize to use the CORBA Naming Service. This is
                  the <quote>normal</quote> way that the Tweek CORBA Manager
                  has been initialized since Tweek was first written. It is a
                  perfectly valid way to use CORBA, although many people find
                  the indirection introduced by the CORBA Naming Service (it
                  runs as a separate process about which both the server side
                  and the client side must have knowledge) to be a
                  hassle.</para>
               </listitem>

               <listitem>
                  <para>Initialize to use direct connections to the Subject
                  Manager. This capability, while not at all new to CORBA, is
                  new in Tweek 1.3.5. Using this approach, there need not be a
                  CORBA Naming Service at all. Instead, the client connects
                  directly to the Subject Manager on the GIOP end point using
                  a <literal>corbaloc</literal> URI. The simplicity of this
                  approach offers a key benefit over the use of the CORBA
                  Naming Service. However, if there are multiple CORBA Manager
                  instances running in a single memory space, each must have
                  its end point port number set to a different value. Such a
                  detail, while still critical in any event, would be hidden
                  by the use of the CORBA Naming Service.</para>
               </listitem>
            </orderedlist>

            <para>We next provide code examples of both ways to initialize the
            Tweek CORBA Manager.</para>

            <section>
               <title>Connections Through the CORBA Naming Service</title>

               <para>The following example shows a <function>main()</function>
               function for an application that performs all the Tweek
               initialization steps. We separate the discussion into two
               parts: one part for the CORBA Manager and one part for the
               Subject Manager (discussed in the next section).</para>

               <example id="TweekApp.cpp.CORBA-Manager.naming.example">
                  <title><filename>TweekApp.cpp</filename>: CORBA Naming
                  Service Usage</title>

                  <programlisting linenumbering="numbered">#include &lt;vpr/vpr.h&gt;
#include &lt;vpr/Thread/Thread.h&gt;
#include &lt;vpr/Util/Debug.h&gt;
#include &lt;tweek/CORBA/CorbaManager.h&gt;                         <co
                        id="TweekApp.cpp.includes.tweek"
                        linkends="TweekApp.cpp.includes.co" />

#include &lt;CustomSubjectImpl.h&gt;                                <co
                        id="TweekApp.cpp.includes.gen"
                        linkends="TweekApp.cpp.includes.co" />

/**
 * This application starts the CORBA server for the C++ side
 * of the test.
 */
int main(int argc, char* argv[])
{
   tweek::CorbaManager mgr;                                   <co
                        id="TweekApp.cpp.corbamgr.decl"
                        linkends="TweekApp.cpp.corbamgr.decl.co" />

   // The first thing we have to do is initialize the Tweek
   // CORBA Manager.  If this fails, we're out of luck.
   try                                                        <co
                        id="TweekApp.cpp.big-try-catch.try"
                        linkends="TweekApp.cpp.big-try-catch.co" />
   {
      // Initialize the CORBA Manager to use the CORBA
      // Naming Service to connect to the Subject Manager.
      if ( mgr.init("example", argc, argv) )                  <co
                        id="TweekApp.cpp.corbamgr.init"
                        linkends="TweekApp.cpp.corbamgr.init.co" />
      {
         bool status(false);

         // Once the CORBA Manager is initialized, we need
         // to create a Subject Manager.  This will hold our
         // CustomSubject object.
         try
         {
            status = mgr.createSubjectManager();

            // If we were able to create the Subject Manager,
            // now we register our objects with it.
            if ( status )
            {
               // First, create real instances of the C++
               // object that will be the CORBA servant.  This
               // must be allocated on the heap.
               mymod::CustomubjectImpl* custom_subj =
                  new mymod::CustomSubjectImpl();

               // Now we try to register the subject and give
               // it a symbolic, easy-to-remember name.
               try
               {
                  mgr.getSubjectManager()-&gt;
                     registerSubject(slider_subj, "CustomSubject");
               }
               catch (...)
               {
                  vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
                     &lt;&lt; "Failed to register subject\n"
                     &lt;&lt; vprDEBUG_FLUSH;
               }

               // We are done with our pointer to the servant.
               slider_subj-&gt;_remove_ref();
            }
         }
         catch (CORBA::Exception&amp; ex)
         {
            vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
               &lt;&lt; "Caught an unknown CORBA exception when "
               &lt;&lt; "trying to register!\n" &lt;&lt; vprDEBUG_FLUSH;
         }

         if ( ! status )
         {
            vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
               &lt;&lt; "Failed to register Subject Manager instance\n"
               &lt;&lt; vprDEBUG_FLUSH;
         }

         std::cout &lt;&lt; "Press 'x' to exit" &lt;&lt; std::endl;
         char input;

         // Loop forever so that we can act sort of like
         // a server.
         while ( 1 )
         {
            std::cin &gt;&gt; input;
            if ( input == 'x' )
            {
               break;
            }
            else
            {
               vpr::System::msleep(100);
            }
         }
      }
      else
      {
         vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
            &lt;&lt; "CORBA failed to initialize\n"
            &lt;&lt; vprDEBUG_FLUSH;
      }
   }
   catch (...)                                               <co
                        id="TweekApp.cpp.big-try-catch.catch"
                        linkends="TweekApp.cpp.big-try-catch.co" />
   {
      vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
         &lt;&lt; "Caught an unknown exception!\n"
         &lt;&lt; vprDEBUG_FLUSH;
   }

   vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
      &lt;&lt; "Exiting\n" &lt;&lt; vprDEBUG_FLUSH;

   return 0;
}</programlisting>

                  <calloutlist>
                     <callout arearefs="TweekApp.cpp.includes.tweek TweekApp.cpp.includes.gen"
                              id="TweekApp.cpp.includes.co">
                        <para>These two headers are typically needed. The
                        first includes the declaration of the Tweek CORBA
                        Manager, and the second is the subject implementation
                        declaration, shown in <xref
                        linkend="CustomSubjectImpl.h.example" />.</para>
                     </callout>

                     <callout arearefs="TweekApp.cpp.corbamgr.decl"
                              id="TweekApp.cpp.corbamgr.decl.co">
                        <para>In order to use CORBA through Tweek, the CORBA
                        Manager must be created and initialized. Any number of
                        these may be created, but in general, only one is
                        needed per application. Here, we declare an instance
                        of <classname>tweek::CorbaManager</classname> on the
                        stack.</para>
                     </callout>

                     <callout arearefs="TweekApp.cpp.corbamgr.init"
                              id="TweekApp.cpp.corbamgr.init.co">
                        <para>Next, we must initialize the CORBA Manager using
                        the method
                        <methodname>tweek::CorbaManager::init()</methodname>.
                        The first argument provides a unique (ideally)
                        identifier for the local Portable Object Adapter
                        (POA). The second and third arguments are
                        <varname>argc</varname> and <varname>argv</varname>
                        respectively. They come in through the argument list
                        of <function>main()</function> and represent the
                        command-line arguments. Any arguments relevant to ORB
                        initialization are removed from
                        <varname>argv</varname>, and <varname>argc</varname>
                        is decremented accordingly (it is passed by
                        reference).</para>
                     </callout>

                     <callout arearefs="TweekApp.cpp.big-try-catch.try TweekApp.cpp.big-try-catch.catch"
                              id="TweekApp.cpp.big-try-catch.co">
                        <para>To ensure that no exceptions go uncaught, we
                        enclose the bulk of <function>main()</function> in a
                        try/catch block that catches any exception. This is
                        handled by the argument list passed to the catch
                        block, <literal>(...)</literal>. This is the
                        equivalent of catching
                        <classname>java.lang.Exception</classname> in
                        Java.</para>
                     </callout>
                  </calloutlist>
               </example>
            </section>

            <section>
               <title>Direct Subject Manager Connections</title>

               <para>Just as in the previous subsection, the following example
               shows a <function>main()</function> function for an application
               that performs all the Tweek initialization steps. The code is
               nearly identical except for one key difference: we invoke
               <methodname>tweek::CorbaManager::initDirect()</methodname>
               instead of
               <methodname>tweek::CorbaManager::init()</methodname>. See the
               call-out after the example code for more details.</para>

               <example id="TweekApp.cpp.CORBA-Manager.direct.example">
                  <title><filename>TweekApp.cpp</filename>: Direct Object
                  Connection</title>

                  <programlisting linenumbering="numbered">#include &lt;vpr/vpr.h&gt;
#include &lt;vpr/Thread/Thread.h&gt;
#include &lt;vpr/Util/Debug.h&gt;
#include &lt;tweek/CORBA/CorbaManager.h&gt;

#include &lt;CustomSubjectImpl.h&gt;

/**
 * This application starts the CORBA server for the C++ side
 * of the test.
 */
int main(int argc, char* argv[])
{
   tweek::CorbaManager mgr;

   // The first thing we have to do is initialize the Tweek
   // CORBA Manager.  If this fails, we're out of luck.
   try
   {
      // Initialize the CORBA Manager to use a direct
      // connection to the Subject Manager.  The GIOP end
      // point will be bound to port 12345 on the default
      / network interface.
      if ( mgr.initDirect("example", argc, argv, "", 12345) ) <co
                        id="TweekApp.cpp.mgr.initDirect.gen"
                        linkends="TweekApp.cpp.corbamgr.init.co" />
      {
         bool status(false);

         // Once the CORBA Manager is initialized, we need
         // to create a Subject Manager.  This will hold our
         // CustomSubject object.
         try
         {
            status = mgr.createSubjectManager();

            // If we were able to create the Subject Manager,
            // now we register our objects with it.
            if ( status )
            {
               // First, create real instances of the C++
               // object that will be the CORBA servant.  This
               // must be allocated on the heap.
               mymod::CustomubjectImpl* custom_subj =
                  new mymod::CustomSubjectImpl();

               // Now we try to register the subject and give
               // it a symbolic, easy-to-remember name.
               try
               {
                  mgr.getSubjectManager()-&gt;
                     registerSubject(slider_subj, "CustomSubject");
               }
               catch (...)
               {
                  vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
                     &lt;&lt; "Failed to register subject\n"
                     &lt;&lt; vprDEBUG_FLUSH;
               }

               // We are done with our pointer to the servant.
               slider_subj-&gt;_remove_ref();
            }
         }
         catch (CORBA::Exception&amp; ex)
         {
            vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
               &lt;&lt; "Caught an unknown CORBA exception when "
               &lt;&lt; "trying to register!\n" &lt;&lt; vprDEBUG_FLUSH;
         }

         if ( ! status )
         {
            vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
               &lt;&lt; "Failed to register Subject Manager instance\n"
               &lt;&lt; vprDEBUG_FLUSH;
         }

         std::cout &lt;&lt; "Press 'x' to exit" &lt;&lt; std::endl;
         char input;

         // Loop forever so that we can act sort of like
         // a server.
         while ( 1 )
         {
            std::cin &gt;&gt; input;
            if ( input == 'x' )
            {
               break;
            }
            else
            {
               vpr::System::msleep(100);
            }
         }
      }
      else
      {
         vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
            &lt;&lt; "CORBA failed to initialize\n"
            &lt;&lt; vprDEBUG_FLUSH;
      }
   }
   catch (...)
   {
      vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
         &lt;&lt; "Caught an unknown exception!\n"
         &lt;&lt; vprDEBUG_FLUSH;
   }

   vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
      &lt;&lt; "Exiting\n" &lt;&lt; vprDEBUG_FLUSH;

   return 0;
}</programlisting>

                  <calloutlist>
                     <callout arearefs="TweekApp.cpp.mgr.initDirect.gen"
                              id="TweekApp.cpp.initDirect.co">
                        <para>This is the only difference in the code with
                        respect to the example shown in <xref
                        linkend="TweekApp.cpp.CORBA-Manager.naming.example" />.
                        Instead of using
                        <methodname>tweek::CorbaManager::init()</methodname>,
                        we call
                        <methodname>tweek::CorbaManager::initDirect()</methodname>
                        and provide the address and port number for the GIOP
                        end point. In this case, we have used an empty string
                        for the end point address to indicate that we want to
                        bind to the default network interface.</para>
                     </callout>
                  </calloutlist>
               </example>

               <para>The above example sets the GIOP end point address and
               port number explicitly through the
               <varname>endPointAddress</varname> and
               <varname>endPointPort</varname> parameters of the
               <methodname>tweek::CorbaManager::initDirect()</methodname>
               method. These parameters, however, are optional. If
               <varname>endPointPort</varname> is 0 (the default), then the
               code falls back on expecting the user to have configured the
               GIOP end point through an omniORB configuration file. In that
               case, the configuration file must be identified through the
               <envar>OMNIORB_CONFIG</envar> environment variable. Without
               doing so, omniORB would use a randomly assigned free port for
               the GIOP end point, and it would be difficult, though not
               impossible, to make the direct connection. There is a lot of
               flexibility offered in configuring the GIOP end point address
               through the omniORB configuration file, and interested readers
               are referred to the <ulink
               url="http://omniorb.sourceforge.net/docs.html">omniORB 4.x
               documentation</ulink> for more information. Furthermore, the
               example <filename>omniORB4.cfg</filename> that comes with Tweek
               includes a long explanation of how to configure the GIOP end
               point address.</para>

               <caution>
                  <para>It is still possible to end up with no explicit GIOP
                  end point address set when relying on
                  <filename>omniORB4.cfg</filename>. If tne
                  <literal>endPoint</literal> property is not assigned a
                  value, then omniORB will still use the randomly assigned
                  free port number for the end piont listening address.</para>
               </caution>
            </section>
         </section>

         <section>
            <title>Using the Subject Manager</title>

            <indexterm>
               <primary>Subject Manager</primary>

               <secondary>use of</secondary>
            </indexterm>

            <para>To demonstrate use of the Subject Manager, we begin by
            revisiting the <function>main()</function> function examined in
            the previous section. This time, we will focus our attention on
            the code related to the Subject Manager only. We will also explain
            how to use the extended API of the Subject Manager
            implementation.</para>

            <para>It is important to know that the Subject Manager is a CORBA
            object that can be accessed by remote code. In the following
            example, the methods used are defined in the class
            <classname>tweek::SubjectManagerImpl</classname>, the C++
            implementation of the
            <interfacename>tweek::SubjectManager</interfacename> interface.
            The details of how the Subject Manager is handled through CORBA
            are largely irrelevant for most users of Tweek. Simply bear in
            mind that the Subject Manager is accessibly remotely and that it
            simplifies the use of CORBA in general.</para>

            <section>
               <title>Subject Manager Initialization</title>

               <para>In order to use the Tweek Subject Manager, it must be
               initialized. Each CORBA Manager should have a single Subject
               Manager associated with it. If not, use of Tweek will be much
               more difficult because the CORBA Manager and the Subject
               Manager together hide most of the details relating to the use
               of CORBA. The following example shows how to initialize the
               Subject Manager using the CORBA Manager object created
               earlier.</para>

               <note>
                  <para>The example code shown below uses the CORBA Naming
                  Service initialization approach for the CORBA Manager. It
                  could just as easily use the direct object connection
                  approach by invoking
                  <methodname>tweek::CorbaManager::initDirect()</methodname>
                  instead.</para>
               </note>

               <example id="TweekApp.cpp.Subject-Manager.example">
                  <title><filename>TweekApp.cpp</filename>: Subject Manager
                  Initialization</title>

                  <programlisting linenumbering="numbered">#include &lt;vpr/vpr.h&gt;
#include &lt;vpr/Thread/Thread.h&gt;
#include &lt;vpr/Util/Debug.h&gt;
#include &lt;tweek/CORBA/CorbaManager.h&gt;

#include &lt;CustomSubjectImpl.h&gt;

/**
 * This application starts the CORBA server for the C++ side of
 * the test.
 */
int main(int argc, char* argv[])
{
   tweek::CorbaManager mgr;

   // The first thing we have to do is initialize the Tweek
   // CORBA Manager.  If this fails, we're out of luck.
   try
   {
      if ( mgr.init("corba_test", argc, argv) )
      {
         bool status(false);

         // Once the CORBA Manager is initialized, we need to
         // create a Subject Manager.  This will hold our
         // CustomSubject object.
         try
         {
            status = mgr.createSubjectManager();              <co
                        id="TweekApp.cpp.subjectmgr.create"
                        linkends="TweekApp.cpp.subjectmgr.create.co" />

            // If we were able to create the Subject Manager,
            // now we register our objects with it.
            if ( status )
            {
               // First, create real instances of the C++
               // object that will be the CORBA servant.  This
               // must be allocated on the heap.
               mymod::CustomubjectImpl* custom_subj =
                  new mymod::CustomSubjectImpl();             <co
                        id="TweekApp.cpp.subject.create"
                        linkends="TweekApp.cpp.subject.create.co" />

               // Now we try to register the subject and give
               // it a symbolic, easy-to-remember name.
               try
               {
                  mgr.getSubjectManager()-&gt;
                     registerSubject(custom_subj,
                                     "CustomSubject");        <co
                        id="TweekApp.cpp.subject.register"
                        linkends="TweekApp.cpp.subject.register.co" />
               }
               catch (...)
               {
                  vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
                     &lt;&lt; "Failed to register subject\n"
                     &lt;&lt; vprDEBUG_FLUSH;
               }

               // We are done with our pointer to the servant.
               custom_subj-&gt;_remove_ref();
            }
         }
         catch (CORBA::Exception&amp; ex)
         {
            vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
               &lt;&lt; "Caught an unknown CORBA exception when "
               &lt;&lt; "trying to register!\n"
               &lt;&lt; vprDEBUG_FLUSH;
         }

         if ( ! status )
         {
            vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
               &lt;&lt; "Failed to register Subject Manager instance\n"
               &lt;&lt; vprDEBUG_FLUSH;
         }

         std::cout &lt;&lt; "Press 'x' to exit" &lt;&lt; std::endl;
         char input;

         // Loop forever so that we can act sort of like
         // a server.
         while ( 1 )                                          <co
                        id="TweekApp.cpp.loop" linkends="TweekApp.cpp.loop.co" />
         {
            std::cin &gt;&gt; input;
            if ( input == 'x' )
            {
               break;
            }
            else
            {
               vpr::System::msleep(100);
            }
         }
      }
      else
      {
         vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
            &lt;&lt; "CORBA failed to initialize\n" &lt;&lt; vprDEBUG_FLUSH;
      }
   }
   catch (...)
   {
      vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
         &lt;&lt; "Caught an unknown exception!\n" &lt;&lt; vprDEBUG_FLUSH;
   }

   vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
      &lt;&lt; "Exiting\n" &lt;&lt; vprDEBUG_FLUSH;

   return 0;
}</programlisting>

                  <calloutlist>
                     <callout arearefs="TweekApp.cpp.subjectmgr.create"
                              id="TweekApp.cpp.subjectmgr.create.co">
                        <para>After the COBRA Manager has been initialized
                        successfully, the Tweek Subject Manager must be
                        created. We do this by invoking the method
                        <methodname>tweek::CorbaManager::createSubjectManager()</methodname>
                        on our <methodname>tweek::CorbaManager</methodname>
                        instance.</para>
                     </callout>

                     <callout arearefs="TweekApp.cpp.subject.create"
                              id="TweekApp.cpp.subject.create.co">
                        <para>Once we have a valid Subject Manager, we must
                        register subjects with it in order for object
                        references to be passed out by CORBA. This creates the
                        <glossterm linkend="gloss.servant">servant</glossterm>
                        to which
                        <interfacename>mymod::CustomSubject</interfacename>
                        references will be made.</para>
                     </callout>

                     <callout arearefs="TweekApp.cpp.subject.register"
                              id="TweekApp.cpp.subject.register.co">
                        <para>Once the servant is created, it is registered
                        with the Subject Manager. The Subject Manager will
                        activate the servant within the POA so that references
                        to it can be created and returned to clients. We
                        register it with the symbolic name
                        <quote>CustomSubject</quote> that can be referenced
                        later by remote objects.</para>
                     </callout>

                     <callout arearefs="TweekApp.cpp.loop"
                              id="TweekApp.cpp.loop.co">
                        <para>After the subject is registered, all the work is
                        done. This simple application now just waits for
                        clients to request references. It will exit when the
                        user enters '<literal>x</literal>'.</para>
                     </callout>
                  </calloutlist>
               </example>

               <para>Note that all the code relating to the Subject Manager is
               enclosed within another try/catch block. This block only
               catches exceptions of type
               <classname>CORBA::Exception</classname>. Anything more general
               is caught by the larger try/catch block.</para>
            </section>

            <section>
               <title>tweek::SubjectManagerImpl API</title>

               <para>The class
               <classname>tweek::SubjectManagerImpl</classname> has some
               methods that are not part of the IDL-specified interface. One
               such method is <methodname>registerSubject()</methodname>,
               which was used in the preceding example. Some other methods
               that may be of interest to users are described in the following
               subsections.</para>

               <sidebar>
                  <para>The methods described below are used for adding
                  information to the Subject Manager to help identify a
                  specific Subject Manager instance when connecting a client
                  application to the Subject Manager servant. This really only
                  comes to bear when using the CORBA Naming Service as a site
                  may have a single Naming Service running with which multiple
                  Subject Manager servants may be registered simultaneously.
                  In that event, the user of the client software would need a
                  way to identify the Subject Manager servant of interest.
                  When using direct Subject Manager connections instead of the
                  Naming Service, there is no need to worry about this
                  because, presumably, the user of the client software knows
                  the GIOP end point address of interest.</para>
               </sidebar>

               <section>
                  <title><methodname>setApplicationName()</methodname></title>

                  <indexterm>
                     <primary>tweek::SubjectManagerImpl</primary>

                     <secondary>setApplicationName() method</secondary>
                  </indexterm>

                  <methodsynopsis>
                     <modifier>public</modifier>

                     <type>void</type>

                     <methodname>setApplicationName</methodname>

                     <methodparam>
                        <type>const std::string&amp;</type>

                        <parameter>appName</parameter>
                     </methodparam>
                  </methodsynopsis>

                  <para>This method can be used to set one of the
                  application-specific identifiers within the Subject Manager.
                  Namely, it sets the application name identifier. These
                  identifiers are used to aid users in choosing a Subject
                  Manager instance when making remote connections to
                  applications.</para>
               </section>

               <section>
                  <title><methodname>setUserName()</methodname></title>

                  <indexterm>
                     <primary>tweek::SubjectManagerImpl</primary>

                     <secondary>setUserName() method</secondary>
                  </indexterm>

                  <methodsynopsis>
                     <modifier>public</modifier>

                     <type>void</type>

                     <methodname>setUserName</methodname>

                     <methodparam>
                        <type>const std::string&amp;</type>

                        <parameter>userName</parameter>
                     </methodparam>
                  </methodsynopsis>

                  <para>Similar to
                  <methodname>setApplicationName()</methodname>, this method
                  allows users to tell the Subject Manager their user name.
                  When multiple users are all running the same application
                  (and are thus using the same parameter to
                  <methodname>setApplicationName()</methodname>), this
                  provides another level of uniqueness. If this method is not
                  used, the Subject Manager will try to get the user name
                  through the <envar>$USER</envar> environment
                  variable.</para>
               </section>

               <section>
                  <title><methodname>addInfoItem()</methodname></title>

                  <indexterm>
                     <primary>tweek::SubjectManagerImpl</primary>

                     <secondary>addInfoItem() method</secondary>
                  </indexterm>

                  <methodsynopsis>
                     <modifier>public</modifier>

                     <type>void</type>

                     <methodname>addInfoItem</methodname>

                     <methodparam>
                        <type>const std::string&amp;</type>

                        <parameter>key</parameter>
                     </methodparam>

                     <methodparam>
                        <type>const std::string&amp;</type>

                        <parameter>value</parameter>
                     </methodparam>
                  </methodsynopsis>

                  <para>If the previous two built-in Subject Manager
                  identifiers are not enough, the method
                  <methodname>addInfoItem()</methodname> allows users to
                  define their own unique identifiers. The first parameter is
                  the identifier, and the second is its (ideally) unique
                  value. Users are free to add any key/value pairs they need
                  in order to aid in the selection of a Subject Manager at
                  runtime.</para>
               </section>
            </section>
         </section>
      </chapter>

      <chapter id="prog.java.chapter">
         <title>Java</title>

         <indexterm>
            <primary>Java client API</primary>
         </indexterm>

         <para>In this chapter, we present the libraries that make up the
         Tweek Java API. In general, we only provide a general overview of the
         libraries. Interested readers are referred to the Tweek
         <emphasis>Java Programmer's Reference</emphasis> for more
         comprehensive documentation.</para>

         <para>The Tweek Java API is broken up into a collection of Java class
         libraries, each packaged in a unique JAR file. Programmers can choose
         the library or libraries they need when writing Java code that uses
         Tweek. It is possible to write JavaBeans that do not use any of the
         Tweek Java libraries, but such Beans may not be very full-featured.
         On the other hand, because the Tweek Java GUI is capable of loading
         any JavaBean, there is no reason that a fully functional Bean must be
         written to take advantage of Tweek services and utilities.</para>

         <section id="gui.library.section">
            <title>GUI Library</title>

            <indexterm>
               <primary>Java libraries</primary>

               <secondary>GUI</secondary>
            </indexterm>

            <para>The GUI Library contains the heart of the Tweek Java GUI.
            Indeed, this library is what contains the Tweek Java GUI, and it
            makes use of all the other Tweek Java libraries to do its job. In
            general, there is not much code in this library that is of
            interest to Bean developers. The lone exception is the singleton
            <classname>org.vrjuggler.tweek.gui.MessagePanel</classname>. This
            class provides access to the message panel at the bottom of the
            Tweek Java GUI layout. Tweek Bean authors can make use of this
            singleton to post messages to that panel for users of the Tweek
            GUI to see. In most cases, this should be the preferred method of
            printing status messages rather than using
            <methodname>System.out.print*()</methodname> or
            <methodname>System.err.print*()</methodname> simply because users
            of the GUI may not have easy access to the console to see the
            messages printed there. The GUI Library is found in
            <filename>$TWEEK_BASE_DIR/share/tweek/java/Tweek.jar</filename>.</para>
         </section>

         <section id="bean.library.section">
            <title>Bean Library</title>

            <indexterm>
               <primary>Java libraries</primary>

               <secondary>Bean</secondary>
            </indexterm>

            <para>The Bean Library is provided to help simplify the process of
            loading and managing JavaBeans. The internal handling of JavaBeans
            performed by the Tweek Java GUI uses classes in this library to
            communicate with other objects when Beans are loaded,
            instantiated, removed, etc. The Bean Library is found in
            <filename>$TWEEK_BASE_DIR/share/tweek/java/TweekBeans.jar</filename>.</para>
         </section>

         <section id="event.library.section">
            <title>Event Library</title>

            <indexterm>
               <primary>Java libraries</primary>

               <secondary>Event</secondary>
            </indexterm>

            <para>The Event Library is used by the GUI Library (i.e., by the
            Tweek Java GUI) to inform Panel Beans about GUI events. This
            includes events such as GUI iconification, GUI closing, and the
            gaining and losing of focus by the GUI. The Event Library is found
            in
            <filename>$TWEEK_BASE_DIR/share/tweek/java/TweekEvents.jar</filename>.</para>

            <para>An interesting part of the Event Library is the Event
            Listener Registry. Historically, the Tweek Java GUI has performed
            automatic, run-time registration of Beans as event listeners based
            on the interface(s) that the Beans implement. That is not always
            convenient, however. For example, a Panel Bean author may want to
            use utility classes as event listeners rather than the Panel Bean
            itself. In this case, the utility classes can be registered
            manually with the Tweek Java GUI using the Event Listener
            Registry.</para>
         </section>

         <section id="network.library.section">
            <title>Network Library</title>

            <indexterm>
               <primary>Java libraries</primary>

               <secondary>Network</secondary>
            </indexterm>

            <para>The Network Library abstracts the use of CORBA by the Tweek
            Java GUI<footnote>
                  <para>This single library is perhaps the reason that people
                  feel compelled to use the <quote>pre-fab</quote> Tweek Java
                  GUI rather than write their own GUI in the language and
                  widget set of their choice.</para>
               </footnote>. It includes the CORBA Service class that handles
            all ORB and remote reference management, and it has all the Java
            classes generated by the IDL-to-Java compiler when the Tweek Java
            API was compiled. Beyond this, it includes the event listener
            interface for Tweek Beans that wish to be notified of network
            connection and disconnection events. The Network Library is found
            in
            <filename>$TWEEK_BASE_DIR/share/tweek/java/TweekNet.jar</filename>.</para>
         </section>

         <section id="beandelivery.library.section">
            <title>Bean Delivery Library</title>

            <indexterm>
               <primary>Java libraries</primary>

               <secondary>Bean Delivery</secondary>
            </indexterm>

            <para>The Bean Delivery Library makes use of the Bean Library and
            the Network Library to allow JavaBeans to be transferred across
            the network. More specifically, a remote subject, most likely
            written in C++, can <quote>push</quote> JavaBeans to the Tweek GUI
            where they can be handled as though they were loaded from the
            local disk. The Bean Delivery Library is found in
            <filename>$TWEEK_BASE_DIR/share/tweek/java/TweekEventDelivery.jar</filename>.</para>
         </section>
      </chapter>

      <chapter id="prog.all.chapter">
         <title>Putting It All Together</title>

         <para>Based on the information presented in the previous chapters, we
         can combine everything into an examples. In this chapter, we present
         the step-by-step process for using the Tweek Java and C++
         APIs.</para>

         <section id="collab.slider.section">
            <title>Collaborative Slider</title>

            <para>In this example, we explain how to develop a simple Tweek
            interface. The goal is to have a <quote>collaborative</quote>
            slider in a Java GUI component. The value displayed by the slider
            is retained by a C++ application so that multiple independent
            sliders can show the same value. The steps explained here are
            highly representative of the normal steps to be followed when
            using the Tweek Java and C++ APIs. The structure of the following
            sections lays out the order of the steps taken. An example
            makefile that goes along with the code presented can be found in
            <xref linkend="SliderSubject.makefile.section" /> of <xref
            linkend="makefile.appendix" />. The full source for the examples
            presented in this section can be found in
            <filename>$TWEEK_BASE_DIR/share/test/NetworkTestBean</filename>.</para>

            <section>
               <title>The Subject</title>

               <para>To begin, the subject interface must be defined in IDL
               and implemented in C++. The interface itself will be
               <quote>compiled</quote> into Java and C++ code. Both ends of
               the communication channels must know the interface in order for
               the references to be used, thus requiring the generation of
               code for both languages.</para>

               <section>
                  <title>Creating the Interface</title>

                  <para>Creating an IDL interface involves writing an IDL
                  file. For this example, we will be storing an integer
                  variable in a C++ servant. The Java GUIs will need to read
                  and write the value, so we need two methods:
                  <methodname>getValue()</methodname> and
                  <methodname>setValue()</methodname>. The type being passed
                  between <glossterm linkend="gloss.orb">ORBs</glossterm> will
                  be <type>long</type>, a 32-bit integer. Depending on the
                  target language, this will map to the corresponding type of
                  the same size.</para>

                  <example id="SliderSubject.idl.example">
                     <title>SliderSubject.idl</title>

                     <programlisting linenumbering="numbered">#ifndef _NETWORK_TEST_SLIDER_SUBJECT_IDL_    <co
                           id="cpp.ifndef.line" linkends="cpp.protection.co" />
#define _NETWORK_TEST_SLIDER_SUBJECT_IDL_    <co id="cpp.define.line"
                           linkends="cpp.protection.co" />

#include &lt;tweek/idl/Subject.idl&gt;             <co
                           id="tweek.subject.idl.include"
                           linkends="tweek.subject.idl.include.co" />

module networktest                           <co id="idl.module.block"
                           linkends="idl.module.block.co" />
{
   interface SliderSubject : tweek::Subject  <co id="idl.interface.decl"
                           linkends="idl.interface.decl.co" />
   {
      void setValue(in long val);            <co
                           id="SliderSubject.setValue.decl"
                           linkends="SliderSubject.methods.co" />
      long getValue();                       <co
                           id="SliderSubject.getValue.decl"
                           linkends="SliderSubject.methods.co" />
   };
};

#endif                                       <co id="cpp.endif.line"
                           linkends="cpp.protection.co" />
</programlisting>

                     <calloutlist>
                        <callout arearefs="cpp.ifndef.line cpp.define.line cpp.endif.line"
                                 id="cpp.protection.co">
                           <para>IDL files are run through the C preprocessor
                           so that they may include external files. To prevent
                           including the same source multiple times, the file
                           must be enclosed in the traditional preprocessor
                           protection block. This is exactly what is done in
                           C/C++ header files.</para>
                        </callout>

                        <callout arearefs="tweek.subject.idl.include"
                                 id="tweek.subject.idl.include.co">
                           <para>All Tweek subject IDL files must include
                           <filename>tweek/idl/Subject.idl</filename>. This is
                           required so that the interface being defined can
                           inherit from
                           <interfacename>tweek::Subject</interfacename>.</para>
                        </callout>

                        <callout arearefs="idl.module.block"
                                 id="idl.module.block.co">
                           <para>Typically, using a module to contain the
                           interface is recommended. Using a module defines a
                           Java package and a C++ namespace (named
                           <literal>networktest</literal> in this case).</para>
                        </callout>

                        <callout arearefs="idl.interface.decl"
                                 id="idl.interface.decl.co">
                           <para>The definition of the subject interface must
                           inherit from
                           <interfacename>tweek::Subject</interfacename>. If
                           this is not done, there is no way that the subject
                           interface will plug into the Subject Manager.</para>
                        </callout>

                        <callout arearefs="SliderSubject.setValue.decl SliderSubject.getValue.decl"
                                 id="SliderSubject.methods.co">
                           <para>This simple interface has only two functions:
                           <methodname>setValue()</methodname> and
                           <methodname>getValue()</methodname>. The method
                           getValue() takes a single read-only parameter of
                           type <type>long</type>;
                           <methodname>getValue()</methodname> returns a value
                           of the same type.</para>
                        </callout>
                     </calloutlist>
                  </example>

                  <para>The file <filename>SliderSubject.idl</filename> must
                  be <quote>compiled</quote> by an <glossterm
                  linkend="gloss.idl-compiler">IDL compiler</glossterm>. For
                  use with Tweek, the interface must be compiled into Java and
                  C++ code. The generated Java code will be used solely for
                  communicating with CORBA
                  <interfacename>networktest.SliderSubject</interfacename>
                  references. The generated C++ code will be extended to
                  provide an implementation of the
                  <interfacename>networktest::SliderSubject</interfacename>
                  interface. (The implementation will be a CORBA <glossterm
                  linkend="gloss.servant">servant</glossterm> object to which
                  references will be made by remote Java code.)</para>
               </section>

               <section>
                  <title>Implementing the Interface in C++</title>

                  <para>After running an IDL compiler to generate the stub
                  CORBA code, the interface must be implemented. In
                  particular, there will be pure virtual methods in
                  <filename>SliderSubject.h</filename> that must be
                  implemented. The implementing class will be the CORBA
                  <glossterm linkend="gloss.servant">servant</glossterm>
                  holding the actual data visualized in the Java GUI
                  slider.</para>

                  <example id="SliderSubjectImpl.h.example">
                     <title>SliderSubjectImpl.h</title>

                     <programlisting linenumbering="numbered">#ifndef _SLIDER_SUBJECT_IMPL_H_
#define _SLIDER_SUBJECT_IMPL_H_

#include &lt;tweek/tweekConfig.h&gt;

#include &lt;vector&gt;

#include &lt;tweek/CORBA/SubjectImpl.h&gt;                           <co
                           id="SliderSubjectImpl.h.includes.subjimpl"
                           linkends="SliderSubjectImpl.h.includes.co" />
#include &lt;SliderSubject.h&gt;                                     <co
                           id="SliderSubjectImpl.h.include.subj"
                           linkends="SliderSubjectImpl.h.include.subj.co" />

namespace networktest                                          <co
                           id="SliderSubjectImpl.h.namespace"
                           linkends="SliderSubjectImpl.h.namespace.co" />
{

/**
 * This class is an extension to the base Tweek SubjectImpl class.
 * It uses multiple inheritance with that class and with the
 * generated CORBA class corresponding to the IDL for
 * SliderSubject.
 */
class SliderSubjectImpl
    : public POA_networktest::SliderSubject                    <co
                           id="SliderSubjectImpl.h.class.decl"
                           linkends="SliderSubjectImpl.h.class.decl.co" />
    , public tweek::SubjectImpl
{
public:
   SliderSubjectImpl()
      : tweek::SubjectImpl(), mValue(0)
   {
      /* Do nothing. */ ;
   }

   virtual ~SliderSubjectImpl()
   {
      /* Do nothing. */ ;
   }

   /**
    * Sets this subject's internal value.
    */
   virtual void setValue(long value);                          <co
                           id="SliderSubjectImpl.h.setValue"
                           linkends="SliderSubjectImpl.h.virtuals.co" />

   /**
    * Returns this subject's internal value.
    */
   virtual long getValue();                                    <co
                           id="SliderSubjectImpl.h.getValue"
                           linkends="SliderSubjectImpl.h.virtuals.co" />

   /**
    * This overriding method is needed so that the correct type
    * is returned when the _this() method is invoked.  Without
    * this method, an object of type tweek::Subject_ptr would
    * be returned.
    *
    * XXX: It may be possible to remove this requirement in
    * the future.
    */  
   networktest::SliderSubject_ptr _this()                      <co
                           id="SliderSubjectImpl.h.hack"
                           linkends="SliderSubjectImpl.h.hack.co" />
   {
      return POA_networktest::SliderSubject::_this();
   }

private:
   long mValue;   /**&lt; Our value */                            <co
                           id="SliderSubjectImpl.h.mValue"
                           linkends="SliderSubjectImpl.h.mValue.co" />
};

} // End of networktest namespace


#endif /* _SLIDER_SUBJECT_IMPL_H_ */</programlisting>

                     <calloutlist>
                        <callout arearefs="SliderSubjectImpl.h.includes.subjimpl"
                                 id="SliderSubjectImpl.h.includes.co">
                           <para>These files will always be included by
                           implementations of Tweek subject derived classes.
                           The first contains the declaration for the basic
                           Tweek subject implementation. The second contains
                           the C++ code generated from the Tweek
                           <filename>Observer.idl</filename> file.</para>
                        </callout>

                        <callout arearefs="SliderSubjectImpl.h.include.subj"
                                 id="SliderSubjectImpl.h.include.subj.co">
                           <para>This header is generated by the IDL compiler
                           from <filename>SliderSubject.idl</filename>. In
                           particular, it defines the class from which
                           <classname>networktest::SliderSubjectImpl</classname>
                           must inherit.</para>
                        </callout>

                        <callout arearefs="SliderSubjectImpl.h.namespace"
                                 id="SliderSubjectImpl.h.namespace.co">
                           <para>In <filename>SliderSubject.idl</filename>,
                           shown in <xref
                           linkend="SliderSubject.idl.example" />, the
                           interface is in the <literal>networktest</literal>
                           module. In the C++ implementation code, the module
                           name corresponds to a namespace.</para>
                        </callout>

                        <callout arearefs="SliderSubjectImpl.h.class.decl"
                                 id="SliderSubjectImpl.h.class.decl.co">
                           <para>The interface implementation class must
                           inherit from the IDL-generated class
                           <classname>POA_networktest::SliderSubject</classname>
                           and from
                           <classname>tweek::SubjectImpl</classname>.</para>
                        </callout>

                        <callout arearefs="SliderSubjectImpl.h.setValue SliderSubjectImpl.h.getValue"
                                 id="SliderSubjectImpl.h.virtuals.co">
                           <para><classname>POA_networktest::SliderSubject</classname>
                           defines two pure virtual methods that must be
                           implemented. These correspond to the methods in
                           <filename>SliderSubject.idl</filename>.</para>
                        </callout>

                        <callout arearefs="SliderSubjectImpl.h.hack"
                                 id="SliderSubjectImpl.h.hack.co">
                           <para>As of this writing, all subject
                           implementations must contain an overriding version
                           of the <methodname>_this()</methodname> method. This
                           is due to the use of multiple inheritance. Note the
                           return type and the <literal>return</literal>
                           statement. These will vary for each subject
                           implementation based on the name of the IDL-defined
                           interface.</para>
                        </callout>

                        <callout arearefs="SliderSubjectImpl.h.mValue"
                                 id="SliderSubjectImpl.h.mValue.co">
                           <para>This is the actual value being stored by the
                           C++ servant.</para>
                        </callout>
                     </calloutlist>
                  </example>

                  <para>In <filename>SliderSubjectImpl.h</filename>, the most
                  important parts to note are the use of multiple inheritance,
                  the declarations of the
                  <interfacename>SliderSubject</interfacename> interface
                  methods, and the implementation of
                  <methodname>_this()</methodname>. The implementations of
                  <methodname>setValue()</methodname> and
                  <methodname>getValue()</methodname> are shown next in <xref
                  linkend="SliderSubjectImpl.cpp.example" />.</para>

                  <example id="SliderSubjectImpl.cpp.example">
                     <title>SliderSubjectImpl.cpp</title>

                     <programlisting linenumbering="numbered">#include &lt;vpr/Util/Debug.h&gt;
#include &lt;SliderSubjectImpl.h&gt;                   <co
                           id="SliderSubjectImpl.cpp.inc"
                           linkends="SliderSubjectImpl.cpp.inc.co" />

namespace networktest
{

void SliderSubjectImpl::setValue(long value)
{
   mValue = value;                               <co
                           id="SliderSubjectImpl.cpp.mValue.assign"
                           linkends="SliderSubjectImpl.cpp.mValue.assign.co" />

   // Notify any observers that our value has changed.  This is very
   // important.
   tweek::SubjectImpl::notify();                 <co
                           id="SliderSubjectImpl.cpp.notify"
                           linkends="SliderSubjectImpl.cpp.notify.co" />
}

long SliderSubjectImpl::getValue()
{
   return mValue;                                <co
                           id="SliderSubjectImpl.cpp.mValue.return"
                           linkends="SliderSubjectImpl.cpp.mValue.return.co" />
}

} // End networktest namespace</programlisting>

                     <calloutlist>
                        <callout arearefs="SliderSubjectImpl.cpp.inc"
                                 id="SliderSubjectImpl.cpp.inc.co">
                           <para>Include the class declaration file, shown in
                           <xref
                           linkend="SliderSubjectImpl.h.example" />.</para>
                        </callout>

                        <callout arearefs="SliderSubjectImpl.cpp.mValue.assign"
                                 id="SliderSubjectImpl.cpp.mValue.assign.co">
                           <para>When invoked, the remote caller will pass a
                           <type>long</type> value, and this saves the result
                           into the servant's storage.</para>
                        </callout>

                        <callout arearefs="SliderSubjectImpl.cpp.notify"
                                 id="SliderSubjectImpl.cpp.notify.co">
                           <para>Because the subject's state has been modified,
                           all attached observers must be notified. This is a
                           very important step that must be taken in this
                           method. Note that it invokes the
                           <methodname>notify()</methodname> method of the
                           parent class.</para>
                        </callout>

                        <callout arearefs="SliderSubjectImpl.cpp.mValue.return"
                                 id="SliderSubjectImpl.cpp.mValue.return.co">
                           <para>Observers will invoke this method when
                           requesting the current
                           <varname>mValue</varname>.</para>
                        </callout>
                     </calloutlist>
                  </example>
               </section>
            </section>

            <section>
               <title>The Observer</title>

               <para>The observer does not define its own specialized IDL
               interface. Instead, it makes use of the existing Tweek basic
               observer (<classname>tweek.ObserverPOA</classname><indexterm>
                     <primary>classes</primary>

                     <secondary>tweek.ObserverPOA</secondary>
                  </indexterm> in Java). The method
               <methodname>update()</methodname> must be implemented. The
               remainder of the observer implementation is centered around
               communication with a
               <interfacename>SliderSubject</interfacename> object reference.
               All observer code is written in Java. The only C++ code for
               observers is part of the Tweek library, and it is generated
               entirely by the <glossterm linkend="gloss.idl-compiler">IDL
               compiler</glossterm>.</para>

               <section id="implement.observer.java.section">
                  <title>Implementing the Observer in Java</title>

                  <para>For every subject interface defined in IDL, a
                  corresponding observer class must be written in Java.
                  Without an observer, there is no way for the Java and C++
                  sides to conduct useful two-way communication. At best, the
                  Java GUI could request a subject reference and manipulate
                  the C++ application through the reference, but the
                  communication would be entirely one-way.</para>

                  <para>In <xref linkend="SliderObserverImpl.java.example" />,
                  we show the complete Java implementation of an observer
                  corresponding to the
                  <interfacename>tweek::SliderSubject</interfacename>
                  interface defined earlier. (The JavaBean that uses this
                  observer is explained in <xref
                  linkend="slider.subject.bean.section" />.) The main focus of
                  this observer is to update its contained
                  <classname>JSlider</classname> whenever the state of the
                  corresponding subject changes.</para>

                  <example id="SliderObserverImpl.java.example">
                     <title>SliderObserverImpl.java</title>

                     <programlisting linenumbering="numbered">package networktest;

import javax.swing.DefaultBoundedRangeModel;
import javax.swing.JSlider;
import tweek.*;

/**
 * Implementation of the Observer side of the Tweek
 * Subject/Observer pattern.  It must extend tweek.ObserverPOA
 * so that instances of this class can be registered as CORBA
 * servants.  In addition, CORBA references to the servants must
 * be capable of being attached to remote subjects.
 */
public class SliderObserverImpl extends ObserverPOA            <co
                           id="SliderObserverImpl.java.class.decl"
                           linkends="SliderObserverImpl.java.class.decl.co" />
{
   public SliderObserverImpl(JSlider slider,                   <co
                           id="SliderObserverImpl.java.constructor"
                           linkends="SliderObserverImpl.java.constructor.co" />
                             SliderSubject subject)
   {
      mSlider        = slider;
      mSliderSubject = subject;
   }

   /**
    * Implements the required method in tweek.ObserverPOA.  The
    * remote subject will invoke this method whenever it is
    * notified of a change.
    */
   public void update()                                        <co
                           id="SliderObserverImpl.java.update"
                           linkends="SliderObserverImpl.java.update.co" />
   {
      // If we have a valid slider object, we need to update
      // its value to whatever our subject has.
      if ( mSlider != null )
      {
         DefaultBoundedRangeModel model =
            (DefaultBoundedRangeModel) mSlider.getModel();
         model.setValue(mSliderSubject.getValue());            <co
                           id="SliderObserverImpl.java.getValue"
                           linkends="SliderObserverImpl.java.getValue.co" />
         mSlider.repaint();
      }
   }

   /**
    * Detaches this observer from our subject.  This is needed
    * when shutting down a CORBA connection.
    */
   public void detach()
   {
      mSliderSubject.detach(this._this());                     <co
                           id="SliderObserverImpl.java.detach"
                           linkends="SliderObserverImpl.java.detach.co" />
   }

   private SliderSubject mSliderSubject = null;
   private JSlider       mSlider        = null;
}</programlisting>

                     <calloutlist>
                        <callout arearefs="SliderObserverImpl.java.class.decl"
                                 id="SliderObserverImpl.java.class.decl.co">
                           <para>As an observer, this class must derive from
                           <classname>tweek.ObserverPOA</classname>. This class
                           is generated by the IDL compiler and is part of the
                           Tweek Network Library (see <xref
                           linkend="network.library.section" />).</para>
                        </callout>

                        <callout arearefs="SliderObserverImpl.java.constructor"
                                 id="SliderObserverImpl.java.constructor.co">
                           <para>The constructor for this observer takes two
                           arguments: a <classname>JSlider</classname> object
                           reference and a
                           <interfacename>networktest.SliderSubject</interfacename>
                           object reference. The observer needs the latter
                           argument so that it can query state information from
                           the subject when notified of state changes. This is
                           part of the subject/observer design pattern <xref
                           linkend="Gam95" />.</para>
                        </callout>

                        <callout arearefs="SliderObserverImpl.java.update"
                                 id="SliderObserverImpl.java.update.co">
                           <para>As stated, all observers must implement
                           <methodname>update()</methodname>. This will be
                           invoked by the remote subject when its
                           <methodname>notify()</methodname> method is
                           invoked.</para>
                        </callout>

                        <callout arearefs="SliderObserverImpl.java.getValue"
                                 id="SliderObserverImpl.java.getValue.co">
                           <para>To get the updated state of the remote
                           subject, the encapsulated subject reference's
                           <methodname>getValue()</methodname> method is
                           invoked. The value returned will be the most
                           up-to-date information from the subject.</para>
                        </callout>

                        <callout arearefs="SliderObserverImpl.java.detach"
                                 id="SliderObserverImpl.java.detach.co">
                           <para>It may be convenient for the observer to
                           implement a <methodname>detach()</methodname> method
                           (though the name may vary). This is used when the
                           Java application is shutting down to ensure that the
                           remote subject does not have dangling references to
                           observers that no longer exist. The only action
                           required here is invoking the subject's
                           <methodname>detach()</methodname> method to inform
                           the subject that this observer is going away.</para>
                        </callout>
                     </calloutlist>
                  </example>

                  <para>This example demonstrates that observers do not have
                  to be complex to be usable. While this example is purposely
                  simple, it should illustrate that developers of observers do
                  not necessarily have to make their implementations
                  complicated. As will be shown in <xref
                  linkend="slider.subject.bean.section" />, the JavaBean that
                  uses this observer completes the picture and provides users
                  with a GUI slider that can be manipulated by any number of
                  simultaneous users.</para>
               </section>
            </section>

            <section id="SliderSubject.server.section">
               <title lang="SliderSubject.server.section">The Server
               Application</title>

               <para>Now that we have the subject and observer ready to go, we
               can make an application that uses them. The following example
               is a (relatively) simple C++ application that starts the CORBA
               Manager<indexterm>
                     <primary>CORBA Manager</primary>

                     <secondary>initialization</secondary>

                     <tertiary>example of</tertiary>
                  </indexterm>, creates the Subject Manager<indexterm>
                     <primary>Subject Manager</primary>

                     <secondary>creation</secondary>

                     <tertiary>example of</tertiary>
                  </indexterm>, registers a
               <interfacename>networktest::SliderSubject</interfacename>
               servant, and then waits for the user to press
               '<literal>x</literal>' to exit. The use of exceptions may
               appear unfamiliar to some C++ programmers. CORBA makes use of
               exceptions as a cross-language mechanism to report errors, and
               thus, there must be proper exception handling code for the
               application to work correctly.</para>

               <example id="SliderSubjectApp.cpp.example">
                  <title>SliderSubjectApp.cpp</title>

                  <programlisting linenumbering="numbered">#include &lt;tweek/CORBA/CorbaManager.h&gt;                         <co
                        id="SliderSubjectApp.cpp.includes.tweek"
                        linkends="SliderSubjectApp.cpp.includes.co" />
#include &lt;vpr/Thread/Thread.h&gt;
#include &lt;vpr/Util/Debug.h&gt;

#include &lt;SliderSubjectImpl.h&gt;                                <co
                        id="SliderSubjectApp.cpp.includes.gen"
                        linkends="SliderSubjectApp.cpp.includes.co" />

/**
 * This application starts the CORBA server for the C++ side
 * of the test.
 */
int main(int argc, char* argv[])
{
   tweek::CorbaManager mgr;                                   <co
                        id="SliderSubjectApp.cpp.corbamgr.decl"
                        linkends="SliderSubjectApp.cpp.corbamgr.co" />

   // The first thing we have to do is initialize the Tweek
   // CORBA Manager.  If this fails, we're out of luck.
   try
   {
      if ( mgr.init("corba_test", argc, argv) )               <co
                        id="SliderSubjectApp.cpp.corbamgr.init"
                        linkends="SliderSubjectApp.cpp.corbamgr.co" />
      {
         bool status(false);

         // Once the CORBA Manager is initialized, we need to
         // create a Subject Manager.  This will hold our
         // SliderSubject object.
         try
         {
            status = mgr.createSubjectManager();              <co
                        id="SliderSubjectApp.cpp.subjectmgr.create"
                        linkends="SliderSubjectApp.cpp.subjectmgr.create.co" />

            // If we were able to create the Subject Manager,
            // now we register our objects with it.
            if ( status )
            {
               // First, create real instances of the C++
               // object that will be the CORBA servant.  This
               // must be allocated on the heap.
               networktest::SliderSubjectImpl* slider_subj =
                  new networktest::SliderSubjectImpl();       <co
                        id="SliderSubjectApp.cpp.subject.create"
                        linkends="SliderSubjectApp.cpp.subject.create.co" />

               // Now we try to register the subject and give
               // it a symbolic, easy-to-remember name.
               try
               {
                  mgr.getSubjectManager()-&gt;
                     registerSubject(slider_subj,
                                     "SliderSubject");        <co
                        id="SliderSubjectApp.cpp.subject.register"
                        linkends="SliderSubjectApp.cpp.subject.register.co" />
               }
               catch (...)
               {
                  vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
                     &lt;&lt; "Failed to register subject\n"
                     &lt;&lt; vprDEBUG_FLUSH;
               }

               // We are done with our pointer to the servant.
               slider_subj-&gt;_remove_ref();
            }
         }
         catch (CORBA::Exception&amp; ex)
         {
            vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
               &lt;&lt; "Caught an unknown CORBA exception when "
               &lt;&lt; "trying to register!\n"
               &lt;&lt; vprDEBUG_FLUSH;
         }

         if ( ! status )
         {
            vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
               &lt;&lt; "Failed to register Subject Manager instance\n"
               &lt;&lt; vprDEBUG_FLUSH;
         }

         std::cout &lt;&lt; "Press 'x' to exit" &lt;&lt; std::endl;
         char input;

         // Loop forever so that we can act sort of like
         // a server.
         while ( 1 )                                          <co
                        id="SliderSubjectApp.cpp.loop"
                        linkends="SliderSubjectApp.cpp.loop.co" />
         {
            std::cin &gt;&gt; input;
            if ( input == 'x' )
            {
               break;
            }
            else
            {
               vpr::System::msleep(100);
            }
         }
      }
      else
      {
         vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
            &lt;&lt; "CORBA failed to initialize\n" &lt;&lt; vprDEBUG_FLUSH;
      }
   }
   catch (...)
   {
      vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
         &lt;&lt; "Caught an unknown exception!\n" &lt;&lt; vprDEBUG_FLUSH;
   }

   vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
      &lt;&lt; "Exiting\n" &lt;&lt; vprDEBUG_FLUSH;

   return 0;
}</programlisting>

                  <calloutlist>
                     <callout arearefs="SliderSubjectApp.cpp.includes.tweek SliderSubjectApp.cpp.includes.gen"
                              id="SliderSubjectApp.cpp.includes.co">
                        <para>These two headers are typically needed. The
                        first includes the declaration of the Tweek CORBA
                        Manager, and the second is the subject implementation
                        declaration, shown in <xref
                        linkend="SliderSubjectImpl.h.example" />.</para>
                     </callout>

                     <callout arearefs="SliderSubjectApp.cpp.corbamgr.decl SliderSubjectApp.cpp.corbamgr.init"
                              id="SliderSubjectApp.cpp.corbamgr.co">
                        <para>In order to use CORBA through Tweek, the CORBA
                        Manager must be created and initialized. Any number of
                        these may be created, but in general, only one is
                        needed per application</para>
                     </callout>

                     <callout arearefs="SliderSubjectApp.cpp.subjectmgr.create"
                              id="SliderSubjectApp.cpp.subjectmgr.create.co">
                        <para>After the COBRA Manager has been initialized
                        successfully, the Tweek Subject Manager must be
                        created.</para>
                     </callout>

                     <callout arearefs="SliderSubjectApp.cpp.subject.create"
                              id="SliderSubjectApp.cpp.subject.create.co">
                        <para>Once we have a valid Subject Manager, we must
                        register subjects with it in order for object
                        references to be passed out by CORBA. This creates the
                        <glossterm linkend="gloss.servant">servant</glossterm>
                        to which
                        <interfacename>networktest::SliderSubject</interfacename>
                        references will be made.</para>
                     </callout>

                     <callout arearefs="SliderSubjectApp.cpp.subject.register"
                              id="SliderSubjectApp.cpp.subject.register.co">
                        <para>Once the servant is created, it is registered
                        with the Subject Manager. The Subject Manager will
                        activate the servant within the POA so that references
                        to it can be created and returned to clients.</para>
                     </callout>

                     <callout arearefs="SliderSubjectApp.cpp.loop"
                              id="SliderSubjectApp.cpp.loop.co">
                        <para>After the subject is registered, all the work is
                        done. This application now just waits for clients to
                        request references. It will exit when the user enters
                        '<literal>x</literal>'.</para>
                     </callout>
                  </calloutlist>
               </example>

               <para>The application shown in <xref
               linkend="SliderSubjectApp.cpp.example" /> is purposely simple.
               There are many ways to use the CORBA Manager and the Subject
               Manager. For example, an object registry could be built on top
               of the Subject Manager so that only specific types of servant
               objects may be registered. Servant registration could be
               automated in object constructors. The C++ API is intended to be
               simple to enhance its usability and flexibility, and the
               application shown in the example is just that: an
               example.</para>
            </section>

            <section id="slider.subject.bean.section">
               <title>The JavaBean</title>

               <para>We have finally reached the point at which we implement a
               JavaBean that can visualize the numeric data held by the C++
               slider subject. Such a JavaBean must be defined as a Tweek
               Panel Bean. (Refer back to <xref
               linkend="intro.javabeans.chapter" /> if these statements seem
               unfamiliar or confusing.)</para>

               <para>The JavaBean shown in the following example is typical of
               one that uses the Tweek Network library to take advantage of
               CORBA facilities. The code for the Bean is longer than previous
               examples, and because of this, it will be split into multiple
               code blocks. Each will be discussed in turn. The full code is
               in one file: <filename>NetworkTest.java</filename>.</para>

               <para>Please note that the details of setting up the GUI
               elements used by the Bean are left out. The code in this case
               was generated by JBuilder and could easily vary from Bean to
               Bean. For the full code, please refer to the aforementioned
               locations.</para>

               <section>
                  <title>Imports</title>

                  <para>The slider JavaBean uses common Java Swing classes, a
                  CORBA exception class, the Tweek Event library, the Tweek
                  Network library, and the Java code generated by an IDL
                  compiler. The following explains how each of these are
                  imported into the main Bean class.</para>

                  <programlisting>package networktest;                                       <co
                        id="NetworkTest.java.package"
                        linkends="NetworkTest.java.package.co" />

import java.awt.*;                                         <co
                        id="NetworkTest.java.imports.gui.awt"
                        linkends="NetworkTest.java.imports.gui.co" />
import javax.swing.*;                                      <co
                        id="NetworkTest.java.imports.gui.swing"
                        linkends="NetworkTest.java.imports.gui.co" />
import javax.swing.event.*;                                <co
                        id="NetworkTest.java.imports.gui.swing.event"
                        linkends="NetworkTest.java.imports.gui.co" />
import org.omg.CORBA.BAD_PARAM;                            <co
                        id="NetworkTest.java.imports.corba"
                        linkends="NetworkTest.java.imports.corba.co" />
import org.vrjuggler.tweek.event.*;                        <co
                        id="NetworkTest.java.imports.tweek.event"
                        linkends="NetworkTest.java.imports.tweek.co" />
import org.vrjuggler.tweek.net.*;                          <co
                        id="NetworkTest.java.imports.tweek.net"
                        linkends="NetworkTest.java.imports.tweek.co" />
import org.vrjuggler.tweek.net.corba.*;                    <co
                        id="NetworkTest.java.imports.tweek.net.corba"
                        linkends="NetworkTest.java.imports.tweek.co" />
import tweek.*;                                            <co
                        id="NetworkTest.java.imports.tweek-gen"
                        linkends="NetworkTest.java.imports.tweek-gen.co" />
</programlisting>

                  <calloutlist>
                     <callout arearefs="NetworkTest.java.package"
                              id="NetworkTest.java.package.co">
                        <para>This Bean is in a package corresponding to the
                        IDL module defined in
                        <filename>SliderSubject.idl</filename>. Using a
                        consistent name throughout makes the code easier to
                        manage and understand.</para>
                     </callout>

                     <callout arearefs="NetworkTest.java.imports.gui.awt NetworkTest.java.imports.gui.swing NetworkTest.java.imports.gui.swing.event"
                              id="NetworkTest.java.imports.gui.co">
                        <para>These imports bring in common Swing and AWT GUI
                        classes. Different Beans will use different classes
                        and packages.</para>
                     </callout>

                     <callout arearefs="NetworkTest.java.imports.corba"
                              id="NetworkTest.java.imports.corba.co">
                        <para>In order to do proper narrowing of reference
                        types, the exception
                        <exceptionname>org.omg.CORBA.BAD_PARAM</exceptionname>
                        must be caught.</para>
                     </callout>

                     <callout arearefs="NetworkTest.java.imports.tweek.event NetworkTest.java.imports.tweek.net NetworkTest.java.imports.tweek.net.corba"
                              id="NetworkTest.java.imports.tweek.co">
                        <para>These imports bring in the classes of the Tweek
                        Event and Network libraries.</para>
                     </callout>

                     <callout arearefs="NetworkTest.java.imports.tweek-gen"
                              id="NetworkTest.java.imports.tweek-gen.co">
                        <para>Tweek Java code generated by an IDL compiler
                        will always be in the package
                        <classname>tweek</classname>. This corresponds to the
                        IDL module and to the C++ namespace.</para>
                     </callout>
                  </calloutlist>
               </section>

               <section>
                  <title>Class Declaration</title>

                  <para>Now we can begin writing the Bean code. Besides the
                  class <classname>SliderObserverImpl</classname>, this Bean
                  has only one public class:
                  <classname>NetworkTest</classname>. It will provide the GUI
                  representation of the numeric data. The declaration of the
                  class and its package-visible helper follow.</para>

                  <programlisting>/**
 * This is an example of a JavaBean that Tweek can load dynamically.  It holds
 * a JSlider that acts as an Observer in the Tweek CORBA Subject/Observer
 * pattern implementation.
 *
 * @version 1.0
 */
public class NetworkTest
   extends JPanel                                          <co
                        id="NetworkTest.java.superclass"
                        linkends="NetworkTest.java.superclass.co" />
   implements CommunicationListener                        <co
                        id="NetworkTest.java.interfaces"
                        linkends="NetworkTest.java.interfaces.co" />
{
...
}

class FrameListener extends TweekFrameAdapter              <co
                        id="NetworkTest.java.helper"
                        linkends="NetworkTest.java.helper.co" />
{
...
}</programlisting>

                  <calloutlist>
                     <callout arearefs="NetworkTest.java.superclass"
                              id="NetworkTest.java.superclass.co">
                        <para>As a Tweek Panel Bean, there must be a class
                        that derives from
                        <classname>javax.swing.JComponent</classname> or some
                        subclass thereof. In this case, the superclass is
                        <classname>javax.swing.JPanel</classname>.</para>
                     </callout>

                     <callout arearefs="NetworkTest.java.interfaces"
                              id="NetworkTest.java.interfaces.co">
                        <para>Since this Bean needs to access the remote
                        Subject Manager, it needs to know when a CORBA service
                        is available. By implementing
                        <interfacename>org.vrjuggler.tweek.net.CommunicationListener</interfacename>,
                        the Bean will be informed by the Tweek Java GUI
                        whenever the communication state with a CORBA service
                        changes.</para>
                     </callout>

                     <callout arearefs="NetworkTest.java.helper"
                              id="NetworkTest.java.helper.co">
                        <para>This Bean also listens for
                        <classname>TweekFrameEvents</classname> so that it can
                        shut itself down cleanly. To be informed of such
                        events, a helper class that extends
                        <classname>org.vrjuggler.tweek.event.TweekFrameAdapter</classname>
                        exists.</para>
                     </callout>
                  </calloutlist>
               </section>

               <section>
                  <title>Member Variables</title>

                  <para>Before delving into the methods of the
                  <classname>networktest.NetworkTest</classname> class, it
                  will be helpful to review the member variables used
                  throughout the class. Refer back to this section if there is
                  any confusion regarding the use or the type of some member
                  variable in the method implementations.</para>

                  <programlisting>private BorderLayout mBeanLayout = new BorderLayout();     <co
                        id="NetworkTest.java.members.layout"
                        linkends="NetworkTest.java.members.layout.co" />

private JPanel mSliderPanel = new JPanel();                <co
                        id="NetworkTest.java.members.slider-group.panel"
                        linkends="NetworkTest.java.members.slider-group.co" />
private JSlider mDataSlider = new JSlider();               <co
                        id="NetworkTest.java.members.slider-group.slider"
                        linkends="NetworkTest.java.members.slider-group.co" />

private SliderObserverImpl mSliderObserver = null;         <co
                        id="NetworkTest.java.members.observer"
                        linkends="NetworkTest.java.members.observer.co" />
</programlisting>

                  <calloutlist>
                     <callout arearefs="NetworkTest.java.members.layout"
                              id="NetworkTest.java.members.layout.co">
                        <para>This is the containing layout for the entire
                        Bean.</para>
                     </callout>

                     <callout arearefs="NetworkTest.java.members.slider-group.panel NetworkTest.java.members.slider-group.slider"
                              id="NetworkTest.java.members.slider-group.co">
                        <para>The <classname>JSlider</classname> used for
                        visually representing the subject's numeric data is
                        <varname>mDataSlider</varname>, and it will be
                        contained within
                        <varname>mSliderPanel</varname>.</para>
                     </callout>

                     <callout arearefs="NetworkTest.java.members.observer"
                              id="NetworkTest.java.members.observer.co">
                        <para>The
                        <interfacename>networktest::SliderSubject</interfacename>
                        observer will be stored within
                        <varname>mSliderObserver</varname>.</para>
                     </callout>
                  </calloutlist>

                  <para>Note that the observer is stored in a member variable
                  initialized to <symbol>null</symbol>. It will be assigned a
                  value when a CORBA service becomes available and the
                  corresponding subject can be requested. The object itself is
                  stored as a member variable so that it can be accessed by
                  all the methods of the class.</para>
               </section>

               <section>
                  <title>Handling CORBA Communications</title>

                  <para>The most complex part of this Bean is the handling of
                  CORBA communication events delivered by the Tweek GUI. All
                  of the handling in this example will be done in the methods
                  <methodname>connectionOpened()</methodname> and
                  <methodname>connectionClosed()</methodname>. The steps that
                  must be followed are straightforward, but there are errors
                  that must be handled properly. It is the error handling that
                  can make the code look daunting, not the use of the Tweek
                  Network library.</para>

                  <programlisting linenumbering="numbered">/**
 * Implements the Tweek CommunicationListener interface needed
 * for being informed of new connections with remote ORBs.
 */
public void connectionOpened(CommunicationEvent e)              <co
                        id="NetworkTest.java.connect"
                        linkends="NetworkTest.java.connect.co" />
{
   // The first thing to do is get the CORBA service object from
   // the event.  We need this so we know to whom we are are
   // connecting.  Once we have the CORBA service, we get its
   // Subject Manager since that's what contains the actual
   // subjects we need.
   CorbaService corba_service = e.getCorbaService();            <co
                        id="NetworkTest.java.corba.service"
                        linkends="NetworkTest.java.corba.co" />
   SubjectManager mgr = corba_service.getSubjectManager();      <co
                        id="NetworkTest.java.corba.subjectmgr"
                        linkends="NetworkTest.java.corba.co" />

   Subject subject = mgr.getSubject("SliderSubject");           <co
                        id="NetworkTest.java.getSubject"
                        linkends="NetworkTest.java.getSubject.co" />
   SliderSubject slider_subject = null;

   // Try to narrow the Subject object to a SliderSubject object.
   // If this fails, it throws a CORBA BAD_PARAM exception.  In
   // that case, we open a dialog box saying that the narrowing
   // failed.
   try
   {
      slider_subject = SliderSubjectHelper.narrow(subject);     <co
                        id="NetworkTest.java.narrow-subject"
                        linkends="NetworkTest.java.narrow.co" />
   }
   catch (BAD_PARAM narrow_ex)                                  <co
                        id="NetworkTest.java.narrow-exception"
                        linkends="NetworkTest.java.narrow.co" />
   {
      JOptionPane.showMessageDialog(
         null,
         "Failed to narrow subject to SliderSubject",
         "SliderSubject Narrow Error",
         JOptionPane.ERROR_MESSAGE
      );
   }

   // Ensure that slider_subject is a valid object just to be
   // safe.
   if ( slider_subject != null )
   {
      // First, we need a Java object that implements the
      // Observer.  That object must be registered with the Java
      // CORBA service.
      mSliderObserver =
         new SliderObserverImpl(mDataSlider, slider_subject);   <co
                        id="NetworkTest.java.observer.create"
                        linkends="NetworkTest.java.observer.create.co" />
      corba_service.registerObject(mSliderObserver,
                                   "SliderObserver");           <co
                        id="NetworkTest.java.observer.register"
                        linkends="NetworkTest.java.observer.register.co" />

      // Now that the observer is registered, we can attach it
      // to the subject.  The subject needs to know who its
      // observers are so that it can notify them of updates.
      slider_subject.attach(mSliderObserver._this());           <co
                        id="NetworkTest.java.observer.attach"
                        linkends="NetworkTest.java.observer.attach.co" />

      // Now we set the slider in our GUI to be whatever value
      // the remote subject is holding for us.
      mDataSlider.setValue(slider_subject.getValue());          <co
                        id="NetworkTest.java.setValue"
                        linkends="NetworkTest.java.setValue.co" />
      mDataSlider.addChangeListener(
         new SliderChangeListener(slider_subject)
      );                                                        <co
                        id="NetworkTest.java.addChangeListener"
                        linkends="NetworkTest.java.addChangeListener.co" />
   }
}

/**
 * Implements the Tweek CommunicationListener interface needed
 * for being informed when existing ORB connections are closed.
 */
public void connectionClosed(ConnectEvent e)                    <co
                        id="NetworkTest.java.disconnect"
                        linkends="NetworkTest.java.shutdown.co" />
{
   if ( mSliderObserver != null )
   {
      mSliderObserver.detach();                                 <co
                        id="NetworkTest.java.observer.detach"
                        linkends="NetworkTest.java.shutdown.co" />
      mSliderObserver = null;
   }
}</programlisting>

                  <calloutlist>
                     <callout arearefs="NetworkTest.java.connect"
                              id="NetworkTest.java.connect.co">
                        <para>If the event delivered to the Bean is a newly
                        opened connection, there is a new CORBA service
                        available, so we will create a new observer to
                        communicate through that service.</para>
                     </callout>

                     <callout arearefs="NetworkTest.java.corba.service NetworkTest.java.corba.subjectmgr"
                              id="NetworkTest.java.corba.co">
                        <para>The first step that must be taken is retrieving
                        the
                        <classname>org.vrjuggler.tweek.net.corba.CorbaService</classname>
                        object from the event. This is needed as the basis for
                        all further actions. With the CORBA service reference,
                        we can request the Subject Manager reference. The
                        result is a CORBA reference to the remote Subject
                        Manager, a servant within the C++ application.</para>
                     </callout>

                     <callout arearefs="NetworkTest.java.getSubject"
                              id="NetworkTest.java.getSubject.co">
                        <para>Through the Subject Manager, we request subjects
                        using symbolic names. In this case, we request the
                        subject with the hard-coded name
                        <quote>SliderSbuject</quote>.</para>
                     </callout>

                     <callout arearefs="NetworkTest.java.narrow-subject NetworkTest.java.narrow-exception"
                              id="NetworkTest.java.narrow.co">
                        <para>The call to
                        <methodname>getSubject()</methodname> returns a
                        reference of type
                        <interfacename>tweek.Subject</interfacename>, but we
                        need to narrow it to
                        <interfacename>networktest.SliderSubject</interfacename>
                        so we can use it. Among the code generated by the IDL
                        compiler is a class named
                        <classname>networktest.SliderSubjectHelper</classname>.
                        Its <methodname>narrow()</methodname> method is used
                        to narrow the CORBA reference type to a more specific
                        type. If the narrowing fails, an exception of type
                        <exceptionname>org.omg.CORBA.BAD_PARAM</exceptionname>
                        is thrown, and it is best to handle it here.</para>
                     </callout>

                     <callout arearefs="NetworkTest.java.observer.create"
                              id="NetworkTest.java.observer.create.co">
                        <para>Once we have the subject reference, we create an
                        observer servant that we will attach to the subject.
                        This is where
                        <classname>networktest.SliderObserverImpl</classname>
                        comes into the picture.</para>
                     </callout>

                     <callout arearefs="NetworkTest.java.observer.register"
                              id="NetworkTest.java.observer.register.co">
                        <para>The observer servant must be registered with the
                        local CORBA service so that references to it can be
                        created. This single statement takes care of all the
                        POA activation behind the scenes.</para>
                     </callout>

                     <callout arearefs="NetworkTest.java.observer.attach"
                              id="NetworkTest.java.observer.attach.co">
                        <para>Now that the servant is registered with the
                        CORBA service, a reference to it can be passed to the
                        remote subject in order to attach the observer to the
                        subject.</para>
                     </callout>

                     <callout arearefs="NetworkTest.java.setValue"
                              id="NetworkTest.java.setValue.co">
                        <para>Once the initial references are passed around,
                        we need to update the GUI slider to the current value
                        held by the subject.</para>
                     </callout>

                     <callout arearefs="NetworkTest.java.addChangeListener"
                              id="NetworkTest.java.addChangeListener.co">
                        <para>As part of the collaborative slider, we need to
                        register a change listener with the GUI slider so that
                        it will be informed of changes made by the local user.
                        These changes are reported to the remote subject so
                        that other users get the update. The class
                        <classname>SliderChangeListener</classname> is shown
                        later.</para>
                     </callout>

                     <callout arearefs="NetworkTest.java.disconnect NetworkTest.java.observer.detach"
                              id="NetworkTest.java.shutdown.co">
                        <para>If the event delivered to the Bean was the
                        closing of an existing connection, the CORBA service
                        is being shut down. When the CORBA service is shut
                        down, we need to detach the local observer from the
                        remote subject to prevent further update notification
                        attempts for this observer.</para>
                     </callout>
                  </calloutlist>

                  <para>It is important to note that the use of hard-coded
                  subject names is not recommended. In this example, the
                  subject name is hard-coded for simplicity. The Tweek Subject
                  Manager allows accessing code to request a list of all
                  registered subjects. Using this information, it is possible
                  to present the Java GUI user with a list of subjects from
                  which they can make a selection.</para>
               </section>

               <section>
                  <title>Handling Frame Events</title>

                  <para>This Bean makes an effort to shut down open CORBA
                  connections when the Tweek GUI is closed. It does this
                  through a helper class that extends
                  <classname>org.vrjuggler.tweek.event.TweekFrameAdapter</classname>,
                  overriding only one method:
                  <methodname>frameClosing()</methodname>. This method calls
                  back into the NetworkTest class, invoking its own
                  <methodname>frameClosing()</methodname> method. For more
                  information about the other Tweek GUI frame events delivered
                  through the interface
                  <interfacename>org.vrjuggler.tweek.event.TweekFrameListener</interfacename>,
                  refer to the Tweek Java API reference.</para>

                  <programlisting>public class NetworkTest
   extends JPanel
   implements CommunicationListener
{
...
   public boolean frameClosing()
   {
      disconnect();
      return true;
   }
...
}

class FrameListener extends TweekFrameAdapter
{
   public FrameListener(NetworkTest bean)
   {
      this.bean = bean;
   }

   public boolean frameClosing(TweekFrameEvent e)               <co
                        id="NetworkTest.java.frame.close"
                        linkends="NetworkTest.java.frame.close.co" />
   {
      return bean.frameClosing();                               <co
                        id="NetworkTest.java.frame.detach"
                        linkends="NetworkTest.java.frame.detach.co" />
   }

   private NetworkTest bean = null;
}</programlisting>

                  <calloutlist>
                     <callout arearefs="NetworkTest.java.frame.close"
                              id="NetworkTest.java.frame.close.co">
                        <para>This class overrides only the method invoked
                        when the Tweek GUI frame is closing. If this method
                        returns <constant>false</constant>, then the GUI frame
                        will not close.</para>
                     </callout>

                     <callout arearefs="NetworkTest.java.frame.detach"
                              id="NetworkTest.java.frame.detach.co">
                        <para>The handling of the frame closing event is
                        delegated to
                        <methodname>NetworkTest.frameClosing()</methodname>,
                        which in turn calls
                        <methodname>NetworkTest.disconnect()</methodname> to
                        shut down the CORBA connection cleanly.</para>
                     </callout>
                  </calloutlist>

                  <para>For the helper class
                  <classname>FrameListener</classname> to be notified of Tweek
                  GUI frame events, it must be registered with the Tweek event
                  listener registry (a singleton). This step is performed in
                  the <classname>NetworkTest</classname> constructor, as shown
                  below.</para>

                  <programlisting>public NetworkTest()
{
   try
   {
      jbInit();
   }
   catch(Exception e)
   {
      e.printStackTrace();
   }

   mFrameListener = new FrameListener(this);
   EventListenerRegistry.instance().
      registerListener(mFrameListener,
                       TweekFrameListener.class);
}</programlisting>
               </section>

               <section>
                  <title>Handling Local Slider Change Events</title>

                  <para>A helper class is used to handle local change events
                  in the slider. The class is a private inner class within the
                  Bean and is defined as follows:</para>

                  <programlisting>private class SliderChangeListener implements ChangeListener
{
   public SliderChangeListener(SliderSubject subject)
   {
      mSliderSubject = subject;
   }

   public void stateChanged(javax.swing.event.ChangeEvent e)
   {
      JSlider source = (JSlider) e.getSource();

      if ( ! source.getValueIsAdjusting() )                     <co
                        id="NetworkTest.java.SliderChangeListener.stateChanged.adjust"
                        linkends="NetworkTest.java.SliderChangeListener.stateChanged.co" />
      {
         mSliderSubject.setValue(source.getValue());            <co
                        id="NetworkTest.java.SliderChangeListener.stateChanged.setValue"
                        linkends="NetworkTest.java.SliderChangeListener.stateChanged.co" />
      }
   }

   private SliderSubject mSliderSubject = null;
}</programlisting>

                  <calloutlist>
                     <callout arearefs="NetworkTest.java.SliderChangeListener.stateChanged.adjust NetworkTest.java.SliderChangeListener.stateChanged.setValue"
                              id="NetworkTest.java.SliderChangeListener.stateChanged.co">
                        <para>Within the
                        <methodname>stateChanged()</methodname> method, we
                        check to see if the user is done adjusting the slider.
                        If so, the remote subject is updated so that its
                        internal value matches that of the local slider. Other
                        users are automatically updated when this
                        happens.</para>
                     </callout>
                  </calloutlist>
               </section>

               <section>
                  <title>XML File</title>

                  <para>With the Bean implementation done, the XML file that
                  describes the Bean must be written. All Beans loaded by the
                  Tweek Java GUI are described by an XML file. In <xref
                  linkend="NetworkTestBean.xml.example" />, we show the XML
                  file for the Bean we have been developing.</para>

                  <example id="NetworkTestBean.xml.example">
                     <title>NetworkTestBean.xml</title>

                     <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;                          <co
                           id="NetworkTestBean.xml.version"
                           linkends="NetworkTestBean.xml.version.co" />
&lt;beanlist
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"        <co
                           id="NetworkTestBean.xml.beanlist"
                           linkends="NetworkTestBean.xml.beanlist.co" />
    xsi:noNamespaceSchemaLocation="http://www.vrjuggler.org/tweek/xsd/1.1/beanlist.xsd"&gt;
  &lt;guipanel name="Network Tester"&gt;                              <co
                           id="NetworkTestBean.xml.guipanel"
                           linkends="NetworkTestBean.xml.guipanel.co" />
    &lt;file                                                       <co
                           id="NetworkTestBean.xml.file"
                           linkends="NetworkTestBean.xml.file.co" />
       name="${TWEEK_BASE_DIR}/share/tweek/beans/NetworkTestBean.jar"
       class="networktest.NetworkTest" /&gt;
    &lt;tree path="/Beans" /&gt;                                      <co
                           id="NetworkTestBean.xml.tree"
                           linkends="NetworkTestBean.xml.tree.co" />
  &lt;/guipanel&gt;
&lt;/beanlist&gt;</programlisting>

                     <calloutlist>
                        <callout arearefs="NetworkTestBean.xml.version"
                                 id="NetworkTestBean.xml.version.co">
                           <para>Well-formed XML requires this line.</para>
                        </callout>

                        <callout arearefs="NetworkTestBean.xml.beanlist"
                                 id="NetworkTestBean.xml.beanlist.co">
                           <para>Tweek XML Bean files are
                           <sgmltag>beanlist</sgmltag> documents. There must be
                           exactly one <sgmltag>beanlist</sgmltag> per file,
                           but the list itself can contain multiple Beans. In
                           this element, we also provide the information needed
                           to validate this document using the XML Schema
                           <filename>beanlist.xsd</filename>. In this case, we
                           use the schema that does not employ XML namespaces.
                           Use of the schema for validation is optional, but it
                           is recommended.</para>
                        </callout>

                        <callout arearefs="NetworkTestBean.xml.guipanel"
                                 id="NetworkTestBean.xml.guipanel.co">
                           <para>The Bean we have been developing is a GUI
                           Panel Bean, and this indicates that fact.</para>
                        </callout>

                        <callout arearefs="NetworkTestBean.xml.file"
                                 id="NetworkTestBean.xml.file.co">
                           <para>To find the Bean, a path must be specified. In
                           this example, we will put the XML and JAR files in
                           <filename>$TWEEK_BASE_DIR/share/tweek/beans</filename>.
                           Note the use of curly braces around the environment
                           variable. This is required. The class attribute
                           names the class that will be instantiated, and in
                           this case, that is
                           <filename>networktest.NetworkTest</filename>. This
                           name corresponds more to the fully qualified name of
                           the class stored within the JAR file.</para>
                        </callout>

                        <callout arearefs="NetworkTestBean.xml.tree"
                                 id="NetworkTestBean.xml.tree.co">
                           <para>Panel Beans are loaded into a tree data
                           structure and visualized using a viewer. This
                           specifies the path within the tree using a
                           UNIX-style path. The path is arbitrary and will be
                           constructed as needed when the Bean is
                           loaded.</para>
                        </callout>
                     </calloutlist>
                  </example>

                  <para>After the Bean is compiled into a JAR file, the JAR
                  file and XML file need to be copied into
                  <filename>$TWEEK_BASE_DIR/share/tweek/beans</filename>. This
                  is the default path that Tweek searches for Beans at
                  startup, and it is a convenient place to put this example
                  Bean.</para>
               </section>
            </section>

            <section>
               <title>Running the Example</title>

               <para>With all the coding done and the code compiled, we can
               run the C++ application and connect multiple instances of the
               Tweek Java GUI to it. The steps to run the C++ application are
               as follows:</para>

               <orderedlist>
                  <listitem>
                     <para>Run a CORBA Naming Service. This is required so
                     that the C++ and Java ORBs can resolve symbolic
                     references.</para>
                  </listitem>

                  <listitem>
                     <para>Since Tweek uses omniORB for a C++ ORB (see <xref
                     linkend="orb-impl.appendix" /> for more information on
                     this), the environment variable
                     <envar>$OMNIORB_CONFIG</envar> must be set. This gives
                     the full path to an omniORB configuration file that
                     omniORB will load at runtime.</para>
                  </listitem>

                  <listitem>
                     <para>Run the C++ application.</para>
                  </listitem>

                  <listitem>
                     <para>Run the Tweek Java GUI. This will find and load all
                     the Beans in
                     <filename>$TWEEK_BASE_DIR/share/tweek/beans</filename>.</para>
                  </listitem>

                  <listitem>
                     <para>Within the Java GUI, connect to the CORBA Naming
                     Service started in step 1. The way the Bean is written,
                     it will request the subject held by the C++ application
                     automatically, and the slider will be updated to the
                     current value.</para>
                  </listitem>
               </orderedlist>
            </section>
         </section>

         <section id="file.loader.section">
            <title>File Loader</title>

            <para>Not everything written in Tweek must use Java, C++, IDL, and
            CORBA. The Tweek Java GUI is a generalized Bean-loading
            environment, and as such, its main focus is to load JavaBeans and
            present them to the user. Those Beans may take advantage of CORBA,
            but they are not required to do so. In this section, we show
            another sample Bean that is much simpler than the previous
            example.</para>

            <para>The Bean shown in this example can open and close multiple
            text files. To do this, the Bean implements the interface
            <interfacename>org.vrjuggler.tweek.beans.FileLoader</interfacename>.
            The Java code will be shown in separate pieces to make it easier
            to understand. The full code is in
            <filename>$TWEEK_BASE_DIR/share/test/FileOpenTestBean/fileopentestbean/FileOpenTestBean.java</filename>.
            An example makefile can be found in <xref
            linkend="FileLoader.makefile.section" />. within <xref
            linkend="makefile.appendix" />..</para>

            <section>
               <title>The JavaBean</title>

               <para>As in the previous example, we focus on the imported
               classes first. They are as follows:</para>

               <programlisting>package fileopentestbean;                                       <co
                     id="FileOpenTestBean.java.package"
                     linkends="FileOpenTestBean.java.package.co" />

import java.awt.*;                                              <co
                     id="FileOpenTestBean.java.import.awt"
                     linkends="FileOpenTestBean.java.std-imports.co" />
import java.io.File;                                            <co
                     id="FileOpenTestBean.java.import.io-File"
                     linkends="FileOpenTestBean.java.std-imports.co" />
import java.io.FileInputStream;                                 <co
                     id="FileOpenTestBean.java.import.io-FileInputStream"
                     linkends="FileOpenTestBean.java.std-imports.co" />
import javax.swing.*;                                           <co
                     id="FileOpenTestBean.java.import.swing"
                     linkends="FileOpenTestBean.java.std-imports.co" />
import org.vrjuggler.tweek.services.ExtensionFileFilter;        <co
                     id="FileOpenTestBean.java.import.ext-filter"
                     linkends="FileOpenTestBean.java.import.ext-filter.co" />
import org.vrjuggler.tweek.beans.FileLoader;                    <co
                     id="FileOpenTestBean.java.import.FileLoader"
                     linkends="FileOpenTestBean.java.import.FileLoader.co" />
</programlisting>

               <calloutlist>
                  <callout arearefs="FileOpenTestBean.java.package"
                           id="FileOpenTestBean.java.package.co">
                     <para>This Bean will be in the package
                     <literal>fileopentestbean</literal>.</para>
                  </callout>

                  <callout arearefs="FileOpenTestBean.java.import.awt FileOpenTestBean.java.import.io-File FileOpenTestBean.java.import.io-FileInputStream FileOpenTestBean.java.import.swing"
                           id="FileOpenTestBean.java.std-imports.co">
                     <para>These are the imports of standard Java classes. In
                     this Bean, we need two Java file I/O classes so that we
                     may load files.</para>
                  </callout>

                  <callout arearefs="FileOpenTestBean.java.import.ext-filter"
                           id="FileOpenTestBean.java.import.ext-filter.co">
                     <para>This line imports the Tweek Service Bean known as
                     the <classname>ExtensionFileFilter</classname>. This
                     provides a simplified mechanism for making file filters
                     typically used with <classname>JFileChooser</classname>
                     instances.</para>
                  </callout>

                  <callout arearefs="FileOpenTestBean.java.import.FileLoader"
                           id="FileOpenTestBean.java.import.FileLoader.co">
                     <para>This line imports the interface from the Tweek Bean
                     library that we will implement.</para>
                  </callout>
               </calloutlist>

               <para>Next, we show the class declaration and the member
               variables.</para>

               <programlisting>public class FileOpenTestBean
    extends JPanel                                              <co
                     id="FileOpenTestBean.java.superclass"
                     linkends="FileOpenTestBean.java.superclass.co" />
    implements java.io.Serializable, FileLoader                 <co
                     id="FileOpenTestBean.java.interfaces"
                     linkends="FileOpenTestBean.java.interfaces.co" />
{
   // Methods ...

   private int openFileCount = 0;                               <co
                     id="FileOpenTestBean.java.openFileCount"
                     linkends="FileOpenTestBean.java.openFileCount.co" />

   private BorderLayout mMainLayout    = new BorderLayout();
   private JLabel       mBeanTitle     = new JLabel();
   private JTabbedPane  mTextContainer = new JTabbedPane();     <co
                     id="FileOpenTestBean.java.mTextContainer"
                     linkends="FileOpenTestBean.java.mTextContainer.co" />
}</programlisting>

               <calloutlist>
                  <callout arearefs="FileOpenTestBean.java.superclass"
                           id="FileOpenTestBean.java.superclass.co">
                     <para>As the primary class for a Panel Bean, this class
                     must from <classname>javax.swing.JComponent</classname>
                     or some subclass thereof. In this case, the class will be
                     <classname>javax.swing.JPanel</classname>.</para>
                  </callout>

                  <callout arearefs="FileOpenTestBean.java.interfaces"
                           id="FileOpenTestBean.java.interfaces.co">
                     <para>JavaBeans are expected to implement
                     <interfacename>java.io.Serializable</interfacename>, and
                     this class does that. The more interesting interface for
                     this example is
                     <interfacename>org.vrjuggler.tweek.beans.FileLoader</interfacename>.
                     By implementing this interface, the Tweek Java GUI will
                     know that this Bean can manage files.</para>
                  </callout>

                  <callout arearefs="FileOpenTestBean.java.openFileCount"
                           id="FileOpenTestBean.java.openFileCount.co">
                     <para>This is a property of the class that keeps track of
                     the number of currently open files.</para>
                  </callout>

                  <callout arearefs="FileOpenTestBean.java.mTextContainer"
                           id="FileOpenTestBean.java.mTextContainer.co">
                     <para>This Bean is capable of opening multiple files, and
                     it will manage them with a
                     <classname>JTabbedPane</classname>.</para>
                  </callout>
               </calloutlist>

               <para>Now that we have the basics for the class, we can start
               implementing the <interfacename>FileLoader</interfacename>
               interface. Of the methods that must be implemented, the most
               complex is <methodname>openRequested()</methodname>. It will be
               shown last because of its length. We will begin instead with
               the simplest methods.</para>

               <programlisting linenumbering="numbered">public String getFileType()
{
   return "Text";                                               <co
                     id="FileOpenTestBean.java.getFileType"
                     linkends="FileOpenTestBean.java.getFileType.co" />
}

public boolean canOpenMultiple()
{
   return true;                                                 <co
                     id="FileOpenTestBean.java.canOpenMultiple"
                     linkends="FileOpenTestBean.java.canOpenMultiple.co" />
}

public boolean canSave()
{
   return false;                                                <co
                     id="FileOpenTestBean.java.canSave"
                     linkends="FileOpenTestBean.java.canSave.co" />
}

public boolean saveRequested()
{
   return false;                                                <co
                     id="FileOpenTestBean.java.saveRequested"
                     linkends="FileOpenTestBean.java.saveRequested.co" />
}

public boolean closeRequested()
{
   mTextContainer.remove(                                       <co
                     id="FileOpenTestBean.java.closeRequested"
                     linkends="FileOpenTestBean.java.closeRequested.co" />
      mTextContainer.getSelectedComponent()
   );
   openFileCount--;
   return true;
}

public int getOpenFileCount ()
{
   return openFileCount;                                        <co
                     id="FileOpenTestBean.java.getOpenFileCount"
                     linkends="FileOpenTestBean.java.getOpenFileCount.co" />
}</programlisting>

               <calloutlist>
                  <callout arearefs="FileOpenTestBean.java.getFileType"
                           id="FileOpenTestBean.java.getFileType.co">
                     <para>This returns the type of file (or files) that can
                     be loaded by the Bean. In this case, we are just loading
                     plain text files.</para>
                  </callout>

                  <callout arearefs="FileOpenTestBean.java.canOpenMultiple"
                           id="FileOpenTestBean.java.canOpenMultiple.co">
                     <para>This method is used to determine if the Bean can
                     open multiple files at one time. This Bean can because of
                     its tabbed pane.</para>
                  </callout>

                  <callout arearefs="FileOpenTestBean.java.canSave"
                           id="FileOpenTestBean.java.canSave.co">
                     <para>This method is used to determine if the Bean can
                     save files, and this Bean does not.</para>
                  </callout>

                  <callout arearefs="FileOpenTestBean.java.saveRequested"
                           id="FileOpenTestBean.java.saveRequested.co">
                     <para>Because this Bean does not save files, it simply
                     returns <constant>false</constant> if a save is
                     requested.</para>
                  </callout>

                  <callout arearefs="FileOpenTestBean.java.closeRequested"
                           id="FileOpenTestBean.java.closeRequested.co">
                     <para>When a close is requested, the currently selected
                     tab is removed and the open file count is
                     decremented.</para>
                  </callout>

                  <callout arearefs="FileOpenTestBean.java.getOpenFileCount"
                           id="FileOpenTestBean.java.getOpenFileCount.co">
                     <para>This simply returns the number of currently open
                     files.</para>
                  </callout>
               </calloutlist>

               <para>The above are all the methods of the
               <interfacename>FileLoader</interfacename> interface except
               <methodname>openRequested()</methodname>. We are now ready to
               move on to it.</para>

               <programlisting linenumbering="numbered">public boolean openRequested()
{
   // Initialize this to false since a lot of things can go wrong
   // in the process of opening files.  Once the file is opened
   // and read successfully, this can be changed to true.
   boolean opened = false;

   JFileChooser chooser = new JFileChooser();                   <co
                     id="FileOpenTestBean.java.openRequested.chooser"
                     linkends="FileOpenTestBean.java.openRequested.chooser.co" />
   chooser.setMultiSelectionEnabled(false);
   chooser.setDialogTitle("Text File Loader");
   chooser.setFileSelectionMode(JFileChooser.FILES_ONLY);

   // Only load .txt files.
   ExtensionFileFilter filter =
      new ExtensionFileFilter("Text Files");                    <co
                     id="FileOpenTestBean.java.openRequested.filter"
                     linkends="FileOpenTestBean.java.openRequested.filter.co" />
   filter.addExtension("txt");
   chooser.addChoosableFileFilter(filter);

   int status = chooser.showOpenDialog(this);                   <co
                     id="FileOpenTestBean.java.openRequested.show-chooser"
                     linkends="FileOpenTestBean.java.openRequested.show-chooser.co" />

   if ( status == JFileChooser.APPROVE_OPTION )
   {
      File file = chooser.getSelectedFile();

      if ( file.canRead() )                                     <co
                     id="FileOpenTestBean.java.openRequested.canRead"
                     linkends="FileOpenTestBean.java.openRequested.read.co" />
      {
         try
         {
            // Read the contents of the file into a byte[]
            // object.
            FileInputStream input_file =
              new FileInputStream(file);
            byte[] file_data = new byte[(int) file.length()];
            input_file.read(file_data);                         <co
                     id="FileOpenTestBean.java.openRequested.do-read"
                     linkends="FileOpenTestBean.java.openRequested.read.co" />

            // Create a text area to hold the contents of the
            // file.
            JTextArea text_area = new JTextArea();              <co
                     id="FileOpenTestBean.java.openRequested.text-area"
                     linkends="FileOpenTestBean.java.openRequested.text-area.co" />
            text_area.setEditable(false);
            text_area.insert(new String(file_data), 0);

            // Create a scroll pane to hold the text area; add
            // it to the tabbed pane with all the other
            // previously loaded scroll panes; and make the new
            // scroll pane the selected component.
            JScrollPane text_comp = new JScrollPane(text_area); <co
                     id="FileOpenTestBean.java.openRequested.scroll-pane"
                     linkends="FileOpenTestBean.java.openRequested.scroll-pane.co" />
            mTextContainer.add(text_comp, file.getName());
            mTextContainer.setSelectedComponent(text_comp);

            // Our work is done.
            openFileCount++;                                    <co
                     id="FileOpenTestBean.java.openRequested.open-inc"
                     linkends="FileOpenTestBean.java.openRequested.open-inc.co" />
            opened = true;
         }
         catch (java.io.FileNotFoundException ex)
         {
            JOptionPane.showMessageDialog(
               null,
               "Cannot find '" + file.getAbsolutePath() + "'",
               "Read Error", JOptionPane.ERROR_MESSAGE
            );
         }
         catch (java.io.IOException ex)
         {
            JOptionPane.showMessageDialog(
               null,
               "Error reading from '" + file.getAbsolutePath() +
                  "':" + ex.getMessage(),
               "Read Error", JOptionPane.ERROR_MESSAGE
            );
         }
      }
      else
      {
         JOptionPane.showMessageDialog(
            null,
            "Cannot read from file '" +
               file.getAbsolutePath() + "'",
            "Read Error", JOptionPane.ERROR_MESSAGE
         );
      }
   }

   return opened;
}</programlisting>

               <calloutlist>
                  <callout arearefs="FileOpenTestBean.java.openRequested.chooser"
                           id="FileOpenTestBean.java.openRequested.chooser.co">
                     <para>First, we create a
                     <classname>JFileChooser</classname> that will be used to
                     select a text file. It is configured to allow selection
                     of only a single file each time.</para>
                  </callout>

                  <callout arearefs="FileOpenTestBean.java.openRequested.filter"
                           id="FileOpenTestBean.java.openRequested.filter.co">
                     <para>Next, we create a filter for
                     <filename>.txt</filename> files that will be used by the
                     file chooser.</para>
                  </callout>

                  <callout arearefs="FileOpenTestBean.java.openRequested.show-chooser"
                           id="FileOpenTestBean.java.openRequested.show-chooser.co">
                     <para>With those steps taken, we now open the chooser and
                     wait for the user to select a file.</para>
                  </callout>

                  <callout arearefs="FileOpenTestBean.java.openRequested.canRead FileOpenTestBean.java.openRequested.do-read"
                           id="FileOpenTestBean.java.openRequested.read.co">
                     <para>If a readable file was chosen, we open it and read
                     its contents into an array of <type>byte</type>s.</para>
                  </callout>

                  <callout arearefs="FileOpenTestBean.java.openRequested.text-area"
                           id="FileOpenTestBean.java.openRequested.text-area.co">
                     <para>With the bytes read, we can now put the contents of
                     the text file into a read-only
                     <classname>JTexArea</classname> object.</para>
                  </callout>

                  <callout arearefs="FileOpenTestBean.java.openRequested.scroll-pane"
                           id="FileOpenTestBean.java.openRequested.scroll-pane.co">
                     <para>Next, we put the <classname>JTextArea</classname>
                     in a <classname>JScrollPane</classname> so that long
                     files can be viewed more easily. The scroll pane is added
                     to the tabbed pane and made the currently selected
                     panel.</para>
                  </callout>

                  <callout arearefs="FileOpenTestBean.java.openRequested.open-inc"
                           id="FileOpenTestBean.java.openRequested.open-inc.co">
                     <para>At this point, we are done, so we increment the
                     number of open files and set the return value to
                     <constant>true</constant> to indicate that a file was
                     opened successfully.</para>
                  </callout>
               </calloutlist>

               <para>This Bean uses no CORBA code and does not require C++
               code to act as a peer. This may be the case for many Panel
               Beans written for Tweek. Of course, this Bean could be extended
               to open files that are then handed off to C++ code through
               CORBA.</para>
            </section>

            <section>
               <title>XML File</title>

               <para>The XML file for this Bean is very simple. It simply
               lists the Bean file information and puts the Bean at the root
               of the Bean tree. The full file is shown in <xref
               linkend="FileOpenTestBean.xml.example" />.</para>

               <example id="FileOpenTestBean.xml.example">
                  <title>FileOpenTestBean.xml</title>

                  <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beanlist
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="http://www.vrjuggler.org/tweek/xsd/1.1/beanlist.xsd"&gt;
  &lt;guipanel name="File Open Test Bean"&gt;
    &lt;file
      name="${TWEEK_BASE_DIR}/share/tweek/beans/FileOpenTestBean.jar" 
      class="fileopentestbean.FileOpenTestBean" /&gt;
    &lt;tree path="/" /&gt;
  &lt;/guipanel&gt;
&lt;/beanlist&gt;</programlisting>
               </example>
            </section>
         </section>
      </chapter>

      <chapter id="cxx.client.chapter">
         <title>C++ as a Client</title>

         <indexterm>
            <primary>C++ client API</primary>
         </indexterm>

         <para>As of Tweek version 0.13.0, users can write C++ clients in
         addition to Java and Python clients. As of this writing, the
         interface is relatively low-level. The C++ counterpart of the Java
         class
         <classname>org.vrjuggler.tweek.net.corba.CorbaService</classname><indexterm>
               <primary>org.vrjuggler.tweek.net.CorbaService</primary>
            </indexterm> is used to communicate with a remote C++ server. The
         class is <classname>tweek::CorbaService</classname><indexterm>
               <primary>tweek::CorbaService</primary>
            </indexterm>, and its API is almost identical to the Java version.
         The basic idea is that users familiar with the Java API can easily
         make use of the C++ version and vice versa.</para>

         <para>In this chapter, we explain how to write C++ clients. First, we
         cover the CORBA Service, and then we show how to use it with a C++
         client application. The basic ideas are identical to those used in
         Java clients. The syntax varies slightly due to the differences in
         the C++ and Java mappings of IDL. Additionally, we do not need to be
         concerned with JavaBeans because we will be speaking strictly in
         terms of C++. There is nothing to prevent an ambitious user from
         developing a C++ counterpart to the Tweek Java GUI, however.</para>

         <section>
            <title>The CORBA Service</title>

            <para>The CORBA Service, implemented in the class
            <classname>tweek::CorbaService</classname><indexterm>
                  <primary>tweek::CorbaService</primary>
               </indexterm>, simplifies the use of CORBA for C++ clients.
            Instances are constructed by providing the host name and port
            where the CORBA Naming Service is listening for incoming requests.
            Once constructed, the CORBA Service must be initialized. This
            creates the local root POA, acquires a reference to the Naming
            Service, and starts the local ORB thread. At this point, the CORBA
            Service can be used exactly as it would be used in Java (see <xref
            linkend="prog.all.chapter" />). For example, the remote Subject
            Manager reference can be requested and servants (C++
            implementations of <interfacename>tweek::Observer</interfacename>)
            can be registered.</para>
         </section>

         <section>
            <title>Example Client Application</title>

            <para>To understand how to use the C++ client API, we will examine
            a simple application. Similar to the Java/C++ application we
            reviewed in <xref linkend="prog.all.chapter" />, this application
            makes use of an IDL-specified interface, and a C++ server. The key
            differences, then, are that there is no Java code in this case,
            and we will not need to use XML.</para>

            <para>All the code shown here, including a GNU makefile, can be
            found in the directory
            <filename>$TWEEK_BASE_DIR/share/tweek/test/CxxClient</filename>.
            In the following sections, we will refer to the specific files and
            highlight key sections within them. We assume that readers have
            already read and understood <xref linkend="prog.all.chapter" />.
            This is important because we will refer back to concepts
            illustrated in that chapter. Further, we will not present the
            server code in this chapter because it is nearly identical to the
            code for the server discussed previously. Interested readers can
            review the file <filename>server.cpp</filename>.</para>

            <section id="StringSubject.interface.section">
               <title><interfacename>StringSubject</interfacename>
               Interface</title>

               <para>As usual, we begin by defining an interface. For this
               example, we will use an interface that provides access to a
               simple string object. The server (Subject) will maintain the
               value of the string, and the clients (Observers) will be able
               to query and manipulate the string. The interface will be
               called
               <interfacename>CxxClientTest::StringSubject</interfacename>.
               The code for the interface is shown in <xref
               linkend="StringSubject.idl.example" />.</para>

               <example id="StringSubject.idl.example">
                  <title>StringSubject.idl</title>

                  <programlisting>#ifndef _CXX_CLIENT_TEST_STRING_SUBJECT_IDL_
#define _CXX_CLIENT_TEST_STRING_SUBJECT_IDL_

#include &lt;tweek/idl/Subject.idl&gt;

module CxxClientTest
{
   interface StringSubject : tweek::Subject   <co
                        id="StringSubject.interface.decl"
                        linkends="StringSubject.interface.decl.co" />
   {
      void setValue(in string val);           <co id="StringSubject.setValue"
                        linkends="StringSubject.accessors.co" />
      string getValue();                      <co id="StringSubject.getValue"
                        linkends="StringSubject.accessors.co" />
   };
};

#endif /* _CXX_CLIENT_TEST_STRING_SUBJECT_IDL_ */</programlisting>

                  <calloutlist>
                     <callout arearefs="StringSubject.interface.decl"
                              id="StringSubject.interface.decl.co">
                        <para>As with all user-defined Subjects, we derive our
                        interface from
                        <interfacename>tweek::Subject</interfacename>.</para>
                     </callout>

                     <callout arearefs="StringSubject.setValue StringSubject.getValue"
                              id="StringSubject.accessors.co">
                        <para>These methods define the accessors for the
                        encapsulated string value. Clients will invoke these
                        to query and to manipulate the state of the remote
                        Subject.</para>
                     </callout>
                  </calloutlist>
               </example>
            </section>

            <section>
               <title><interfacename>StringSubject</interfacename> Interface
               Implementation</title>

               <para>Now that we have our interface defined abstractly, we
               must provide a C++ implementation of the Subject. This will be
               done in the files <filename>StringSubjectImpl.cpp</filename>
               and <filename>StringSubjectImpl.h</filename>. We begin with the
               header file, shown in <xref
               linkend="StringSubjectImpl.h.example" />. While the example
               code may appear long, there is only slight variation from
               previous Subject implementation header files. We highlight the
               important bits, of course.</para>

               <example id="StringSubjectImpl.h.example">
                  <title>StringSubjectImpl.h</title>

                  <programlisting linenumbering="numbered">#ifndef _STRING_SUBJECT_IMPL_H_
#define _STRING_SUBJECT_IMPL_H_

#include &lt;tweek/tweekConfig.h&gt;

#include &lt;string&gt;

#include &lt;vpr/vpr.h&gt;
#include &lt;vpr/Sync/Mutex.h&gt;
#include &lt;tweek/CORBA/SubjectImpl.h&gt;
#include &lt;StringSubject.h&gt;                                     <co
                        id="StringSubjectImpl.h.include"
                        linkends="StringSubjectImpl.h.include.co" />

namespace CxxClientTest
{

/**
 * This class is an extension to the base Tweek SubjectImpl
 * class.  It uses multiple inheritance with that class and
 * with the generated CORBA class corresponding to the IDL for
 * StringSubject.
 */
class StringSubjectImpl
   : public POA_CxxClientTest::StringSubject                   <co
                        id="StringSubjectImpl.h.decl"
                        linkends="StringSubjectImpl.h.decl.co" />
   , public tweek::SubjectImpl
{
public:
   StringSubjectImpl() : tweek::SubjectImpl(), mValue("")
   {
      /* Do nothing. */ ;
   }

   virtual ~StringSubjectImpl()
   {
      /* Do nothing. */ ;
   }

   /**
    * Sets this subject's internal value.
    */
   virtual void setValue(const char* value);                   <co
                        id="StringSubjectImpl.h.setValue"
                        linkends="StringSubjectImpl.h.virtuals.co" />

   /**
    * Returns this subject's internal value.
    */
   virtual char* getValue();                                   <co
                        id="StringSubjectImpl.h.getValue"
                        linkends="StringSubjectImpl.h.virtuals.co" />

   /**
    * This overriding method is needed so that the correct
    * type is returned when the _this() method is invoked.
    * Without this method, an object of type tweek::Subject_ptr
    * would be returned.
    */
   CxxClientTest::StringSubject_ptr _this()                    <co
                        id="StringSubjectImpl.h.this"
                        linkends="StringSubjectImpl.h.this.co" />
   {
      return POA_CxxClientTest::StringSubject::_this();
   }

private:
   std::string mValue;      /**&lt; Our value */                  <co
                        id="StringSubjectImpl.h.mValue"
                        linkends="StringSubjectImpl.h.mValue.co" />

   /** A mutex to protect mValue accesses */
   vpr::Mutex  mValueLock;                                     <co
                        id="StringSubjectImpl.h.mutex"
                        linkends="StringSubjectImpl.h.mutex.co" />
};

} // End of CxxClientTest namespace

#endif /* _STRING_SUBJECT_IMPL_H_ */</programlisting>

                  <calloutlist>
                     <callout arearefs="StringSubjectImpl.h.include"
                              id="StringSubjectImpl.h.include.co">
                        <para>We must be sure to include the header that
                        defines the base class from which we will derive our
                        implementation. Remember that this code will be
                        generated by the IDL compiler.</para>
                     </callout>

                     <callout arearefs="StringSubjectImpl.h.decl"
                              id="StringSubjectImpl.h.decl.co">
                        <para>As usual, we declare our implementation so that
                        it derives from the class generated by the IDL
                        compiler
                        (<classname>POA_CxxClientTest::StringSubject</classname>)
                        and from the basic Tweek Subject implementation class
                        (<classname>tweek::SubjectImpl</classname>).</para>
                     </callout>

                     <callout arearefs="StringSubjectImpl.h.setValue StringSubjectImpl.h.getValue"
                              id="StringSubjectImpl.h.virtuals.co">
                        <para>These are the pure virtual methods defined by
                        <classname>POA_CxxClientTest::StringSubject</classname>
                        that we must implement. As in previous examples, this
                        is where we will do the work of accessing the
                        encapsulated string value.</para>
                     </callout>

                     <callout arearefs="StringSubjectImpl.h.this"
                              id="StringSubjectImpl.h.this.co">
                        <para>As with all C++ Subject implementations, we must
                        override the method <methodname>_this()</methodname>
                        in order to return the correct type. This is critical
                        for proper use of the specific Subject type.</para>
                     </callout>

                     <callout arearefs="StringSubjectImpl.h.mValue"
                              id="StringSubjectImpl.h.mValue.co">
                        <para>Here we have the string value that will be
                        encapsulated within the servant instance. For
                        convenience, we use the
                        <classname>std::string</classname> type, though it
                        will require careful handling of the
                        <type>char*</type> data that CORBA actually passes
                        around.</para>
                     </callout>

                     <callout arearefs="StringSubjectImpl.h.mutex"
                              id="StringSubjectImpl.h.mutex.co">
                        <para>In this Subject implementation, we are being
                        more paranoid about concurrent accesses to
                        <varname>mValue</varname>, so we will protect it with
                        a mutex.</para>
                     </callout>
                  </calloutlist>
               </example>

               <para>Next, we look at the very simple implementations of
               <methodname>CxxClientTest::StringSubjectImpl::setValue()</methodname>
               and
               <methodname>CxxClientTest::StringSubjectImpl::getValue()</methodname>.
               These are found in the file
               <filename>StringSubjectImpl.cpp</filename>, and the code is
               shown in <xref linkend="StringSubjectImpl.cpp.example" />. It
               is important to note the use of guards in the method
               implementations. These provide an exception-safe mechanism for
               controlling access to the data member
               <varname>mValue</varname>. When constructed, the guard locks
               the mutex passed as the argument to the constructor. When the
               guard goes out of scope, the mutex is automatically
               unlocked.</para>

               <example id="StringSubjectImpl.cpp.example">
                  <title>StringSubjectImpl.cpp</title>

                  <programlisting linenumbering="numbered">#include &lt;vpr/Sync/Guard.h&gt;
#include &lt;StringSubjectImpl.h&gt;                              <co
                        id="StringSubjectImpl.cpp.include"
                        linkends="StringSubjectImpl.cpp.include.co" />

namespace CxxClientTest
{

void StringSubjectImpl::setValue(const char* value)
{
   {
      vpr::Guard&lt;vpr::Mutex&gt; val_guard(mValueLock);         <co
                        id="StringSubjectImpl.cpp.setValue.guard"
                        linkends="StringSubjectImpl.cpp.setValue.co" />
      mValue = std::string(value);                          <co
                        id="StringSubjectImpl.cpp.setValue.assign"
                        linkends="StringSubjectImpl.cpp.setValue.co" />
   }

   // Notify any observers that our value has changed.  This
   // is very important.
   tweek::SubjectImpl::notify();                            <co
                        id="StringSubjectImpl.cpp.setValue.notify"
                        linkends="StringSubjectImpl.cpp.notify.co" />
}

char* StringSubjectImpl::getValue()
{
   vpr::Guard&lt;vpr::Mutex&gt; val_guard(mValueLock);            <co
                        id="StringSubjectImpl.cpp.getValue.guard"
                        linkends="StringSubjectImpl.cpp.getValue.co" />
   return CORBA::string_dup(mValue.c_str());                <co
                        id="StringSubjectImpl.cpp.getValue.return"
                        linkends="StringSubjectImpl.cpp.getValue.co" />
}

} // End CxxClientTest namespace</programlisting>

                  <calloutlist>
                     <callout arearefs="StringSubjectImpl.cpp.include"
                              id="StringSubjectImpl.cpp.include.co">
                        <para>As usual, we must include our header file to get
                        the necessary declarations.</para>
                     </callout>

                     <callout arearefs="StringSubjectImpl.cpp.setValue.guard StringSubjectImpl.cpp.setValue.assign"
                              id="StringSubjectImpl.cpp.setValue.co">
                        <para>Within this scoped block, we lock the
                        <varname>mValueLock</varname> using a guard and assign
                        a new value to <varname>mValue</varname>. Upon exiting
                        this block, the guard goes out of scope, and
                        <varname>mValueLock</varname> is unlocked.</para>
                     </callout>

                     <callout arearefs="StringSubjectImpl.cpp.setValue.notify"
                              id="StringSubjectImpl.cpp.notify.co">
                        <para>As with all cases where we modify the state of
                        the Subject, we must notify any Observers who are
                        attached to us. Just as the comment notes, this is
                        very important.</para>
                     </callout>

                     <callout arearefs="StringSubjectImpl.cpp.getValue.guard StringSubjectImpl.cpp.getValue.return"
                              id="StringSubjectImpl.cpp.getValue.co">
                        <para>Here, we return the current value of
                        <varname>mValue</varname>. We use a guard again to
                        simplify unlocking the mutex (it happens automatically
                        upon return). Note that we make a copy of the memory
                        contained in <varname>mValue</varname> using
                        <function>CORBA::string_dup()</function>. Making a
                        copy is required by CORBA.</para>
                     </callout>
                  </calloutlist>
               </example>
            </section>

            <section>
               <title id="string.observer.section">Observer
               Implementation</title>

               <para>With the Subject implemented, we now turn our attention
               to a C++ Observer implementation. Its implementation we will be
               very simple. Its <methodname>update()</methodname> method will
               query the current string value and print it to the console. The
               goal here is to demonstrate how to write a C++ Observer, not
               how to write an <emphasis>interesting</emphasis>
               Observer.</para>

               <example id="StringObserverImpl.h.example">
                  <title>StringObserverImpl.h</title>

                  <programlisting linenumbering="numbered">#ifndef _STRING_OBSERVER_IMPL_H_
#define _STRING_OBSERVER_IMPL_H_

#include &lt;tweek/CORBA/Observer.h&gt;                        <co
                        id="StringObserverImpl.h.Observer.include"
                        linkends="StringObserverImpl.h.includes.co" />
#include &lt;StringSubject.h&gt;                               <co
                        id="StringObserverImpl.h.StringSubject.include"
                        linkends="StringObserverImpl.h.includes.co" />

class StringObserverImpl : public POA_tweek::Observer    <co
                        id="StringObserverImpl.h.decl"
                        linkends="StringObserverImpl.h.decl.co" />
{
public:
   StringObserverImpl(CxxClientTest::StringSubject_var subject)
      : mSubject(subject)
   {
      /* Do nothing. */ ;
   }

   virtual ~StringObserverImpl()
   {
      /* Do nothing. */ ;
   }

   virtual void update();                                <co
                        id="StringObserverImpl.h.update"
                        linkends="StringObserverImpl.h.update.co" />

   void detach()
   {
      mSubject-&gt;detach(_this());                         <co
                        id="StringObserverImpl.h.detach"
                        linkends="StringObserverImpl.h.detach.co" />
   }

private:
   CxxClientTest::StringSubject_var mSubject;            <co
                        id="StringObserverImpl.h.mSubject"
                        linkends="StringObserverImpl.h.mSubject.co" />
};

#endif /* _STRING_OBSERVER_IMPL_H_ */</programlisting>

                  <calloutlist>
                     <callout arearefs="StringObserverImpl.h.Observer.include StringObserverImpl.h.StringSubject.include"
                              id="StringObserverImpl.h.includes.co">
                        <para>First, we include the headers we need. The first
                        declares the basic
                        <classname>tweek::Observer</classname> C++ interface.
                        The second includes the
                        <classname>tweek::StringSubject</classname> interface.
                        We need this header so that we can hang onto a
                        reference to our Subject.</para>
                     </callout>

                     <callout arearefs="StringObserverImpl.h.decl"
                              id="StringObserverImpl.h.decl.co">
                        <para>Our Observer implementation derives from the
                        basic Tweek Observer class
                        <classname>POA_tweek::Observer</classname>. The Java
                        equivalent is
                        <classname>tweek.ObserverPOA</classname>. Refer to
                        <xref linkend="SliderObserverImpl.java.example" /> in
                        <xref linkend="implement.observer.java.section" /> to
                        see the correspondence.</para>
                     </callout>

                     <callout arearefs="StringObserverImpl.h.update"
                              id="StringObserverImpl.h.update.co">
                        <para>The <methodname>update()</methodname> method
                        must be implemented for all subclasses of
                        <classname>POA_tweek::Observer</classname>. Here, we
                        just declare the method; the implementation will be
                        shown in <xref
                        linkend="StringObserverImpl.cpp.example" />.</para>
                     </callout>

                     <callout arearefs="StringObserverImpl.h.detach"
                              id="StringObserverImpl.h.detach.co">
                        <para>The <methodname>detach()</methodname> method is
                        provided as an easy way to detach the Observer from
                        its Subject. Ideally, this would be done in the
                        destructor so that the detaching process happens
                        automatically when the Observer servant is deleted.
                        Doing so leads to incorrect deactivation of the
                        servant, however. Instead, we provide this method as a
                        way to perform the detachment before servant
                        deactivation or deletion occurs.</para>
                     </callout>

                     <callout arearefs="StringObserverImpl.h.mSubject"
                              id="StringObserverImpl.h.mSubject.co">
                        <para>Finally, we have a member variable that we will
                        use to retain a reference our Subject. This allows the
                        Observer to be passed around to functions without
                        passing its Subject explicitly. Further, we will see
                        that having a reference to the Subject is required for
                        the <methodname>update()</methodname> method
                        implementation to work.</para>
                     </callout>
                  </calloutlist>
               </example>

               <para>Now, we show the implementation of
               <methodname>StringObserverImpl::update()</methodname>. This
               method is implemented in
               <filename>StringObserverImpl.cpp</filename>. While the method
               body is very short, we use the <filename>.cpp</filename> file
               to encourage the implementation of methods outside of the class
               declaration.</para>

               <example id="StringObserverImpl.cpp.example">
                  <title>StringObserverImpl.cpp</title>

                  <programlisting>#include &lt;iostream&gt;
#include &lt;StringObserverImpl.h&gt;                     <co
                        id="StringObserverImpl.cpp.include"
                        linkends="StringObserverImpl.cpp.include.co" />

void StringObserverImpl::update()
{
   char* cur_value = mSubject-&gt;getValue();          <co
                        id="StringObserverImpl.cpp.update.query"
                        linkends="StringObserverImpl.cpp.update.query.co" />
   std::cout &lt;&lt; "Current string value is now '"     <co
                        id="StringObserverImpl.cpp.update.print"
                        linkends="StringObserverImpl.cpp.update.query.co" />
             &lt;&lt; cur_value &lt;&lt; "'" &lt;&lt; std::endl;
   delete cur_value;                                <co
                        id="StringObserverImpl.cpp.update.delete"
                        linkends="StringObserverImpl.cpp.update.delete.co" />
}</programlisting>

                  <calloutlist>
                     <callout arearefs="StringObserverImpl.cpp.include"
                              id="StringObserverImpl.cpp.include.co">
                        <para>As usual, we have to include our header file to
                        get the class declaration information.</para>
                     </callout>

                     <callout arearefs="StringObserverImpl.cpp.update.query StringObserverImpl.cpp.update.print"
                              id="StringObserverImpl.cpp.update.query.co">
                        <para>Since <methodname>update()</methodname> is only
                        called when the state of the Subject changes, we need
                        to query its current state. Once we get the current
                        string value back, we print it to the console. The
                        value is enclosed in single quotes so that any leading
                        or trailing whitespace is displayed clearly.</para>
                     </callout>

                     <callout arearefs="StringObserverImpl.cpp.update.delete"
                              id="StringObserverImpl.cpp.update.delete.co">
                        <para>Lastly, we delete the memory returned by
                        <methodname>CxxClientTest::StringSubject::getValue()</methodname>.
                        The burden for freeing this memory is on the client,
                        as per standard CORBA operating procedure.</para>
                     </callout>
                  </calloutlist>
               </example>
            </section>

            <section>
               <title>Client Application</title>

               <para>Finally, we look at the C++ client application. This
               brings everything together and makes use of the
               <classname>tweek::CorbaService</classname> class to contact the
               remote server. The application shown below is more complicated
               than the server because more work must done. We must initialize
               the local CORBA Service (the local ORB); we must pick out the
               correct Subject Manager reference; and we must get the correct
               <interfacename>CxxClientTest::StringSubject</interfacename>
               reference from the Subject Manager. Once all of those steps are
               completed, we can create an Observer servant (an instance of
               <classname>StringObserverImpl</classname>) and attach it to the
               remote Subject.</para>

               <para>The file containing the complete client application
               source is client.cpp. We will examine it in three parts: the
               required headers, the implementation of
               <function>main()</function>, and the Subject Manager
               lookup.</para>

               <example>
                  <title>client.cpp: Required Header Files</title>

                  <programlisting>#include &lt;iostream&gt;
#include &lt;string&gt;

#include &lt;vpr/vpr.h&gt;
#include &lt;vpr/Util/Debug.h&gt;
#include &lt;tweek/Client/CorbaService.h&gt;    <co
                        id="client.cpp.include.CorbaService"
                        linkends="client.cpp.include.CorbaService.co" />
#include &lt;tweek/CORBA/SubjectManager.h&gt;   <co
                        id="client.cpp.include.SubjectManager"
                        linkends="client.cpp.include.SubjectManager.co" />

#include &lt;StringObserverImpl.h&gt;           <co
                        id="client.cpp.include.StringObserverImpl"
                        linkends="client.cpp.include.StringObserverImpl.co" />
</programlisting>

                  <calloutlist>
                     <callout arearefs="client.cpp.include.CorbaService"
                              id="client.cpp.include.CorbaService.co">
                        <para>The key to the C++ client interface is the CORBA
                        Service. Its declaration is found in
                        <filename>tweek/Client/CorbaService.h</filename>.</para>
                     </callout>

                     <callout arearefs="client.cpp.include.SubjectManager"
                              id="client.cpp.include.SubjectManager.co">
                        <para>As in Java clients, the Subject Manager plays a
                        vital role in getting references to remote Subjects.
                        Note that the file we include here is generated by the
                        IDL compiler and provides only the basic interface. We
                        will not be using the actual Subject Manager C++
                        implementation here. That is only used on the server
                        side.</para>
                     </callout>

                     <callout arearefs="client.cpp.include.StringObserverImpl"
                              id="client.cpp.include.StringObserverImpl.co">
                        <para>Lastly, we include the implementation of our
                        Observer. We will be creating an instance of this
                        class to act as the servant for an Observer reference.
                        The servant we create will be attached to a remote
                        Subject, just as in all Java clients.</para>
                     </callout>
                  </calloutlist>
               </example>

               <para>Next, we look at the implementation of the application's
               <function>main()</function> function. This is where the bulk of
               the work is done. Of course, in real-world use, modularizing
               the code would be much better than dumping most of it in
               <function>main()</function>. For the purposes of this example,
               we can get by with having most of the code in
               <function>main()</function>.</para>

               <para>Note the use of try/catch blocks in the client
               application code. As in the case of server applications (refer
               to <xref linkend="SliderSubject.server.section" />), we are
               careful about handling exceptions properly. Remember that CORBA
               uses exceptions extensively to indicate errors, and thus it is
               necessary for user code to catch them.</para>

               <example id="client.cpp.main.example1">
                  <title>client.cpp: Implementation of
                  <function>main()</function>, Part I</title>

                  <programlisting linenumbering="numbered">int main(int argc, char* argv[])
{
   std::string ns_host, iiop_ver;
   vpr::Uint16 ns_port;

   std::cout &lt;&lt; "Naming Service host: ";                        <co
                        id="client.cpp.main.nshost"
                        linkends="client.cpp.main.naming.info.co" />
   std::cin &gt;&gt; ns_host;

   std::cout &lt;&lt; "Naming Service port (usually 2809): ";         <co
                        id="client.cpp.main.nsport"
                        linkends="client.cpp.main.naming.info.co" />
   std::cin &gt;&gt; ns_port;

   std::cout &lt;&lt; "IIOP version (usually 1.0): ";                 <co
                        id="client.cpp.main.iiopver"
                        linkends="client.cpp.main.naming.info.co" />
   std::cin &gt;&gt; iiop_ver;

   // Create the local CORBA Service using the Naming Service
   // URI information we just collected.
   tweek::CorbaService corba_service(ns_host, ns_port,          <co
                        id="client.cpp.main.corba-service.construct"
                        linkends="client.cpp.main.corba-service.construct.co" />
                                     iiop_ver);

   try
   {
      // Attempt to initialize the CORBA Service.
      if ( corba_service.init(argc, argv) )                     <co
                        id="client.cpp.main.corba-service.init"
                        linkends="client.cpp.main.corba-service.init.co" />
      {
         // This will hold the reference to the Subject Manager
         // we use.
         tweek::SubjectManager_var subj_mgr =
            chooseSubjectManager(corba_service);                <co
                        id="client.cpp.main.SubjectManager.choose"
                        linkends="client.cpp.main.SubjectManager.choose.co" />

         // Verify that we actually got a Subject Manager
         // reference back from chooseSubjectManager.
         if ( ! CORBA::is_nil(subj_mgr) )                       <co
                        id="client.cpp.main.SubjectManager.verify"
                        linkends="client.cpp.main.SubjectManager.choose.co" />
         {
            // Request the Subject with which we will communicate.
            // This hard-coded Subject name is not necessarily a
            // good thing.
            tweek::Subject_var subj =
               subj_mgr-&gt;getSubject("StringSubject");           <co
                        id="client.cpp.main.subject.request"
                        linkends="client.cpp.main.subject.request.co" />

            // If the Subject Manager knows about the Subject
            // named above, then we are good to go.
            if ( ! CORBA::is_nil(subj) )                        <co
                        id="client.cpp.subject.verify"
                        linkends="client.cpp.main.subject.request.co" />
            {
               ...  // Shown in the next example block
            }
         }
         // We did not get a Subject Manager reference back for
         // some reason.
         else
         {
            vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
               &lt;&lt; "No Subject Manager chosen--exiting.\n"
               &lt;&lt; vprDEBUG_FLUSH;
         }
      }
      // The CORBA Service initialization failed.
      else
      {
         vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
            &lt;&lt; "CORBA Service failed to initialize\n"
            &lt;&lt; vprDEBUG_FLUSH;
      }
   }
   catch (...)
   {
      vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
         &lt;&lt; "Caught an unknown exception!\n" &lt;&lt; vprDEBUG_FLUSH;
   }

   return 0;
}</programlisting>

                  <calloutlist>
                     <callout arearefs="client.cpp.main.nshost client.cpp.main.nsport client.cpp.main.iiopver"
                              id="client.cpp.main.naming.info.co">
                        <para>Here, we query input from the user to get Naming
                        Service information. We need the host name where the
                        Naming Service is running, the port on which it is
                        listening, and the version of <glossterm
                        linkend="gloss.iiop">IIOP</glossterm> to use. Using
                        the values we get from the user, we can construct an
                        instance of
                        <classname>tweek::CorbaService</classname>.
                        Internally, it will use the values to create a URI for
                        looking up the Naming Service reference.</para>
                     </callout>

                     <callout arearefs="client.cpp.main.corba-service.construct"
                              id="client.cpp.main.corba-service.construct.co">
                        <para>Once we have all the necessary initialization
                        pieces, we can construct an instance of
                        <classname>tweek::CorbaService</classname>. Simply
                        creating an instance of this class does not perform
                        any CORBA-related activities. That is the next
                        step.</para>
                     </callout>

                     <callout arearefs="client.cpp.main.corba-service.init"
                              id="client.cpp.main.corba-service.init.co">
                        <para>Now we initialize the local CORBA Service. We
                        pass in <varname>argc</varname> and
                        <varname>argv</varname> in case the user provided any
                        CORBA-specific command-line parameters. (Any such
                        parameters will be stripped from
                        <varname>argv</varname>, and <varname>argc</varname>
                        will be decremented accordingly.) If initialization
                        succeeds, we proceed to requesting the Subject Manager
                        reference.</para>
                     </callout>

                     <callout arearefs="client.cpp.main.SubjectManager.choose client.cpp.main.SubjectManager.verify"
                              id="client.cpp.main.SubjectManager.choose.co">
                        <para>Using the CORBA Service, we choose the Subject
                        Manager through which all Subject requests will be
                        handled. The work for making this choice is offloaded
                        to the helper function
                        <function>chooseSubjectManager()</function>, shown in
                        <xref
                        linkend="client.cpp.chooseSubjectManager.example" />.
                        For now, we just assume that we got back some
                        reference, possibly nil, to a remote
                        <interfacename>tweek::SubjectManager</interfacename>
                        object. Since we do not know for sure what the state
                        of things is on the server side or what decision the
                        user made, we verify that we did not get back a nil
                        reference. If we got back a valid Subject Manager
                        reference, we can use it just as we would in a Java
                        client to request Subject references by name.</para>
                     </callout>

                     <callout arearefs="client.cpp.main.subject.request client.cpp.subject.verify"
                              id="client.cpp.main.subject.request.co">
                        <para>Next, we request the reference to the remote
                        Subject. The symbolic name we use here is the same as
                        that specified in the server application (not shown in
                        this chapter). Note that using a hard-coded name in
                        this way is not recommended, but we use it here for
                        the sake of simplicity. Once we have a reference, we
                        verify that it is not nil before trying to use
                        it.</para>
                     </callout>
                  </calloutlist>
               </example>

               <para>We now narrow our attention to the handling of the
               Subject reference that was returned by the Subject Manager. The
               code shown in <xref linkend="client.cpp.main.example2" /> comes
               from the <quote>...</quote> block in <xref
               linkend="client.cpp.main.example1" />. At this point in the
               application execution, we know that we have a non-nil
               <interfacename>tweek::Subject</interfacename> reference, so we
               need to narrow it to our specific type, create an Observer
               servant, and attach it to the remote Subject.</para>

               <example id="client.cpp.main.example2">
                  <title>client.cpp: Implementation of
                  <function>main()</function>, Part II</title>

                  <programlisting linenumbering="numbered">StringObserverImpl* string_observer(NULL);
PortableServer::ObjectId_var observer_id;

try
{
   // Attempt to narrow subj to the more specific reference type
   // CxxClientTest::StringSubject_var.  If this fails, an
   // exception will be thrown and caught below.
   CxxClientTest::StringSubject_var string_subj =
      CxxClientTest::StringSubject::_narrow(subj);              <co
                        id="client.cpp.main.subject.narrow"
                        linkends="client.cpp.main.subject.narrow.co" />

   // Request the current value before we create the Observer.
   // In this way, we can see the persistent state maintained
   // by the Subject.
   char* cur_value = string_subj-&gt;getValue();
   std::cout &lt;&lt; "Current string value is '" &lt;&lt; cur_value &lt;&lt; "'"
             &lt;&lt; std::endl;
   delete cur_value;

   // Create our Observer servant.
   string_observer = new StringObserverImpl(string_subj);       <co
                        id="client.cpp.main.servant.construct"
                        linkends="client.cpp.main.servant.construct.co" />

   // Register the newly created servant with our ORB's POA.
   observer_id =
      corba_service.registerObject(string_observer,
                                   "StringObserver");           <co
                        id="client.cpp.main.servant.register"
                        linkends="client.cpp.main.servant.register.co" />

   // This could be done in the StringObserverImpl constructor,
   // but we do it here in this example just to make it clear
   // that it is important.
   string_subj-&gt;attach(string_observer-&gt;_this());               <co
                        id="client.cpp.main.observer.attach" />

   const std::string exit_string("Q");
   std::string cur_string;

   for ( ;; )                                                   <co
                        id="client.cpp.main.loop"
                        linkends="client.cpp.main.loop.co" />
   {
      std::cout &lt;&lt; "Enter a string (Q to quit): ";
      std::cin &gt;&gt; cur_string;

      if ( exit_string != cur_string )
      {
         string_subj-&gt;setValue(cur_string.c_str());             <co
                        id="client.cpp.main.subject.setValue" />
      }
      else
      {
         break;
      }
   }
}
catch (...)
{
   vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
      &lt;&lt; "Caught an unknown exception during object interaction!\n"
      &lt;&lt; vprDEBUG_FLUSH;
}

// We're done, so now we have to clean up after ourselves.
// The order of operations here is important.
if ( NULL != string_observer )
{
   string_observer-&gt;detach();                                   <co
                        id="client.cpp.main.observer.detach"
                        linkends="client.cpp.main.cleanup.co" />
   corba_service.unregisterObject(observer_id);                 <co
                        id="client.cpp.main.servant.unregister"
                        linkends="client.cpp.main.cleanup.co" />
   delete string_observer;                                      <co
                        id="client.cpp.main.servant.delete"
                        linkends="client.cpp.main.cleanup.co" />
}</programlisting>

                  <calloutlist>
                     <callout arearefs="client.cpp.main.subject.narrow"
                              id="client.cpp.main.subject.narrow.co">
                        <para>Given a non-nil Subject reference, we now need
                        to narrow it to our specific Subject type,
                        <interfacename>CxxClientTest::StringSubject</interfacename>.
                        If the narrowing fails, an exception will be thrown.
                        In that case, we are done because we did not get back
                        a reference we can use.</para>
                     </callout>

                     <callout arearefs="client.cpp.main.servant.construct"
                              id="client.cpp.main.servant.construct.co">
                        <para>If the narrowing succeeded, then we can create
                        an Observer servant (an instance of our class
                        <classname>StringObserverImpl</classname>). In our
                        local ORB, this servant will handle accesses from
                        remote objects—namely, the Subject to which it is
                        attached.</para>
                     </callout>

                     <callout arearefs="client.cpp.main.servant.register"
                              id="client.cpp.main.servant.register.co">
                        <para>Next, we register our newly created Observer
                        servant with the POA in the local CORBA Service. We
                        give it an arbitrary name, and it gives us a unique
                        identifier for the servant. We will need this
                        identifier later when the application is shutting down
                        and cleaning up after itself.</para>
                     </callout>

                     <callout arearefs="client.cpp.main.observer.attach"
                              id="client.cpp.main.observer.attach.co">
                        <para>At long last, we can attach our Observer to the
                        remote Subject. The mechanism for doing this is nearly
                        identical to the Java version. The only difference is
                        the use of the <literal>-&gt;</literal> operator,
                        which is not present in Java. Once the Subject knows
                        about our Observer, it will be informed of all state
                        changes.</para>
                     </callout>

                     <callout arearefs="client.cpp.main.loop"
                              id="client.cpp.main.loop.co">
                        <para>In this loop, we ask the user for input and then
                        pass that input to the Subject's
                        <methodname>setValue()</methodname> method. We do this
                        until the user enters the string
                        <literal>"Q"</literal>, which denotes that s/he wants
                        to quit the application.</para>
                     </callout>

                     <callout arearefs="client.cpp.main.subject.setValue"
                              id="client.cpp.main.subject.setValue.co">
                        <para>This is where we modify the state of the remote
                        Subject. We pass the C string version of the
                        user-specified string as the argument to
                        <methodname>CxxClientTest::StringSubject::setValue()</methodname>.</para>
                     </callout>

                     <callout arearefs="client.cpp.main.observer.detach client.cpp.main.servant.unregister client.cpp.main.servant.delete"
                              id="client.cpp.main.cleanup.co">
                        <para>Once the user has requested to quit the
                        application, we need to clean up the servant we
                        constructed earlier. First, we detach the Observer
                        from the remote Subject. Next, we unregister our
                        servant using the ID returned by the local CORBA
                        Service. Finally, we delete the heap memory allocated
                        for the servant. With that, we are done.</para>
                     </callout>
                  </calloutlist>
               </example>

               <para>The last part of the client application is the choice of
               the Subject Manager reference to use. In this example, we put
               that code in the helper function
               <function>chooseSubjectManager()</function>. In this function,
               we request the list of valid Subject Manager references from
               the local CORBA Service and present the information about each
               one to the user. Using this information, the user selects one,
               and that reference is then returned to the caller. In a
               real-world example, the Subject Manager chooser would be much
               more sophisticated than what we show in <xref
               linkend="client.cpp.chooseSubjectManager.example" />, but for
               the purposes of explaining the ideas, this will suffice.</para>

               <example id="client.cpp.chooseSubjectManager.example">
                  <title>client.cpp: Implementation of
                  <methodname>chooseSubjectManager()</methodname></title>

                  <programlisting linenumbering="numbered">tweek::SubjectManager_var
chooseSubjectManager(tweek::CorbaService&amp; corbaService)
{
   tweek::SubjectManager_var subj_mgr;

   // Request all the active Subject Manager references.
   std::list&lt;tweek::SubjectManager_var&gt; mgrs =
      corbaService.getSubjectManagerList();                    <co
                        id="client.cpp.chooseSubjectManager.list"
                        linkends="client.cpp.chooseSubjectManager.list.co" />

   std::list&lt;tweek::SubjectManager_var&gt;::iterator cur_mgr;

   // Iterate over all the tweek::SubjectManager references we
   // have.
   for ( cur_mgr = mgrs.begin();                               <co
                        id="client.cpp.chooseSubjectManager.loop"
                        linkends="client.cpp.chooseSubjectManager.loop.co" />
         cur_mgr != mgrs.end();
         ++cur_mgr )
   {
      try
      {
         // It is not entirely safe to assume that *cur_mgr is
         // still valid at this point, even though it was valid
         // when the mgrs list was constructed.  Hence, we test
         // it again now.
         if ( ! (*cur_mgr)-&gt;_non_existent() )                  <co
                        id="client.cpp.chooseSubjectManager.verify"
                        linkends="client.cpp.chooseSubjectManager.verify.co" />
         {
            std::string response;
            const std::string proceed("y");

            tweek::SubjectManager::SubjectManagerInfoList_var
               mgr_info = (*cur_mgr)-&gt;getInfo();               <co
                        id="client.cpp.chooseSubjectManager.getInfo"
                        linkends="client.cpp.chooseSubjectManager.info.co" />

            std::cout &lt;&lt; "\nSubject Manager information:"
                      &lt;&lt; std::endl;

            // Loop over the information items and print each
            // key/value pair to the screen.
            for ( CORBA::ULong i = 0;                          <co
                        id="client.cpp.chooseSubjectManager.info-loop"
                        linkends="client.cpp.chooseSubjectManager.info.co" />
                  i &lt; mgr_info-&gt;length();
                  ++i )
            {
               std::cout &lt;&lt; "\t" &lt;&lt; mgr_info[i].key  &lt;&lt; " = "
                         &lt;&lt; mgr_info[i].value &lt;&lt; std::endl;
            }

            std::cout &lt;&lt; "Use this Subject Manager (y/n)? ";
            std::cin &gt;&gt; response;

            if ( proceed == response )
            {
               subj_mgr = *cur_mgr;                            <co
                        id="client.cpp.chooseSubjectManager.done"
                        linkends="client.cpp.chooseSubjectManager.done.co" />
               break;
            }
         }
      }
      catch (...)
      {
         vprDEBUG(vprDBG_ALL, vprDBG_CRITICAL_LVL)
            &lt;&lt; "Caught an unknown exception in "
            &lt;&lt; "chooseSubjectManager loop\n"
            &lt;&lt; vprDEBUG_FLUSH;
      }
   }

   return subj_mgr;
}</programlisting>

                  <calloutlist>
                     <callout arearefs="client.cpp.chooseSubjectManager.list"
                              id="client.cpp.chooseSubjectManager.list.co">
                        <para>Using the given
                        <classname>tweek::CorbaService</classname> reference,
                        we ask for the current list of valid
                        <interfacename>tweek::SubjectManager</interfacename>
                        references. The references in this list are guaranteed
                        to be valid at the time the list was
                        constructed.</para>
                     </callout>

                     <callout arearefs="client.cpp.chooseSubjectManager.loop"
                              id="client.cpp.chooseSubjectManager.loop.co">
                        <para>We use an STL iterator to loop over the list of
                        returned
                        <interfacename>tweek::SubjectManager</interfacename>
                        references. This loop presents each reference in
                        sequence and asks the user if the current reference is
                        the one s/he wants. The loop completes when the user
                        selects a reference or when no more references are
                        available.</para>
                     </callout>

                     <callout arearefs="client.cpp.chooseSubjectManager.verify"
                              id="client.cpp.chooseSubjectManager.verify.co">
                        <para>While the list of Subject Manager references was
                        guaranteed to have contained valid references when it
                        was constructed, things may have changed since then.
                        That is the nature of asynchronous programming. To be
                        safe, we test the current Subject Manager reference to
                        see if it still refers to an extant object. If so, we
                        continue. If not, we skip it. This invocation of
                        <methodname>tweek::SubjectManager::_non_existent()</methodname>
                        may throw an exception, and for that reason, we
                        enclose the body of the for loop in a try/catch
                        block.</para>
                     </callout>

                     <callout arearefs="client.cpp.chooseSubjectManager.getInfo client.cpp.chooseSubjectManager.info-loop"
                              id="client.cpp.chooseSubjectManager.info.co">
                        <para>It is possible for a single Naming Service to
                        have multiple active Subject Manager references. Each
                        of these has a unique identifier within the Naming
                        Service, but the identifier is not human readable. To
                        work around this, we make use of the method
                        <methodname>tweek::SubjectManager::getInfo()</methodname>.
                        This method returns a sequence of key/value pairs
                        (both are strings) that can be used to identify which
                        Subject Manager reference is the correct one. Here, we
                        request this information sequence and print all the
                        key/value pairs. With this output, the user can
                        (hopefully) determine which Subject Manager reference
                        to use.</para>

                        <note>
                           <para>This example is purposefully simple to keep
                           the code small. Readers are strongly encouraged to
                           come up with much more sophisticated choosing
                           mechanisms here. For example, the flexibility of the
                           Subject Manager information sequence would allow
                           choices to be made entirely in code without any
                           interactive user feedback.</para>
                        </note>
                     </callout>

                     <callout arearefs="client.cpp.chooseSubjectManager.done"
                              id="client.cpp.chooseSubjectManager.done.co">
                        <para>Here, the user has selected the current Subject
                        Manager as the correct one. We copy the reference to
                        the <varname>subj_mgr</varname> variable. Then, we
                        break out of the loop and return
                        <varname>subj_mgr</varname> to the caller.</para>
                     </callout>
                  </calloutlist>
               </example>

               <para>With that, we are done with our review of the C++ client
               API in Tweek. The use of CORBA allows Java and C++ client code
               to be quite similar, and this can be helpful when migrating
               between the two. The addition of the C++ client API in Tweek
               0.13 also demonstrates one of the basic design philosophies of
               Tweek: clients can be written in any language without concern
               for the language the server uses.</para>
            </section>
         </section>
      </chapter>

      <chapter>
         <title>Python</title>

         <indexterm>
            <primary>Python client API</primary>
         </indexterm>

         <para>The use of Python with Tweek is still being refined. While
         programmer's can make use of Python with Tweek right now, Tweek
         includes very little built-in support to ease the use of Python. Such
         features are planned for Tweek 1.2.</para>
      </chapter>
   </part>

   <part>
      <title>Appendices</title>

      <appendix id="makefile.appendix">
         <title>Compiling Example Code</title>

         <para>This appendix provides makefiles that can be used as starting
         points for compiling the example code shown earlier. These can also
         be used as the basis for future projects using Tweek.</para>

         <important>
            <para>When compiling on Windows, special care must be taken to
            manage DLL symbol importing correctly. The following preprocessor
            symbols <emphasis>must</emphasis> be defined when compiling
            <emphasis>all</emphasis> user code:</para>

            <itemizedlist>
               <listitem>
                  <para><symbol>USE_core_stub_in_nt_dll</symbol></para>
               </listitem>

               <listitem>
                  <para><symbol>USE_core_stub_in_nt_dll_NOT_DEFINED_Subject</symbol></para>
               </listitem>
            </itemizedlist>

            <para>It is especially important to define these two symbols when
            compiling C++ code generated by the omniORB IDL compiler
            (<command>omniidl</command>). Failure to define these symbols will
            result in run-time errors involving the registration of subjects
            with the Tweek Subject Manager. Other problems may arise as
            well.</para>

            <para>The best way to define these symbols is to use the
            <option>/D</option> option to <command>CL.EXE</command> so that
            every C++ file compiled has the symbols defined. This can be done
            easily using a Visual C++ project file or in a makefile. Example
            Visual C++ project files can be found with the Tweek test
            applications under the directory tree
            <filename>%TWEEK_BASE_DIR%\share\tweek\test</filename>.</para>
         </important>

         <section id="SliderSubject.makefile.section">
            <title>SliderSubject</title>

            <para>The following is a makefile that shows how to compile the
            code related to the <interfacename>SliderSubject</interfacename>
            example presented in <xref linkend="collab.slider.section" />. It
            runs the IDL compiler, the C++ compiler, and the Java compiler. It
            assumes the use of <command>omniidl</command>, the JacORB
            compiler, and GCC in a Linux environment.</para>

            <programlisting>APP_NAME=       server

all:
        $(MAKE) cxx_idl
        $(MAKE) java_idl
        $(MAKE) NO_DEPEND=0 cxx
        $(MAKE) $(APP_NAME)
        $(MAKE) java
        $(MAKE) NetworkTestBean.jar
        -$(MAKE) install

# Basic options.
srcdir=         .
NO_DEPEND=      YES

IDL_CXX_FILES=  SliderSubject.cpp SliderSubject.h               \
                WhiteboardSubject.cpp WhiteboardSubject.h
IDL_JAVA_FILES= SliderSubject.java              \
                WhiteboardSubject.java

base_srcs=      SliderSubjectImpl.cpp           \
                WhiteboardSubjectImpl.cpp       \
                main.cpp
idl_srcs=       \
   $(filter-out $(base_srcs), $(notdir $(wildcard $(CXX_GEN_DIR)/*.cpp)))

SRCS=           $(base_srcs) $(idl_srcs)
JAVA_SRCS=      networktest/NetworkTest.java                    \
                networktest/SliderObserverImpl.java             \
                networktest/SliderSubjectHolder.java            \
                networktest/WhiteboardObserverImpl.java         \
                networktest/WhiteboardSubjectHolder.java
ALL_CLASSES=    networktest/*.class

DZR_BASE_DIR=   $(shell flagpoll doozer --get-prefix)
include $(DZR_BASE_DIR)/ext/tweek/dzr.tweek.mk

CXX_GEN_DIR=            .
CXX_IDL=                $(TWEEK_IDL_CXX)
CXX_IDL_OPTS=           $(TWEEK_IDLFLAGS_CXX)                   \
                        $(TWEEK_IDL_GENDIR_CXX)$(CXX_GEN_DIR)
CXX_IDL_INCLUDES=
EXTRA_INCLUDES+=        -I$(CXX_GEN_DIR)

JAVA_GEN_DIR=           $(srcdir)
JAVA_IDL=               $(TWEEK_IDL_JAVA)
JAVA_IDL_OPTS=          $(TWEEK_IDLFLAGS_JAVA)                  \
                        $(TWEEK_IDL_GENDIR_JAVA) $(JAVA_GEN_DIR)
JAVA_IDL_INCLUDES=

vpath %.idl $(srcdir)
vpath %.cpp $(CXX_GEN_DIR)
vpath %.h $(CXX_GEN_DIR)
vpath %.java $(JAVA_GEN_DIR)

# --------------------------------------------------------------
# Application build targets.
# --------------------------------------------------------------
cxx_idl: $(IDL_CXX_FILES)

%.cpp %.h: %.idl
        $(CXX_IDL) $(CXX_IDL_OPTS) $(CXX_IDL_INCLUDES) $&lt;

java_idl: $(IDL_JAVA_FILES)

%.java: %.idl
        $(JAVA_IDL) $(JAVA_IDL_OPTS) $(JAVA_IDL_INCLUDES) $&lt;

cxx: $(OBJS)

java: $(CLASSES)

server: $(OBJS)
        $(LINK) $(LINK_OUT)$@ $(OBJS) $(TWEEK_LIBS)             \
          $(EXTRA_LIBS) $(LIBS)

NetworkTestBean.jar: $(JAVA_CLASSES)
        $(JAR) cvf $@ $(ALL_CLASSES)

install:
        cp NetworkTestBean.jar $(TWEEK_BASE_DIR)/share/tweek/beans
        cp $(srcdir)/NetworkTestBean.xml                        \
          $(TWEEK_BASE_DIR)/share/tweek/beans

CLEAN_FILES+=   \
   $(addprefix $(srcdir)/, $(IDL_CXX_FILES))                    \
   $(addprefix $(srcdir)/networktest/, $(IDL_JAVA_FILES))       \
   $(CLASSES) tweek/*.class
CLEAN_DIRS+=    $(srcdir)/tweek
CLOBBER_FILES+= NetworkTestBean.jar</programlisting>
         </section>

         <section id="FileLoader.makefile.section">
            <title>File Loader</title>

            <para>The following is a makefile that shows how to compile the
            code related to the file loader Bean example presented in <xref
            linkend="file.loader.section" />. All it must do is compile the
            Java code for the Bean.</para>

            <programlisting>all:
        $(MAKE) java
        $(MAKE) FileOpenTestBean.jar
        -$(MAKE) install

# Basic options.
srcdir=         .
NO_DEPEND=      YES

JAVA_SRCS=      fileopentestbean/FileOpenTestBean.java
ALL_CLASSES=    fileopentestbean/*.class

DZR_BASE_DIR=   $(shell flagpoll doozer --get-prefix)
include $(DZR_BASE_DIR)/ext/tweek/dzr.tweek.mk

# --------------------------------------------------------------
# Application build targets.
# --------------------------------------------------------------
java: $(CLASSES)

FileOpenTestBean.jar: $(JAVA_CLASSES)
        $(JAR) cvf $@ $(ALL_CLASSES)

install:
        cp FileOpenTestBean.jar $(TWEEK_BASE_DIR)/share/tweek/beans
        cp $(srcdir)/FileOpenTestBean.xml                       \
           $(TWEEK_BASE_DIR)/share/tweek/beans

CLOBBER_FILES+= FileOpenTestBean.jar</programlisting>
         </section>
      </appendix>

      <appendix id="orb-impl.appendix">
         <title>CORBA Implementations</title>

         <para>In order to use CORBA, a CORBA implementation must be
         available. As of this writing, Tweek uses omniORB 3.0.4 and newer
         <xref linkend="Omn02" /> for a C++ ORB. Since Tweek uses the POA, any
         C++ ORB may be used with only a few changes to the code.</para>

         <para>For the Java side, OpenORB 1.2.0 <xref linkend="Ope02" /> and
         newer <xref linkend="Ope03" /> have been used. Java IDL <xref
         linkend="Jid02" />, the CORBA implementation that comes with the Java
         Development Kit (JDK), does not fully implement the POA as of JDK
         1.3.1. With the release of JDK 1.4.0, Java IDL has a complete,
         working POA implementation and can be used without taking any special
         steps.</para>

         <para>To use an alternate ORB with Java, two arguments must be passed
         to the Java virtual machine. They are based on the ORB
         implementation. For example, if using OpenORB, the following two
         arguments must be specified:</para>

         <orderedlist>
            <listitem>
               <para><option>-Dorg.omg.CORBA.ORBClass=org.openorb.CORBA.ORB</option></para>
            </listitem>

            <listitem>
               <para><option>-Dorg.omg.CORBA.ORBSingletonClass=org.openorb.CORBA.ORB</option>Singleton</para>
            </listitem>
         </orderedlist>

         <para>Other ORBs will vary in the location of the
         <classname>ORBClass</classname> and the
         <classname>ORBSingletonClass</classname>. Refer to the documentation
         of the specific ORB to find out more about using it instead of Java
         IDL.</para>

         <para>For Python, most testing thus far has been done with omniORBpy
         2.0 and newer. Using ominORBpy requires that omniORB be installed
         since omniORBpy is primarily just a Python wrapper wround the C++
         CORBA implementation. We are watching the development of Fnorb <xref
         linkend="Fno03" /> as an alternative to omniORBpy. Fnorb offers a
         pure-Python implementation of CORBA. In other words, it requires no
         natively compiled code to operate. Prior to December 2003, Fnorb
         lacked a POA implementation, so it was not a viable option, but work
         is still under way to provide a complete CORBA 2.3
         implementation.</para>
      </appendix>

      <appendix>
         <title>Legal</title>

         <para>A full binary distribution of Tweek comes with binary code from
         several other software projects not affiliated with the Juggler
         Project or Iowa State University. Tweek makes use of redistributable
         code from the following packages:</para>

         <itemizedlist>
            <listitem>
               <para>JacORB (<ulink
               url="http://www.jacorb.org/">http://www.jacorb.org/</ulink>)</para>
            </listitem>

            <listitem>
               <para>JDOM (<ulink
               url="http://www.jdom.org/">http://www.jdom.org/</ulink>)</para>
            </listitem>

            <listitem>
               <para>JGoodies look and feel (<ulink
               url="http://www.jgoodies.com/">http://www.jgoodies.com/</ulink>)</para>
            </listitem>

            <listitem>
               <para>Kunststoff look and feel (<ulink
               url="http://www.incors.org/">http://www.incors.org/</ulink>)</para>
            </listitem>

            <listitem>
               <para>Liquid look and feel (<ulink
               url="http://liquidlnf.sourceforge.net/">http://liquidlnf.sourceforge.net/</ulink>)</para>
            </listitem>

            <listitem>
               <para>Metouia look and feel (<ulink
               url="http://mlf.sourceforge.net/">http://mlf.sourceforge.net/</ulink>)</para>
            </listitem>

            <listitem>
               <para>OpenORB (<ulink
               url="http://openorb.sourceforge.net/">http://openorb.sourceforge.net/</ulink>)</para>
            </listitem>
         </itemizedlist>

         <para>The licenses for each of these software packages can be found
         in
         <filename>$TWEEK_BASE_DIR/share/tweek/data/licenses</filename>.</para>
      </appendix>

      <appendix id="appendix.gfdl">
         <title>GNU Free Documentation License</title>

         <subtitle>Version 1.2, November 2002</subtitle>

         <blockquote id="fsf-copyright">
            <title>FSF Copyright note</title>

            <para>Copyright (C) 2000,2001,2002 Free Software Foundation, Inc.
            59 Temple Place, Suite 330, Boston, MA 02111-1307 USA Everyone is
            permitted to copy and distribute verbatim copies of this license
            document, but changing it is not allowed.</para>
         </blockquote>

         <section id="gfdl-0">
            <title>PREAMBLE</title>

            <para>The purpose of this License is to make a manual, textbook,
            or other functional and useful document "free" in the sense of
            freedom: to assure everyone the effective freedom to copy and
            redistribute it, with or without modifying it, either commercially
            or noncommercially. Secondarily, this License preserves for the
            author and publisher a way to get credit for their work, while not
            being considered responsible for modifications made by
            others.</para>

            <para>This License is a kind of "copyleft", which means that
            derivative works of the document must themselves be free in the
            same sense. It complements the GNU General Public License, which
            is a copyleft license designed for free software.</para>

            <para>We have designed this License in order to use it for manuals
            for free software, because free software needs free documentation:
            a free program should come with manuals providing the same
            freedoms that the software does. But this License is not limited
            to software manuals; it can be used for any textual work,
            regardless of subject matter or whether it is published as a
            printed book. We recommend this License principally for works
            whose purpose is instruction or reference.</para>
         </section>

         <section id="gfdl-1">
            <title>APPLICABILITY AND DEFINITIONS</title>

            <para id="gfdl-doc">This License applies to any manual or other
            work, in any medium, that contains a notice placed by the
            copyright holder saying it can be distributed under the terms of
            this License. Such a notice grants a world-wide, royalty-free
            license, unlimited in duration, to use that work under the
            conditions stated herein. The "Document", below, refers to any
            such manual or work. Any member of the public is a licensee, and
            is addressed as "you". You accept the license if you copy, modify
            or distribute the work in a way requiring permission under
            copyright law.</para>

            <para id="gfdl-mod-ver">A "Modified Version" of the Document means
            any work containing the Document or a portion of it, either copied
            verbatim, or with modifications and/or translated into another
            language.</para>

            <para id="gfdl-secnd-sect">A "Secondary Section" is a named
            appendix or a front-matter section of the Document that deals
            exclusively with the relationship of the publishers or authors of
            the Document to the Document's overall subject (or to related
            matters) and contains nothing that could fall directly within that
            overall subject. (Thus, if the Document is in part a textbook of
            mathematics, a Secondary Section may not explain any mathematics.)
            The relationship could be a matter of historical connection with
            the subject or with related matters, or of legal, commercial,
            philosophical, ethical or political position regarding
            them.</para>

            <para id="gfdl-inv-sect">The "Invariant Sections" are certain
            Secondary Sections whose titles are designated, as being those of
            Invariant Sections, in the notice that says that the Document is
            released under this License. If a section does not fit the above
            definition of Secondary then it is not allowed to be designated as
            Invariant. The Document may contain zero Invariant Sections. If
            the Document does not identify any Invariant Sections then there
            are none.</para>

            <para id="gfdl-cov-text">The "Cover Texts" are certain short
            passages of text that are listed, as Front-Cover Texts or
            Back-Cover Texts, in the notice that says that the Document is
            released under this License. A Front-Cover Text may be at most 5
            words, and a Back-Cover Text may be at most 25 words.</para>

            <para id="gfdl-transparent">A "Transparent" copy of the Document
            means a machine-readable copy, represented in a format whose
            specification is available to the general public, that is suitable
            for revising the document straightforwardly with generic text
            editors or (for images composed of pixels) generic paint programs
            or (for drawings) some widely available drawing editor, and that
            is suitable for input to text formatters or for automatic
            translation to a variety of formats suitable for input to text
            formatters. A copy made in an otherwise Transparent file format
            whose markup, or absence of markup, has been arranged to thwart or
            discourage subsequent modification by readers is not Transparent.
            An image format is not Transparent if used for any substantial
            amount of text. A copy that is not "Transparent" is called
            "Opaque".</para>

            <para>Examples of suitable formats for Transparent copies include
            plain ASCII without markup, Texinfo input format, LaTeX input
            format, SGML or XML using a publicly available DTD, and
            standard-conforming simple HTML, PostScript or PDF designed for
            human modification. Examples of transparent image formats include
            PNG, XCF and JPG. Opaque formats include proprietary formats that
            can be read and edited only by proprietary word processors, SGML
            or XML for which the DTD and/or processing tools are not generally
            available, and the machine-generated HTML, PostScript or PDF
            produced by some word processors for output purposes only.</para>

            <para id="gfdl-title-page">The "Title Page" means, for a printed
            book, the title page itself, plus such following pages as are
            needed to hold, legibly, the material this License requires to
            appear in the title page. For works in formats which do not have
            any title page as such, "Title Page" means the text near the most
            prominent appearance of the work's title, preceding the beginning
            of the body of the text.</para>

            <para id="gfdl-entitled">A section "Entitled XYZ" means a named
            subunit of the Document whose title either is precisely XYZ or
            contains XYZ in parentheses following text that translates XYZ in
            another language. (Here XYZ stands for a specific section name
            mentioned below, such as "Acknowledgements", "Dedications",
            "Endorsements", or "History".) To "Preserve the Title" of such a
            section when you modify the Document means that it remains a
            section "Entitled XYZ" according to this definition.</para>

            <para>The Document may include Warranty Disclaimers next to the
            notice which states that this License applies to the Document.
            These Warranty Disclaimers are considered to be included by
            reference in this License, but only as regards disclaiming
            warranties: any other implication that these Warranty Disclaimers
            may have is void and has no effect on the meaning of this
            License.</para>
         </section>

         <section id="gfdl-2">
            <title>VERBATIM COPYING</title>

            <para>You may copy and distribute the Document in any medium,
            either commercially or noncommercially, provided that this
            License, the copyright notices, and the license notice saying this
            License applies to the Document are reproduced in all copies, and
            that you add no other conditions whatsoever to those of this
            License. You may not use technical measures to obstruct or control
            the reading or further copying of the copies you make or
            distribute. However, you may accept compensation in exchange for
            copies. If you distribute a large enough number of copies you must
            also follow the conditions in section 3.</para>

            <para>You may also lend copies, under the same conditions stated
            above, and you may publicly display copies.</para>
         </section>

         <section id="gfdl-3">
            <title>COPYING IN QUANTITY</title>

            <para>If you publish printed copies (or copies in media that
            commonly have printed covers) of the Document, numbering more than
            100, and the Document's license notice requires Cover Texts, you
            must enclose the copies in covers that carry, clearly and legibly,
            all these Cover Texts: Front-Cover Texts on the front cover, and
            Back-Cover Texts on the back cover. Both covers must also clearly
            and legibly identify you as the publisher of these copies. The
            front cover must present the full title with all words of the
            title equally prominent and visible. You may add other material on
            the covers in addition. Copying with changes limited to the
            covers, as long as they preserve the title of the Document and
            satisfy these conditions, can be treated as verbatim copying in
            other respects.</para>

            <para>If the required texts for either cover are too voluminous to
            fit legibly, you should put the first ones listed (as many as fit
            reasonably) on the actual cover, and continue the rest onto
            adjacent pages.</para>

            <para>If you publish or distribute Opaque copies of the Document
            numbering more than 100, you must either include a
            machine-readable Transparent copy along with each Opaque copy, or
            state in or with each Opaque copy a computer-network location from
            which the general network-using public has access to download
            using public-standard network protocols a complete Transparent
            copy of the Document, free of added material. If you use the
            latter option, you must take reasonably prudent steps, when you
            begin distribution of Opaque copies in quantity, to ensure that
            this Transparent copy will remain thus accessible at the stated
            location until at least one year after the last time you
            distribute an Opaque copy (directly or through your agents or
            retailers) of that edition to the public.</para>

            <para>It is requested, but not required, that you contact the
            authors of the Document well before redistributing any large
            number of copies, to give them a chance to provide you with an
            updated version of the Document.</para>
         </section>

         <section id="gfdl-4">
            <title>MODIFICATIONS</title>

            <para>You may copy and distribute a Modified Version of the
            Document under the conditions of sections 2 and 3 above, provided
            that you release the Modified Version under precisely this
            License, with the Modified Version filling the role of the
            Document, thus licensing distribution and modification of the
            Modified Version to whoever possesses a copy of it. In addition,
            you must do these things in the Modified Version:</para>

            <orderedlist id="gfdl-modif-cond" numeration="upperalpha">
               <title>GNU FDL Modification Conditions</title>

               <listitem>
                  <simpara>Use in the Title Page (and on the covers, if any) a
                  title distinct from that of the Document, and from those of
                  previous versions (which should, if there were any, be
                  listed in the History section of the Document). You may use
                  the same title as a previous version if the original
                  publisher of that version gives permission.</simpara>
               </listitem>

               <listitem>
                  <simpara>List on the Title Page, as authors, one or more
                  persons or entities responsible for authorship of the
                  modifications in the Modified Version, together with at
                  least five of the principal authors of the Document (all of
                  its principal authors, if it has fewer than five), unless
                  they release you from this requirement.</simpara>
               </listitem>

               <listitem>
                  <simpara>State on the Title page the name of the publisher
                  of the Modified Version, as the publisher.</simpara>
               </listitem>

               <listitem>
                  <simpara>Preserve all the copyright notices of the
                  Document.</simpara>
               </listitem>

               <listitem>
                  <simpara>Add an appropriate copyright notice for your
                  modifications adjacent to the other copyright
                  notices.</simpara>
               </listitem>

               <listitem>
                  <simpara>Include, immediately after the copyright notices, a
                  license notice giving the public permission to use the
                  Modified Version under the terms of this License, in the
                  form shown in the <link
                  linkend="gfdl-addendum">Addendum</link> below.</simpara>
               </listitem>

               <listitem>
                  <simpara>Preserve in that license notice the full lists of
                  Invariant Sections and required Cover Texts given in the
                  Document's license notice.</simpara>
               </listitem>

               <listitem>
                  <simpara>Include an unaltered copy of this
                  License.</simpara>
               </listitem>

               <listitem>
                  <simpara>Preserve the section Entitled "History", Preserve
                  its Title, and add to it an item stating at least the title,
                  year, new authors, and publisher of the Modified Version as
                  given on the Title Page. If there is no section Entitled
                  "History" in the Document, create one stating the title,
                  year, authors, and publisher of the Document as given on its
                  Title Page, then add an item describing the Modified Version
                  as stated in the previous sentence.</simpara>
               </listitem>

               <listitem>
                  <simpara>Preserve the network location, if any, given in the
                  Document for public access to a Transparent copy of the
                  Document, and likewise the network locations given in the
                  Document for previous versions it was based on. These may be
                  placed in the "History" section. You may omit a network
                  location for a work that was published at least four years
                  before the Document itself, or if the original publisher of
                  the version it refers to gives permission.</simpara>
               </listitem>

               <listitem>
                  <simpara>For any section Entitled "Acknowledgements" or
                  "Dedications", Preserve the Title of the section, and
                  preserve in the section all the substance and tone of each
                  of the contributor acknowledgements and/or dedications given
                  therein.</simpara>
               </listitem>

               <listitem>
                  <simpara>Preserve all the Invariant Sections of the
                  Document, unaltered in their text and in their titles.
                  Section numbers or the equivalent are not considered part of
                  the section titles.</simpara>
               </listitem>

               <listitem>
                  <simpara>Delete any section Entitled "Endorsements". Such a
                  section may not be included in the Modified
                  Version.</simpara>
               </listitem>

               <listitem>
                  <simpara>Do not retitle any existing section to be Entitled
                  "Endorsements" or to conflict in title with any Invariant
                  Section.</simpara>
               </listitem>

               <listitem>
                  <simpara>Preserve any Warranty Disclaimers.</simpara>
               </listitem>
            </orderedlist>

            <para>If the Modified Version includes new front-matter sections
            or appendices that qualify as Secondary Sections and contain no
            material copied from the Document, you may at your option
            designate some or all of these sections as invariant. To do this,
            add their titles to the list of Invariant Sections in the Modified
            Version's license notice. These titles must be distinct from any
            other section titles.</para>

            <para>You may add a section Entitled "Endorsements", provided it
            contains nothing but endorsements of your Modified Version by
            various parties--for example, statements of peer review or that
            the text has been approved by an organization as the authoritative
            definition of a standard.</para>

            <para>You may add a passage of up to five words as a Front-Cover
            Text, and a passage of up to 25 words as a Back-Cover Text, to the
            end of the list of Cover Texts in the Modified Version. Only one
            passage of Front-Cover Text and one of Back-Cover Text may be
            added by (or through arrangements made by) any one entity. If the
            Document already includes a cover text for the same cover,
            previously added by you or by arrangement made by the same entity
            you are acting on behalf of, you may not add another; but you may
            replace the old one, on explicit permission from the previous
            publisher that added the old one.</para>

            <para>The author(s) and publisher(s) of the Document do not by
            this License give permission to use their names for publicity for
            or to assert or imply endorsement of any Modified Version.</para>
         </section>

         <section id="gfdl-5">
            <title>COMBINING DOCUMENTS</title>

            <para>You may combine the Document with other documents released
            under this License, under the terms defined in <link
            linkend="gfdl-4">section 4</link> above for modified versions,
            provided that you include in the combination all of the Invariant
            Sections of all of the original documents, unmodified, and list
            them all as Invariant Sections of your combined work in its
            license notice, and that you preserve all their Warranty
            Disclaimers.</para>

            <para>The combined work need only contain one copy of this
            License, and multiple identical Invariant Sections may be replaced
            with a single copy. If there are multiple Invariant Sections with
            the same name but different contents, make the title of each such
            section unique by adding at the end of it, in parentheses, the
            name of the original author or publisher of that section if known,
            or else a unique number. Make the same adjustment to the section
            titles in the list of Invariant Sections in the license notice of
            the combined work.</para>

            <para>In the combination, you must combine any sections Entitled
            "History" in the various original documents, forming one section
            Entitled "History"; likewise combine any sections Entitled
            "Acknowledgements", and any sections Entitled "Dedications". You
            must delete all sections Entitled "Endorsements".</para>
         </section>

         <section id="gfdl-6">
            <title>COLLECTIONS OF DOCUMENTS</title>

            <para>You may make a collection consisting of the Document and
            other documents released under this License, and replace the
            individual copies of this License in the various documents with a
            single copy that is included in the collection, provided that you
            follow the rules of this License for verbatim copying of each of
            the documents in all other respects.</para>

            <para>You may extract a single document from such a collection,
            and distribute it individually under this License, provided you
            insert a copy of this License into the extracted document, and
            follow this License in all other respects regarding verbatim
            copying of that document.</para>
         </section>

         <section id="gfdl-7">
            <title>AGGREGATION WITH INDEPENDENT WORKS</title>

            <para>A compilation of the Document or its derivatives with other
            separate and independent documents or works, in or on a volume of
            a storage or distribution medium, is called an "aggregate" if the
            copyright resulting from the compilation is not used to limit the
            legal rights of the compilation's users beyond what the individual
            works permit. When the Document is included in an aggregate, this
            License does not apply to the other works in the aggregate which
            are not themselves derivative works of the Document.</para>

            <para>If the Cover Text requirement of section 3 is applicable to
            these copies of the Document, then if the Document is less than
            one half of the entire aggregate, the Document's Cover Texts may
            be placed on covers that bracket the Document within the
            aggregate, or the electronic equivalent of covers if the Document
            is in electronic form. Otherwise they must appear on printed
            covers that bracket the whole aggregate.</para>
         </section>

         <section id="gfdl-8">
            <title>TRANSLATION</title>

            <para>Translation is considered a kind of modification, so you may
            distribute translations of the Document under the terms of section
            4. Replacing Invariant Sections with translations requires special
            permission from their copyright holders, but you may include
            translations of some or all Invariant Sections in addition to the
            original versions of these Invariant Sections. You may include a
            translation of this License, and all the license notices in the
            Document, and any Warranty Disclaimers, provided that you also
            include the original English version of this License and the
            original versions of those notices and disclaimers. In case of a
            disagreement between the translation and the original version of
            this License or a notice or disclaimer, the original version will
            prevail.</para>

            <para>If a section in the Document is Entitled "Acknowledgements",
            "Dedications", or "History", the requirement (section 4) to
            Preserve its Title (section 1) will typically require changing the
            actual title.</para>
         </section>

         <section id="gfdl-9">
            <title>TERMINATION</title>

            <para>You may not copy, modify, sublicense, or distribute the
            Document except as expressly provided for under this License. Any
            other attempt to copy, modify, sublicense or distribute the
            Document is void, and will automatically terminate your rights
            under this License. However, parties who have received copies, or
            rights, from you under this License will not have their licenses
            terminated so long as such parties remain in full
            compliance.</para>
         </section>

         <section id="gfdl-10">
            <title>FUTURE REVISIONS OF THIS LICENSE</title>

            <para>The Free Software Foundation may publish new, revised
            versions of the GNU Free Documentation License from time to time.
            Such new versions will be similar in spirit to the present
            version, but may differ in detail to address new problems or
            concerns. See http://www.gnu.org/copyleft/.</para>

            <para>Each version of the License is given a distinguishing
            version number. If the Document specifies that a particular
            numbered version of this License "or any later version" applies to
            it, you have the option of following the terms and conditions
            either of that specified version or of any later version that has
            been published (not as a draft) by the Free Software Foundation.
            If the Document does not specify a version number of this License,
            you may choose any version ever published (not as a draft) by the
            Free Software Foundation.</para>
         </section>

         <section id="gfdl-addendum">
            <title>ADDENDUM: How to use this License for your
            documents</title>

            <para>To use this License in a document you have written, include
            a copy of the License in the document and put the following
            copyright and license notices just after the title page:</para>

            <blockquote id="copyright-sample">
               <title>Sample Invariant Sections list</title>

               <para>Copyright (c) YEAR YOUR NAME. Permission is granted to
               copy, distribute and/or modify this document under the terms of
               the GNU Free Documentation License, Version 1.2 or any later
               version published by the Free Software Foundation; with no
               Invariant Sections, no Front-Cover Texts, and no Back-Cover
               Texts. A copy of the license is included in the section
               entitled "GNU Free Documentation License".</para>
            </blockquote>

            <para>If you have Invariant Sections, Front-Cover Texts and
            Back-Cover Texts, replace the "with...Texts." line with
            this:</para>

            <blockquote id="inv-cover-sample">
               <title>Sample Invariant Sections list</title>

               <para>with the Invariant Sections being LIST THEIR TITLES, with
               the Front-Cover Texts being LIST, and with the Back-Cover Texts
               being LIST.</para>
            </blockquote>

            <para>If you have Invariant Sections without Cover Texts, or some
            other combination of the three, merge those two alternatives to
            suit the situation.</para>

            <para>If your document contains nontrivial examples of program
            code, we recommend releasing these examples in parallel under your
            choice of free software license, such as the GNU General Public
            License, to permit their use in free software.</para>
         </section>
      </appendix>
   </part>

   <bibliography>
      <biblioentry id="Fno03">
         <biblioset relation="website">
            <address><otheraddr><ulink url="http://www.fnorb.org/">Fnorb website</ulink></otheraddr></address>
         </biblioset>
      </biblioentry>

      <biblioentry id="Gam95">
         <biblioset relation="book">
            <authorgroup>
               <author>
                  <firstname>Erich</firstname>

                  <surname>Gamma</surname>
               </author>

               <author>
                  <firstname>Richard</firstname>

                  <surname>Helm</surname>
               </author>

               <author>
                  <firstname>Ralph</firstname>

                  <surname>Johnson</surname>
               </author>

               <author>
                  <firstname>John</firstname>

                  <surname>Vlissides</surname>
               </author>
            </authorgroup>

            <title>Design Patterns</title>

            <copyright>
               <year>1995</year>

               <holder>Addison Wesley Longman, Inc.</holder>
            </copyright>

            <isbn>0-201-63361-2</isbn>

            <publisher>
               <publishername>Addison-Wesley</publishername>
            </publisher>
         </biblioset>
      </biblioentry>

      <biblioentry id="Hen99">
         <biblioset relation="book">
            <authorgroup>
               <author>
                  <firstname>Michi</firstname>

                  <surname>Henning</surname>
               </author>

               <author>
                  <firstname>Steve</firstname>

                  <surname>Vinoski</surname>
               </author>
            </authorgroup>

            <title>Advanced CORBA Programming with C++</title>

            <copyright>
               <year>1999</year>

               <holder>Addison Wesley Longman, Inc.</holder>
            </copyright>

            <isbn>0-201-37927-9</isbn>

            <publisher>
               <publishername>Addison Wesley Longman, Inc.</publishername>
            </publisher>
         </biblioset>
      </biblioentry>

      <biblioentry id="Jbe02">
         <biblioset relation="website">
            <address><otheraddr><ulink
                     url="http://java.sun.com/products/javabeans/">JavaBeans website</ulink></otheraddr></address>
         </biblioset>
      </biblioentry>

      <biblioentry id="Jid02">
         <biblioset relation="website">
            <address><otheraddr><ulink
                     url="http://java.sun.com/products/jdk/idl/">Java IDL website</ulink></otheraddr></address>
         </biblioset>
      </biblioentry>

      <biblioentry id="Omn02">
         <biblioset relation="website">
            <address><otheraddr><ulink
                     url="http://www.uk.research.att.com/omniORB/">omniORB website</ulink></otheraddr></address>
         </biblioset>
      </biblioentry>

      <biblioentry id="Ope02">
         <biblioset relation="website">
            <address><otheraddr><ulink url="http://www.openorb.com/">OpenORB website</ulink></otheraddr></address>
         </biblioset>
      </biblioentry>

      <biblioentry id="Ope03">
         <biblioset relation="website">
            <address><otheraddr><ulink url="http://openorb.sourceforge.net/">OpenORB community website</ulink></otheraddr></address>
         </biblioset>
      </biblioentry>

      <biblioentry id="Pyq03">
         <biblioset relation="website">
            <address><otheraddr><ulink
                     url="http://www.riverbankcomputing.co.uk/pyqt/index.php">PyQt website</ulink></otheraddr></address>
         </biblioset>
      </biblioentry>
   </bibliography>

   <glossary>
      <title>Glossary</title>

      <glossdiv>
         <title>A</title>

         <glossentry id="gloss.api">
            <glossterm>application programmer interface</glossterm>

            <acronym>API</acronym>

            <glossdef>
               <para>An application programmer interface is the documented,
               programatic interface used by programmers to access a software
               library.</para>
            </glossdef>
         </glossentry>
      </glossdiv>

      <glossdiv>
         <title>C</title>

         <glossentry id="gloss.corba">
            <glossterm>Common Object Request Broker Architecture</glossterm>

            <acronym>CORBA</acronym>

            <glossdef>
               <para>The Common Object Request Broker Architecture (CORBA) is
               a standard specified by the Object Management Group for
               distributed object-oriented programming. It is both platform-
               and language-independent. Implementations of CORBA are
               available from many vendors for a wide variety of programming
               languages.</para>
            </glossdef>
         </glossentry>
      </glossdiv>

      <glossdiv>
         <title>D</title>

         <glossentry id="gloss.distrib-programming">
            <glossterm>distributed programming</glossterm>

            <glossdef>
               <para>Distributed programming is a paradigm in which software
               components are installed on physically separated computers and
               accessed remotely though a network. Examples of distributed
               programming include Sun's Remote Procedure Calls (RPC), Java's
               Remote Method Invocation (RMI), Microsoft's Component Object
               Model (COM), and the Common Object Request Broker Architecture
               (CORBA). RPC is based on the procedural programming paradigm
               used by languages such as C and Pascal. With RPC, procedures
               residing in memory on remote machines are accessed. The other
               examples listed are based on the object-oriented programming
               paradigm used by languages such as C++, Java, Smalltalk, and
               Python. In this case, software objects and their methods are
               accessed remotely.</para>
            </glossdef>
         </glossentry>
      </glossdiv>

      <glossdiv>
         <title>E</title>

         <glossentry id="gloss.xml.main">
            <glossterm>Extensible Markup Language</glossterm>

            <acronym>XML</acronym>

            <glossdef>
               <para>The eXtensible Markup Language (XML) is a specification
               from the World Wide Web Consortium. XML itself is a language
               for specifying well-defined, structured document markup.</para>
            </glossdef>
         </glossentry>
      </glossdiv>

      <glossdiv>
         <title>G</title>

         <glossentry id="gloss.gui">
            <glossterm>graphical user interface</glossterm>

            <acronym>GUI</acronym>

            <glossdef>
               <para>Graphical user interfaces are used in modern operating
               systems that support the concept of <quote>windows</quote>. The
               windows provide a visual representation of an application and
               usually have a border and a title to distinguish one window
               from another. Within the window, there are graphical elements
               known as <quote>widgets</quote> that make up the full
               interface. Widgets include pull-down menus, clickable buttons,
               and scroll bars.</para>
            </glossdef>
         </glossentry>
      </glossdiv>

      <glossdiv>
         <title>I</title>

         <glossentry id="gloss.idl-compiler">
            <glossterm>IDL compiler</glossterm>

            <glossdef>
               <para>A software tool that reads an IDL file and generates code
               in a specific language (e.g., Java, C++, Smalltalk, etc.). This
               code may be anything, but typically, it is stub or skeleton
               code that is extended by user-defined code that completes the
               interface implementation.</para>
            </glossdef>
         </glossentry>

         <glossentry id="gloss.interface">
            <glossterm>interface</glossterm>

            <glossdef>
               <para>Several types of <quote>interfaces</quote> exist within
               the scope of Tweek:</para>

               <itemizedlist>
                  <listitem>
                     <para>In Java. there is a keyword
                     <literal>interface</literal> that can be used to define a
                     set of methods that must be part of an implementing
                     class. Classes that claim to implement a given interface
                     must define the methods described by the interface or
                     declare themselves abstract.</para>
                  </listitem>

                  <listitem>
                     <para>In <glossterm linkend="gloss.idl">IDL</glossterm>,
                     an interface is essentially identical to a Java
                     interface, but an IDL compiler can generate code from the
                     IDL. The interface methods must still be implemented (by
                     a C++ class, for example), and thus, the main function of
                     an IDL interface is to define a language-independent
                     signature through which CORBA communication may
                     occur.</para>
                  </listitem>

                  <listitem>
                     <para>In C++, there is no <literal>interface</literal>
                     keyword as in Java and IDL. The term
                     <quote>interface</quote> is typically applied to abstract
                     classes (those with pure virtual methods). More
                     generally, it is use to refer to the collection of
                     methods defined by a class.</para>
                  </listitem>
               </itemizedlist>
            </glossdef>
         </glossentry>

         <glossentry id="gloss.idl">
            <glossterm>Interface Definition Language</glossterm>

            <acronym>IDL</acronym>

            <glossdef>
               <para>The Interface Definition Language is a simple language
               used to define the interface (or signature) an object will
               have. An interface is composed solely of methods (functions)
               that may be invoked on an object (data element). No data
               members are present in the interface definition. IDL is not
               tied to a specific language but instead must be compiled into
               another language where the interface will be
               implemented.</para>
            </glossdef>
         </glossentry>

         <glossentry id="gloss.iiop">
            <glossterm>Internet Inter-ORB Protocol</glossterm>

            <acronym>IIOP</acronym>

            <glossdef>
               <para>The Internet Inter-ORB Protocol (IIOP) is part of the
               CORBA specification. It is used to standardize communication
               between ORBs so that ORBs from different vendors can
               inter-operate seamlessly.</para>
            </glossdef>
         </glossentry>
      </glossdiv>

      <glossdiv>
         <title>J</title>

         <glossentry id="gloss.javabean">
            <glossterm>JavaBean</glossterm>

            <glossdef>
               <para>JavaBeans are the component architecture of the Java
               programming language. There are no restrictions on the
               interfaces implemented by JavaBeans, though it is strongly
               recommended that they implement
               <interfacename>java.io.Serializable</interfacename>.</para>
            </glossdef>
         </glossentry>

         <glossentry id="gloss.jni">
            <glossterm>Java Native Interface</glossterm>

            <acronym>JNI</acronym>

            <glossdef>
               <para>The Java Native Interface is the bridge between a Java
               virtual machine (JVM) and natively compiled code. Native code
               can load a JVM and get access to Java objects through it, or
               Java classes may have native methods that are loaded by the
               JVM.</para>
            </glossdef>
         </glossentry>
      </glossdiv>

      <glossdiv>
         <title>O</title>

         <glossentry id="gloss.orb">
            <glossterm>Object Request Broker</glossterm>

            <acronym>ORB</acronym>

            <glossdef>
               <para>An Object Request Broker (ORB) is used by CORBA for
               management of interface implementation objects (servants) and
               the references made to those objects. ORBs communicate with
               each other using a client/server model, though two ORBs may
               both act as servers and clients during the transactions.</para>
            </glossdef>
         </glossentry>
      </glossdiv>

      <glossdiv>
         <title>P</title>

         <glossentry id="gloss.poa">
            <glossterm>Portable Object Adapter</glossterm>

            <acronym>POA</acronym>

            <glossdef>
               <para>The Portable Object Adapter (POA) the standard object
               adapter and is part of the CORBA 2.3 specification. It is used
               together with IIOP to allow ORB implementations from different
               vendors to communicate. A single ORB may have multiple POAs
               each tailored to a certain task using parameterized
               characteristics.</para>
            </glossdef>
         </glossentry>
      </glossdiv>

      <glossdiv>
         <title>R</title>

         <glossentry id="gloss.rmi">
            <glossterm>Remote Method Invocation</glossterm>

            <acronym>RMI</acronym>

            <glossdef>
               <para>Remote Method Invocation (RMI) is a mechanism for gaining
               access to remote Java code. It is implemented as part of the
               Java virtual machine and was originally intended to be
               comparable to CORBA. RMI allows easy access to code between two
               virtual machines, but it does not have the cross-language
               features of CORBA.</para>
            </glossdef>
         </glossentry>
      </glossdiv>

      <glossdiv>
         <title>S</title>

         <glossentry id="gloss.servant">
            <glossterm>servant</glossterm>

            <glossdef>
               <para>In CORBA, a servant is an instance of an interface
               implementation that is registered with an ORB. A servant
               receives method invocations through the CORBA object
               adapter.</para>
            </glossdef>
         </glossentry>
      </glossdiv>

      <glossdiv>
         <title>X</title>

         <glossentry id="gloss.xml">
            <glossterm>XML</glossterm>

            <glossdef>
               <para>See <glossterm linkend="gloss.xml.main">Extensible Markup
               Language</glossterm>.</para>
            </glossdef>
         </glossentry>
      </glossdiv>
   </glossary>

   <index></index>
</book>

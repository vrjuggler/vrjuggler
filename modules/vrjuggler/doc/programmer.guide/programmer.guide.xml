<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<book>
  <bookinfo>
    <title>VR Juggler</title>

    <subtitle>The Programmer&#39;s Guide</subtitle>

    <releaseinfo>Version 2.0 Alpha 2</releaseinfo>

    <pubdate>$Date$</pubdate>
  </bookinfo>

  <part id="part.intro">
    <title>Introduction</title>

    <chapter id="chapter.getting.started">
      <title>Getting Started</title>

      <para>In this book, we present a <quote>how-to</quote> for writing VR
      Juggler applications. We will explain concepts used in VR Juggler and
      present carefully annotated example code whenever appropriate. There are
      two groups of people who should read this book:</para>

      <orderedlist>
        <listitem>
          <para>Those who are required to read it in order to do a project for
          work or school. To those in this category, fear not—VR Juggler is
          very simple to use after getting through the initial learning
          stages. It is a powerful tool that will allow the creation of
          interesting and powerful applications very quickly.</para>
        </listitem>

        <listitem>
          <para>Those who are just interested in creating compelling,
          interesting VR applications. VR Juggler facilitates the construction
          of extremely powerful applications that will run on nearly any
          combination of hardware architecture and software platform.</para>
        </listitem>
      </orderedlist>

      <section>
        <title>Necessary Experience</title>

        <para>To help readers get the most from this book, recommendations
        follow to provide an idea of what previous experience is necessary.
        Various programming skills are needed, of course, but programming for
        VR requires more than just knowledge of a given programming language.
        VR Juggler takes advantage of many programming design patterns and
        advanced concepts to make it more powerful, more flexible, and more
        extensible. A good background in mathematics is helpful for performing
        the myriad transformations that must be applied to three-dimensional
        (3D) geometry.</para>

        <section>
          <title>Required Background</title>

          <para>To get the most from this chapter, there are a few
          prerequisites:</para>

          <itemizedlist>
            <listitem>
              <para>C++ programming experience</para>
            </listitem>

            <listitem>
              <para>Some graphics programming background (e.g., OpenGL, OpenGL
              Performer, etc.)</para>
            </listitem>

            <listitem>
              <para>Reasonable mathematical background (linear algebra
              knowledge is very useful)</para>
            </listitem>
          </itemizedlist>

          <para>For some of the advanced sections of this book, it is
          recommended that readers review the VR Juggler architecture book.
          This is optional, though it may be helpful in gaining a quicker
          understanding of some topics and concepts.</para>
        </section>

        <section>
          <title>Other VR Software Tools</title>

          <para>Readers who already have experience with other VR software
          development environments can easily skim through this book and find
          the relevant new information. The book is designed for easy
          skimming. Simply look at the headings to get a good determination of
          what should be read and what may be skipped.</para>
        </section>

        <section>
          <title>Organization</title>

          <para>This book is organized into three main parts:</para>

          <orderedlist>
            <listitem>
              <para>Introduction: The introduction to the key VR Juggler
              application development concept, application objects. We also
              describe common helper classes that simplify the process of
              writing applications.</para>
            </listitem>

            <listitem>
              <para>Writing applications: The presentation of application
              development including how to get input from devices and how to
              write applications for each of the supported graphics
              application programmer interfaces (APIs).</para>
            </listitem>

            <listitem>
              <para>Advanced topics: An extension of the previous chapters
              showing how to incorporate run-time reconfiguration into
              applications and how to write multi-threaded applications.</para>
            </listitem>
          </orderedlist>
        </section>
      </section>
    </chapter>

    <chapter id="chapter.app.basics">
      <title>Application Basics</title>

      <indexterm zone="chapter.app.basics">
        <primary>applications</primary>

        <secondary>basics</secondary>
      </indexterm>

      <para>In VR Juggler, all applications are written as objects that are
      handled by the kernel. The objects are known as <glossterm
      linkend="gloss.app.object">application objects</glossterm><indexterm><primary>application
      object</primary></indexterm>, and we will use that term frequently
      throughout this text. Application objects are introduced and explained
      in this chapter.</para>

      <section id="section.app.object.overview">
        <title>Application Object Overview</title>

        <indexterm zone="section.app.object.overview">
          <primary>applications</primary>

          <secondary>application object overview</secondary>
        </indexterm>

        <indexterm zone="section.app.object.overview">
          <primary>application object</primary>

          <secondary>overview</secondary>
        </indexterm>

        <para>VR Juggler uses the application object<indexterm><primary>application
        object</primary></indexterm> to create the VR environment with which
        the users interact. The application object implements <glossterm
        linkend="gloss.interface">interfaces</glossterm> needed by the VR
        Juggler <glossterm linkend="gloss.virtual.platform">virtual platform</glossterm><indexterm><primary>virtual
        platform</primary></indexterm>.</para>

        <section id="section.main.func">
          <title>No <function>main()</function>—<quote>Don&#39;t call me,
          I&#39;ll call you</quote></title>

          <indexterm zone="section.main.func">
            <primary>main function</primary>
          </indexterm>

          <para>Since VR Juggler applications are objects, developers do not
          write the traditional <function>main()</function> function. Instead,
          developers create an application object that implements a set of
          pre-defined interfaces. The VR Juggler kernel controls the
          application&#39;s processing time by calling the object&#39;s
          interface implementation methods.</para>

          <para>In traditional programs, the <function>main()</function>
          function defines the point where the <glossterm
          linkend="gloss.thread.of.control">thread of control</glossterm>
          enters the application. After the <function>main()</function>
          function is called, the application starts performing any necessary
          processing. When the operating system (OS) starts the program, it
          gives the <function>main()</function> function some unit of
          processing time. After the time unit (quantum) for the process
          expires, the OS performs what is called a <quote>context switch</quote>
          to change control to another process. VR Juggler achieves similar
          functionality but in a slightly different manner.</para>

          <para>The application objects correspond to processes in a normal
          OS. The kernel is the scheduler, and it allocates time to an
          application by invoking the methods of the application object.
          Because the kernel has additional information about the resources
          needed by the applications, it maintains a very strict schedule to
          define when the application is granted processing time. This is the
          basis to maintain coherence across the system.</para>
        </section>

        <section>
          <title>Application Objects Derive from Base Classes for Specific
          Graphics APIs</title>

          <para>The first step in defining an application object<indexterm><primary>application
          object</primary></indexterm> is to implement the basic interfaces
          defined by the kernel and the Draw Managers<indexterm><primary>Draw
          Manager</primary></indexterm>. There is a base class for the
          interface that the kernel expects (<classname>vrj::App</classname><indexterm><primary>classes</primary><secondary>vrj::App</secondary></indexterm>)
          and a base class handled by each Draw Manager interface (<classname>vrj::PfApp</classname><indexterm><primary>classes</primary><secondary>vrj::PfApp</secondary><seealso>vrj::PfApp</seealso></indexterm>,
          <classname>vrj::GlApp</classname><indexterm><primary>classes</primary><secondary>vrj::GlApp</secondary><seealso>vrj::GlApp</seealso></indexterm>,
          etc.). See <xref linkend="figure.vrj.App.hierarchy" /> for a visual
          representation of the complete application interface hierarchy. The
          interface defined in <classname>vrj::App</classname><indexterm><primary>classes</primary><secondary>vrj::App</secondary></indexterm>
          specifies methods for initialization, shutdown, and execution of the
          application. This is the abstract type that is seen by the VR
          Juggler kernel. The Draw Manager interfaces specified in the
          <classname>vrj::*App</classname> classes define the API-specific
          functions necessary to render the virtual environment. For example,
          an interface used by a Draw Manager could have functions for drawing
          the scene and for initializing context-specific information.</para>

          <figure id="figure.vrj.App.hierarchy">
            <title><classname>vrj::App</classname> hierarchy</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="figures/AppHierarchy.png"
                format="PNG" />
              </imageobject>
            </mediaobject>
          </figure>
        </section>

        <section>
          <title>Writing an Application Means Filling in the Blanks</title>

          <para>To implement an application in VR Juggler, developers simply
          need to <quote>fill in the blanks</quote> of the appropriate
          interfaces. To simplify this process, there are default
          implementations of most methods in the interfaces. Hence, the user
          must only provide implementations for the aspects they want to
          customize. If an implementation is not provided in the user
          application object, the default is used, but it is important to know
          that in most cases, the default implementation does nothing.</para>

          <tip>
            <para>When overriding a virtual method defined by a VR Juggler
            application class, it is best to call the parent class method
            implementation before performing any application-specific
            processing. For example, if a user-defined application object
            overrides <methodname>vrj::App::init()</methodname> in the class
            <classname>userApp</classname>, the method
            <methodname>userApp::init()</methodname> should invoke
            <methodname>vrj::App::init()</methodname> before performing its
            own initialization steps.</para>
          </tip>
        </section>
      </section>

      <section>
        <title>Benefits of Application Objects</title>

        <indexterm>
          <primary>application object</primary>

          <secondary>benefits of</secondary>
        </indexterm>

        <para>As stated earlier, the most common approach for VR application
        development is one where the application defines the
        <function>main()</function> function. That <function>main()</function>
        function in turn calls library functions when needed. (This is the
        model followed by software packages such as the
        <trademark>CAVElibs</trademark> and the Diverse Toolkit.) The library
        in this model only executes code when directed to do so by the
        application. As a result, the application developer is responsible for
        coordinating the execution of the different VR system components. This
        can lead to complex applications.</para>

        <section>
          <title>Allow for Run-Time Changes</title>

          <para>As a <glossterm linkend="gloss.virtual.platform">virtual
          platform</glossterm>, VR Juggler does not use the model described
          above because VR Juggler needs to maintain control of the system
          components. This control is necessary to make changes to the virtual
          platform at run time. As the controller of the execution, the kernel
          always knows the current state of the applications, and therefore,
          it can manage the run-time reconfigurations of the virtual
          environment safely. With run-time reconfiguration, it is possible to
          switch applications, start new devices, reconfigure running devices,
          and send reconfiguration information to the application object.</para>
        </section>

        <section>
          <title>Low Coupling</title>

          <para>Application objects lead to a robust architecture as a result
          of low coupling and well-defined inter-object dependencies. The
          application interface defines the only communication path between
          the application and the virtual platform, and this allows
          restriction of inter-object dependencies. This decreased coupling
          allows changes in the system to be localized, and thus, changes to
          one object will not affect another unless the interface itself is
          changed. The result is code that is more robust and more extensible.</para>

          <para>Because the application is simply an object, it is possibly to
          load and unload applications dynamically. When the virtual platform
          initializes, it waits for an application to be passed to it. When
          the application is given to the VR Juggler kernel at run time, the
          kernel performs a few initialization steps and then executes the
          application.</para>
        </section>

        <section>
          <title>Allows Implementation Changes</title>

          <para>Since applications use a distinct interface to communicate
          with the virtual platform, changes to the implementation of the
          virtual platform do not affect the application. Changes could
          include bug fixes, performance tuning, or new device support.</para>
        </section>

        <section>
          <title>Multi-Language Interaction</title>

          <para>By treating applications as objects, we can mix programming
          languages in the VR Juggler kernel. For example, an application
          object could be written in Python, C#, or even VB.NET, but the VR
          Juggler kernel (written in standard C++) will still see it as an
          instance of the abstract interface <classname>vrj::App</classname><indexterm><primary>classes</primary><secondary>vrj::App</secondary></indexterm>.
          The use of application objects has allowed such extensions to VR
          Juggler to be written without requiring any changes to VR Juggler.</para>
        </section>
      </section>

      <section id="section.app.startup">
        <title>VR Juggler Startup</title>

        <indexterm zone="section.app.startup">
          <primary>applications</primary>

          <secondary>starting</secondary>
        </indexterm>

        <para>In this section, we describe one way to start VR Juggler. We
        will use the traditional <function>main()</function> function in C++,
        but this is not the only way to do it. We have written Python
        applications that start the VR Juggler kernel, and it is possible to
        write a VR Juggler <glossterm linkend="gloss.daemon">daemon</glossterm>
        that loads applications on demand at runtime. In other words, the VR
        Juggler startup procedure is quite flexible, and we choose to focus on
        the simplest method here.</para>

        <section id="section.app.startup.no.main">
          <title>No <function>main()</function>—Sort Of</title>

          <indexterm zone="section.app.startup.no.main">
            <primary>applications</primary>

            <secondary>main function</secondary>

            <tertiary>use</tertiary>
          </indexterm>

          <para>Previously, we explained how VR Juggler applications do not
          have a <function>main()</function> function, but further explanation
          is required. While it is true that user <emphasis>applications</emphasis>
          do not have a <function>main()</function> function because they are
          objects, there must still be a <function>main()</function> somewhere
          that starts the system. This is because the operating system uses
          <function>main()</function> as the starting point for all
          applications. In typical VR Juggler applications, there is a
          <function>main()</function>, but it only starts the VR Juggler
          kernel and gives the kernel the application to run. It then waits
          for the kernel to shut down before exiting.</para>
        </section>

        <section id="section.app.main.structure">
          <title>Structure of a <function>main()</function> Function</title>

          <indexterm zone="section.app.main.structure">
            <primary>applications</primary>

            <secondary>main function</secondary>

            <tertiary>structure</tertiary>
          </indexterm>

          <para>The following is a typical example of a <function>main()</function>
          function that will start the VR Juggler kernel and hand it an
          instance of a user application object. The specifics of what is
          happening in this code are described below.</para>

          <programlistingco>
            <areaspec>
              <area coords="5 75" id="simpleApp.main.body.create-kernel" />

              <area coords="6 75" id="simpleApp.main.body.app-instantiate" />

              <area coords="8 75" id="simpleApp.main.body.loadConfigFile" />

              <area coords="9 75" id="simpleApp.main.body.start" />

              <area coords="10 75" id="simpleApp.main.body.setApp" />
            </areaspec>

            <programlisting linenumbering="numbered">#include &#60;vrj/Kernel/Kernel.h&#62;
#include &#60;simpleApp.h&#62;

int main(int argc, char* argv[])
{
   vrj::Kernel* kernel = vrj::Kernel::instance(); // Get the kernel
   simpleApp* app      = new simpleApp();         // Create the app object

   kernel-&#62;loadConfigFile(...);             // Configure the kernel
   kernel-&#62;start();                         // Start the kernel thread
   kernel-&#62;setApplication(app);             // Give application to kernel
   kernel-&#62;waitForKernelStop();             // Block until kernel stops

   return 0;
}</programlisting>

            <calloutlist>
              <callout arearefs="simpleApp.main.body.create-kernel">
                <para>This line finds (and may create) the VR Juggler kernel.
                The kernel reference is stored in the handle so that we can
                use it later.</para>
              </callout>

              <callout arearefs="simpleApp.main.body.app-instantiate">
                <para>We instantiate a copy of the user application object (<classname>simpleApp</classname>)
                here. Notice that we include the header file that defines the
                <classname>simpleApp</classname> class.</para>
              </callout>

              <callout arearefs="simpleApp.main.body.loadConfigFile">
                <para>This statement represents the code that will be in the
                <function>main()</function> function for passing configuration
                files to the kernel&#39;s <methodname>loadConfigFile()</methodname>
                method. These configuration files may come from the command
                line or from some other source. If reading the files from the
                command line, it can be as simple as looping through all the
                arguments and passing each one to the kernel.</para>
              </callout>

              <callout arearefs="simpleApp.main.body.start">
                <para>As a result of this statement, the VR Juggler kernel
                begins running. It creates a new thread of execution for the
                kernel, and the kernel begins its internal processing. From
                this point on, any changes made reconfigure the kernel. These
                changes can come in the form of more configuration files or in
                the form of an application object to execute. At this point,
                it is important to notice that the kernel knows nothing about
                the application. Moreover, there is no need for it to know
                about configuration files yet. This demonstrates how the VR
                Juggler kernel executes independently from the user
                application. The kernel will simply work on its own
                controlling and configuring the system even without an
                application to run.</para>
              </callout>

              <callout arearefs="simpleApp.main.body.setApp">
                <para>This statement finally tells the kernel what application
                it should run. The method call reconfigures the kernel so that
                it will now start invoking the application object&#39;s member
                functions. It is at this time that the application is now
                running in the VR system.</para>
              </callout>
            </calloutlist>
          </programlistingco>
        </section>
      </section>

      <section>
        <title>Kernel Loop</title>

        <para>Before proceeding into application object details, we must
        understand how VR Juggler calls the application, and we must know what
        a <glossterm linkend="gloss.frame">frame</glossterm><indexterm><primary>frame</primary></indexterm>
        is. In the code above, the statement on line 9 tells the kernel thread
        to start running. When the kernel begins its execution, it follows the
        sequence shown in <xref linkend="figure.kernel.loop.sequence" />. The
        specific methods called are described in more detail in the following
        section. This diagram will be useful in understanding the order in
        which the application object methods are invoked.</para>

        <figure id="figure.kernel.loop.sequence">
          <title>Kernel loop sequence</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
              fileref="figures/Kernel_Loop_Call_Sequence.png" format="PNG"
              scalefit="1" />
            </imageobject>
          </mediaobject>
        </figure>

        <section id="section.frame.definition">
          <title>Definition of a Frame</title>

          <indexterm zone="section.frame.definition">
            <primary>frame</primary>

            <secondary>definition of</secondary>
          </indexterm>

          <para>The VR Juggler kernel calls each of the methods in the
          application object based on a strictly scheduled
          <firstterm>frame of execution</firstterm><indexterm><primary>frame
          of execution</primary></indexterm>. The frame of execution is shown
          in <xref linkend="figure.kernel.loop.sequence" />; it makes up all
          the lines within the <quote>while(!quit)</quote> clause.</para>

          <para>During the frame of execution, the kernel calls the
          application methods and performs internal updates (the
          <methodname>updateAllData()</methodname> method call). Because the
          kernel has complete control over the frame, it can make changes at
          pre-defined <quote>safe</quote> times when the application is not
          doing any processing. At these times, the kernel can change the
          virtual platform configuration as long as the interface remains the
          same.</para>

          <para>The frame of execution also serves as a framework for the
          application. That is, the application can expect that when
          <methodname>preFrame()</methodname> is called, the devices have just
          been updated. Applications can rely upon the system being in
          well-defined stages of the frame when the kernel invokes the
          application object&#39;s methods.</para>
        </section>
      </section>

      <section id="section.base.app.obj.interface">
        <title>Base Application Object Interface</title>

        <indexterm zone="section.base.app.obj.interface">
          <primary>application object</primary>

          <secondary>base interface of</secondary>
        </indexterm>

        <para>Within this section, we provide a brief overview of the member
        functions from the base VR Juggler application interface. This
        interface is defined by <classname>vrj::App</classname><indexterm><primary>classes</primary><secondary>vrj::App</secondary></indexterm>,
        and the member functions are shown in <xref
        linkend="figure.app.obj.interface" />. Refer to <xref
        linkend="figure.kernel.loop.sequence" /> for a visual presentation of
        the order in which the methods are invoked.</para>

        <para>The base interface of the application object defines the
        following functions:</para>

        <itemizedlist>
          <listitem>
            <para><methodname>init()</methodname></para>
          </listitem>

          <listitem>
            <para><methodname>apiInit()</methodname></para>
          </listitem>

          <listitem>
            <para><methodname>preFrame()</methodname></para>
          </listitem>

          <listitem>
            <para><methodname>intraFrame()</methodname></para>
          </listitem>

          <listitem>
            <para><methodname>postFrame()</methodname></para>
          </listitem>
        </itemizedlist>

        <para>As previously described, the VR Juggler kernel calls these
        functions from its control loop to allocate processing time to them.
        These functions handle initialization and computation. Other member
        functions that can be used for reconfiguration, focus control,
        resetting, and exiting will be covered later in this book.</para>

        <figure id="figure.app.obj.interface">
          <title>Application object interface</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
              fileref="figures/userOglApp_hierarchy.png" format="PNG" />
            </imageobject>
          </mediaobject>
        </figure>

        <section id="section.app.obj.init">
          <title>Initialization</title>

          <indexterm zone="section.app.obj.init">
            <primary>application object</primary>

            <secondary>initialization</secondary>
          </indexterm>

          <para>The following is a description of the application objects
          related to the initialization of a VR Juggler application. The order
          of presentation is the same as the order of execution when the
          application is executed by the kernel.</para>

          <section>
            <title><methodname>vrj::App::init()</methodname></title>

            <para>The <methodname>init()</methodname> method is called by the
            kernel to initialize any application data. When the kernel
            prepares to start a new application, it first calls
            <methodname>init()</methodname> to signal the application that it
            is about to be executed.</para>

            <section>
              <title>Timing</title>

              <para>This member function is called immediately after the
              kernel is told to start running the application and before any
              graphics API handling has been started by VR Juggler.</para>
            </section>

            <section>
              <title>Uses</title>

              <para>Typical applications will utilize this method to load data
              files, create lookup tables, or perform some steps that should
              be done only once per execution. In other words, this method is
              the place to perform any pre-processing steps needed by the
              application to set up its data structures.</para>
            </section>
          </section>

          <section>
            <title><methodname>vrj::App::apiInit()</methodname></title>

            <para>This member function is for any graphics API-specific
            initialization required by the application. Data members that
            cannot be initialized until after the graphics API is started
            should be initialized here.</para>

            <note>
              <para>In OpenGL, there is no concept of initializing the API, so
              this method is normally empty in such applications.</para>
            </note>

            <section>
              <title>Timing</title>

              <para>This member function is called after the graphics API has
              been started but before the kernel frame is started.</para>
            </section>

            <section>
              <title>Uses</title>

              <para>In most cases, scene graph loading and other API-specific
              initialization should be done in this method.</para>
            </section>
          </section>
        </section>

        <section id="section.app.frame.functions">
          <title>Frame Functions</title>

          <indexterm zone="section.app.frame.functions">
            <primary>application object</primary>

            <secondary>frame functions</secondary>
          </indexterm>

          <para>Once the application object has been initialized by the VR
          Juggler kernel, the kernel frame loop begins. Each frame, there are
          specific application object methods that are invoked, and
          understanding the timing and potential uses of these methods can
          improve the functionality of the immersive application. In some
          cases, it is possible to use these member functions to optimize the
          application to improve the frame rate and the level of
          interactivity.</para>

          <section>
            <title><methodname>vrj::App::preFrame()</methodname></title>

            <para>The <methodname>preFrame()</methodname> method is called
            when the system is about to trigger drawing. This is the time that
            the application object should do any last-minute updates of data
            based on input device status. It is best to avoid doing any
            time-consuming computation in this method. The time used in this
            method contributes to the overall device latency in the system.
            The devices will not be re-sampled before rendering begins.</para>

            <section>
              <title>Timing</title>

              <para>This method is called immediately before triggering
              rendering of the current frame.</para>
            </section>

            <section>
              <title>Uses</title>

              <para>In general, this method should be reserved for
              <quote>last-millisecond</quote> data updates in response to
              device input (latency-critical code).</para>
            </section>
          </section>

          <section id="section.app.intraFrame">
            <title><methodname>vrj::App::intraFrame()</methodname></title>

            <para>The code in this method executes in parallel with the
            rendering method. That is, it executes while the current frame is
            being drawn. This is the place to put any processing that can be
            done in advance for the next frame. By doing parallel processing
            in this method, the application can increase its frame rate
            because drawing and computation can be parallelized. Special care
            must be taken to ensure that any data being used for rendering
            does not change while rendering is happening. One method for doing
            this is buffering. Use of synchronization primitives is not
            recommended because that technique could <emphasis>lower</emphasis>
            the frame rate.</para>

            <section>
              <title>Timing</title>

              <para>This method is invoked after rendering has been triggered
              but before the rendering has finished.</para>
            </section>

            <section>
              <title>Uses</title>

              <para>The primary use of this method is performing
              time-consuming computations, the results of which can be used in
              the next frame.</para>
            </section>
          </section>

          <section>
            <title><methodname>vrj::App::postFrame()</methodname></title>

            <para>Finally, the <methodname>postFrame()</methodname> method is
            available for final processing at the end of the kernel frame
            loop. This is a good place to do any data updates that are not
            dependent upon input data and cannot be overlapped with the
            rendering process (see the discussion on <methodname>vrj::App::intraFrame()</methodname>
            above).</para>

            <section>
              <title>Timing</title>

              <para>This method is invoked after rendering has completed but
              before VR Juggler updates devices and other internal data.</para>
            </section>

            <section>
              <title>Uses</title>

              <para>Some possible uses of this method include <quote>cleaning
              up</quote> after the frame has been rendered or synchronizing
              with external networking or computational processes.</para>
            </section>
          </section>
        </section>
      </section>

      <section id="section.draw.mgr.classes">
        <title>Draw Manager-Specific Application Classes</title>

        <indexterm>
          <primary>Draw Manager</primary>

          <secondary>application classes</secondary>
        </indexterm>

        <para>Beyond the basic methods common to all applications, there are
        methods that are specific to a given Draw Manager. The application
        classes are extended for each of the specific Draw Managers. The
        graphics API-specific application classes derive from
        <classname>vrj::App</classname><indexterm><primary>classes</primary><secondary>vrj::App</secondary></indexterm>
        and extend this interface further. They add extra <quote>hooks</quote>
        that support the abilities of the specific API.</para>

        <section id="section.draw.mgr.opengl.classes">
          <title>OpenGL Application Class</title>

          <indexterm zone="section.draw.mgr.opengl.classes">
            <primary>Draw Manager</primary>

            <secondary>application classes</secondary>

            <tertiary>OpenGL</tertiary>
          </indexterm>

          <para>The OpenGL application base class adds several methods to the
          application interface that allow rendering of OpenGL graphics. The
          extensions to the base <classname>vrj::App</classname><indexterm><primary>classes</primary><secondary>vrj::App</secondary></indexterm>
          class are shown in <xref linkend="figure.vrj.GlApp" />. In the
          following, we describe the method <methodname>vrj::GlApp::draw()</methodname>,
          the most important element of the interface. More details about the
          <classname>vrj::GlApp</classname><indexterm><primary>classes</primary><secondary>vrj::GlApp</secondary></indexterm>
          class are provided in <xref linkend="section.opengl.apps" />, found
          in <xref linkend="chapter.writing.apps" />.</para>

          <figure id="figure.vrj.GlApp">
            <title><classname>vrj::GlApp</classname> interface extensions to
            <classname>vrj::App</classname></title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="figures/GlAppHierarchy.png"
                format="PNG" />
              </imageobject>
            </mediaobject>
          </figure>

          <section>
            <title><methodname>vrj::GlApp::draw()</methodname></title>

            <para>The <quote>draw function</quote> is called by the OpenGL
            Draw Manager when it needs to render the current scene in an
            OpenGL graphics window. It is called for each active OpenGL
            context.</para>
          </section>

          <section>
            <title><methodname>vrj::GlApp::getDrawScaleFactor()</methodname></title>

            <para>As of VR Juggler 2.0 Alpha 1, applications can specify the
            units of measure that are the basis for the graphics they render.
            The default unit of measure is feet (identified by the constant
            scale factor <constant>gadget::PositionUnitConversion::ConvertToFeet</constant>)
            to maintain backwards compatibility with the previous VR Juggler
            semantics. By overriding this method, applications can identify
            the unit of measure they expect. The default implementation is the
            following:</para>

            <programlisting>float vrj::GlApp::getDrawScaleFactor()
{
   return gadget::PositionUnitConversion::ConvertToFeet;
}</programlisting>

            <para>Overriding this method means changing the rendering scale
            factor used by the OpenGL Draw Manager. The current list of
            constants (defined in <filename>gadget/Position/PositionUnitConversion.h</filename>)
            is as follows:</para>

            <itemizedlist>
              <listitem>
                <para><constant>gadget::PositionUnitConversion::ConvertToFeet</constant></para>
              </listitem>

              <listitem>
                <para><constant>gadget::PositionUnitConversion::ConvertToInches</constant></para>
              </listitem>

              <listitem>
                <para><constant>gadget::PositionUnitConversion::ConvertToMeters</constant></para>
              </listitem>

              <listitem>
                <para><constant>gadget::PositionUnitConversion::ConvertToCentimeters</constant></para>
              </listitem>
            </itemizedlist>

            <para>Because the value returned is simply a scaling factor, user
            applications can define whatever units they want. Note that
            internally, VR Juggler is treating all units as
            <emphasis>meters</emphasis>, so the scaling factor converts from
            meters to the desired units.</para>
          </section>
        </section>

        <section id="section.draw.mgr.performer">
          <title>OpenGL Performer Application Class</title>

          <indexterm zone="section.draw.mgr.performer">
            <primary>Draw Manager</primary>

            <secondary>application classes</secondary>

            <tertiary>OpenGL Performer</tertiary>
          </indexterm>

          <para>The OpenGL Performer application base class adds interface
          functions that deal with the OpenGL Performer scene graph. Some of
          the interface extensions are shown in <xref
          linkend="figure.vrj.PfApp" />. The following is a description of
          only two methods in the <classname>vrj::PfApp</classname><indexterm><primary>classes</primary><secondary>vrj::PfApp</secondary></indexterm>
          interface. More detailed discussion on this class is provided in
          <xref linkend="section.pf.apps" />, found in <xref
          linkend="chapter.writing.apps" />.</para>

          <figure id="figure.vrj.PfApp">
            <title><classname>vrj::PfApp</classname> interface extensions to
            <classname>vrj::App</classname></title>

            <mediaobject>
              <imageobject>
                <imagedata align="center"
                fileref="figures/userPfApp_hierarchy.png" format="PNG" />
              </imageobject>
            </mediaobject>
          </figure>

          <section>
            <title><methodname>vrj::PfApp::initScene()</methodname></title>

            <para>The <methodname>initScene()</methodname> member function is
            called when the application should create the scene graph it will
            use.</para>
          </section>

          <section>
            <title><methodname>vrj::PfApp::getScene()</methodname></title>

            <para>The <methodname>getScene()</methodname> member function is
            called by the Performer Draw Manager when it needs to know what
            scene graph it should render for the application.</para>
          </section>
        </section>
      </section>
    </chapter>

    <chapter id="chapter.helper.classes">
      <title>Helper Classes</title>

      <para>Within this chapter, we present information on some helper classes
      that are provided for use with VR Juggler. These classes are intended to
      make it easier for application programmers to write their code.
      Ultimately, we want application programmers to focus more on compelling
      immersive content and less on the many details that are involved with 3D
      graphics programming. The classes presented in this chapter focus on
      mathematical computations and on input from hardware devices. VR Juggler
      uses the Graphics Math Template Library or GMTL (part of the <ulink
      url="http://ggt.sf.net/">Generic Graphics Toolkit</ulink> software) for
      mathematical computation. An overview of the most commonly used GMTL
      data types and operations is presented here. In addition to the GMTL
      operations, special attention is paid to Gadgeteer, the input system
      used by VR Juggler, and its device interfaces and device proxies.</para>

      <section id="section.vec.classes">
        <title>The <classname>gmtl::Vec&#60;S, T&#62;</classname> Helper Class</title>

        <indexterm>
          <primary>gmtl::Vec&#60;S, T&#62;</primary>
        </indexterm>

        <para>This section is intended to provide an introduction to how the
        helper class <classname>gmtl::Vec&#60;S, T&#62;</classname><indexterm><primary>classes</primary><secondary>gmtl::Vec&#60;S,
        T&#62;</secondary><seealso>gmtl::Vec3f, gmtl::Vec4f</seealso></indexterm>
        works and how it can be used in VR Juggler applications. It begins
        with a high-level description of the classes which forms the necessary
        basis for understanding them in detail. Then, examples of how to use
        all the available operations in the interfaces for these classes are
        provided. It concludes with a description of the internal details of
        the classes.</para>

        <section>
          <title>High-Level Description</title>

          <indexterm>
            <primary>gmtl::Vec&#60;S, T&#62;</primary>

            <secondary>description of</secondary>
          </indexterm>

          <para>The class <classname>gmtl::Vec&#60;S, T&#62;</classname><indexterm><primary>classes</primary><secondary>gmtl::Vec&#60;S,
          T&#62;</secondary></indexterm> is designed to work the same way as a
          mathematical vector, typically of 3 or 4 dimensions. There are
          predefined vector types that would normally be used in a VR
          application that are provided for convenience. That is, a
          <classname>gmtl::Vec3f</classname> object can be thought of as a
          vector of the form &#60;x, y, z&#62;. Similarly, a
          <classname>gmtl::Vec4f</classname> can be thought of as a vector of
          the form &#60;x, y, z, w&#62;. An existing understanding of
          mathematical vectors is sufficient to know how these classes can be
          used. The question then becomes, how are they used? We will get to
          that later, and readers who have experience with vectors can skip
          ahead. If vectors are an unfamiliar topic, it may be convenient to
          think of these classes as three- and four-element C++ arrays of
          <type>float</type>s respectively. Most benefits of the vector
          concept are lost with that simpler idea, however. Therefore, if the
          reader needs to think of them as arrays, then arrays should probably
          be used until vectors feel more comfortable. Once the use of vectors
          seems familiar and straightforward, readers are encouraged to come
          back and read further.</para>

          <para>Vectors are typically used to contain spatial data or
          something similar. For convenience, however, they can be visualized
          as a more general-purpose container for numerical data upon which
          well-defined operations can be performed. There is no need to
          constrain thinking of them as only holding the coordinates for some
          point in space or some other limited-scope use. The GMTL vectors use
          by VR Juggler retain this generality and can be used wherever
          vectors come in handy.</para>

          <para><classname>gmtl::Vec3f</classname> and <classname>gmtl::Vec4f</classname>,
          as specific implementations of mathematical vectors, hide vector
          operations on single-precision floating-point numbers (<type>float</type>)
          behind a simple-to-use interface. For a single vector, the following
          standard vector operations are available:</para>

          <itemizedlist>
            <listitem>
              <para>Inversion (changing the sign of all elements)</para>
            </listitem>

            <listitem>
              <para>Normalization</para>
            </listitem>

            <listitem>
              <para>Calculation of length</para>
            </listitem>

            <listitem>
              <para>Multiplication by a scalar</para>
            </listitem>

            <listitem>
              <para>Division by a scalar</para>
            </listitem>

            <listitem>
              <para>Conversion to a Performer vector</para>
            </listitem>
          </itemizedlist>

          <para>For two vectors, the following operations can be performed:</para>

          <itemizedlist>
            <listitem>
              <para>Assignment</para>
            </listitem>

            <listitem>
              <para>Equality/inequality comparison</para>
            </listitem>

            <listitem>
              <para>Dot product</para>
            </listitem>

            <listitem>
              <para>Cross product</para>
            </listitem>

            <listitem>
              <para>Addition</para>
            </listitem>

            <listitem>
              <para>Subtraction</para>
            </listitem>
          </itemizedlist>

          <para>Using GMTL vectors should be straightforward if readers
          understand these operations and keep in mind that
          <classname>gmtl::Vec3f</classname> and <classname>gmtl::Vec4f</classname>
          can be thought of at this high level.</para>
        </section>

        <section id="section.gmtl.Vec.use">
          <title>Using <classname>gmtl::Vec3f</classname> and
          <classname>gmtl::Vec4f</classname></title>

          <indexterm zone="section.gmtl.Vec.use">
            <primary>classes</primary>

            <secondary>gmtl::Vec3f</secondary>
          </indexterm>

          <indexterm zone="section.gmtl.Vec.use">
            <primary>classes</primary>

            <secondary>gmtl::Vec4f</secondary>
          </indexterm>

          <para>With an understanding of these classes as standard
          mathematical vectors, it is time to learn how to deal with them at
          the C++ level. In some cases, the mathematical operators are
          overloaded to simplify user code; in other cases, a named method
          must be invoked on an object. Before any of that, however, make sure
          that the source file includes the <filename>gmtl/Vec.h</filename>
          header file. From here on, the available operations are presented in
          the order they were listed in the previous section. We begin with
          creating the objects and setting their values.</para>
        </section>

        <section id="section.gmtl.Vec.creation">
          <title>Creating Vectors and Setting Their Values</title>

          <indexterm>
            <primary>gmtl::Vec3f</primary>

            <secondary>creating</secondary>
          </indexterm>

          <indexterm>
            <primary>gmtl::Vec4f</primary>

            <secondary>creating</secondary>
          </indexterm>

          <para>Before doing anything with vectors, some must be created. The
          examples here use <classname>gmtl::Vec3f</classname>, but the
          example is equally applicable to <classname>gmtl::Vec4f</classname>.
          To create a <classname>gmtl::Vec3f</classname>, use the default
          constructor which initializes the vector to &#60;0.0, 0.0, 0.0&#62;:</para>

          <programlisting>gmtl::Vec3f vec1;</programlisting>

          <para>After creating the vector <varname>vec1</varname>, its
          elements can be assigned values all at once as follows:</para>

          <programlisting>vec1.set(1.0, 1.5, -1.0);</programlisting>

          <para>or individually:</para>

          <programlisting>vec1[0] = 1.0;
vec1[1] = 1.5;
vec1[2] = -1.0;</programlisting>

          <para>Note that in the last example, the individual elements of the
          vector can be accessed exactly as with a normal array. To do the
          above steps all at once when the vector is created, give the element
          values when declaring the vector:</para>

          <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0);</programlisting>

          <para>All of the above code has exactly the same results but
          accomplishes them in different ways. This flexibility is just one of
          the ways that GMTL vectors are more powerful than C++ arrays (of the
          same size, of course).</para>
        </section>

        <section id="section.gmtl.Vec.inversion">
          <title>Inversion (Finding the Negative of a Vector)</title>

          <indexterm>
            <primary>gmtl::Vec3f</primary>

            <secondary>inverting</secondary>
          </indexterm>

          <indexterm>
            <primary>gmtl::Vec4f</primary>

            <secondary>inverting</secondary>
          </indexterm>

          <para>Once a vector is created, the simplest operation that can be
          performed on it is finding its inverse. The following code
          demonstrates just that:</para>

          <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2;

vec2 = -vec1;</programlisting>

          <para>The vector <varname>vec2</varname> now has the value
          &#60;-1.0, -1.5, 1.0&#62;. That is all there is to it. (Readers
          interested in details should note that the above does a copy
          operation to return the negative values.)</para>
        </section>

        <section>
          <title>Normalization</title>

          <indexterm>
            <primary>gmtl::Vec3f</primary>

            <secondary>normalizing</secondary>
          </indexterm>

          <indexterm>
            <primary>gmtl::Vec4f</primary>

            <secondary>normalizing</secondary>
          </indexterm>

          <para>Normalizing a vector is another simple operation (at the
          interface level anyway). The following code normalizes a vector:</para>

          <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0);

gmtl::normalize( vec1 );</programlisting>

          <para>The vector <varname>vec1</varname> is now normalized. Clean
          and simple.</para>

          <para>Besides normalizing a given vector, a vector can be tested to
          determine if it has already been normalized. This is done as follows
          (assuming the vector <varname>vec</varname> has already been
          declared before this point):</para>

          <programlisting>if ( gmtl::isNormalized( vec1 ) )
{
   // Go here if vec is normalized
}</programlisting>
        </section>

        <section>
          <title>Length Calculation</title>

          <indexterm>
            <primary>gmtl::Vec3f</primary>

            <secondary>length of</secondary>
          </indexterm>

          <indexterm>
            <primary>gmtl::Vec4f</primary>

            <secondary>length of</secondary>
          </indexterm>

          <para>Part of normalizing a vector requires finding its length
          first. To get a vector&#39;s length, do the following:</para>

          <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0);
float length;

length = gmtl::length( vec1 );</programlisting>

          <para>In this case, length is assigned the value 2.061553 (or more
          accurately, the square root of 4.25). Finding the length of a vector
          appears simple from the programmer&#39;s perspective, but it has
          some hidden costs. Namely, it requires a square root calculation.
          For optimization purposes, GMTL provides a function called
          <function>gmtl::lengthSquared()</function> that returns the length
          of the vector without calculating the square root.</para>
        </section>

        <section>
          <title>Multiplication by a Scalar</title>

          <indexterm>
            <primary>gmtl::Vec3f</primary>

            <secondary>multiplying by a scalar</secondary>
          </indexterm>

          <indexterm>
            <primary>gmtl::Vec4f</primary>

            <secondary>multiplying by a scalar</secondary>
          </indexterm>

          <para>The GMTL vector classes provide an easy way to multiply a
          vector by a scalar. There are several ways to do it depending on
          what is required. Examples of each method follow.</para>

          <para>To multiply a vector by a scalar and store the result in
          another vector, do the following:</para>

          <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2;

vec2 = 3 * vec1;</programlisting>

          <para>(The order of the factors in the multiplication can be swapped
          depending on preference or need.) Here, <varname>vec2</varname> gets
          the value &#60;3.0, 4.5, -3.0&#62;.</para>

          <para>To multiply a vector by a scalar and store the result in the
          same vector, do the following:</para>

          <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0);

vec1 *= 3;</programlisting>

          <para>After this, <varname>vec1</varname> has the value &#60;3.0,
          4.5, -3.0&#62;.</para>
        </section>

        <section>
          <title>Division by a Scalar</title>

          <indexterm>
            <primary>gmtl::Vec3f</primary>

            <secondary>dividing by a scalar</secondary>
          </indexterm>

          <indexterm>
            <primary>gmtl::Vec4f</primary>

            <secondary>dividing by a scalar</secondary>
          </indexterm>

          <para>Very similar to multiplying by a scalar, division by scalars
          is also possible. While the examples are almost identical, they are
          provided here for clarity.</para>

          <para>To divide a vector by a scalar and store the result in another
          vector, do the following:</para>

          <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2;

vec2 = vec1 / 3;</programlisting>

          <para>Here, <varname>vec2</varname> gets the value &#60;0.333333,
          0.5, -0.333333&#62;. Note that the scalar must come after the vector
          because the operation would not make sense otherwise.</para>

          <para>To divide a vector by a scalar and store the result in the
          same vector, do the following:</para>

          <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0);

vec1 /= 3;</programlisting>

          <para>After this, <varname>vec1</varname> has the value
          &#60;0.333333, 0.5, -0.333333&#62;.</para>
        </section>

        <section id="section.pfVec.to.gmtl.Vec">
          <title>Converting to an OpenGL Performer Vector</title>

          <indexterm zone="section.pfVec.to.gmtl.Vec">
            <primary>gmtl::Vec3f</primary>

            <secondary>converting to pfVec3</secondary>
          </indexterm>

          <indexterm zone="section.pfVec.to.gmtl.Vec">
            <primary>pfVec3</primary>

            <secondary>converting from gmtl::Vec3f</secondary>

            <seealso>gmtl::Vec3f</seealso>
          </indexterm>

          <para>SGI&#39;s OpenGL Performer likes to work with its own
          <classname>pfVec3</classname> class, and to facilitate the use of it
          with <classname>gmtl::Vec3f</classname>, two conversion functions
          are provided for converting a <classname>gmtl::Vec3f</classname> to
          a <classname>pfVec3</classname> and vice versa. The first works as
          follows:</para>

          <programlisting>gmtl::Vec3f vj_vec;
pfVec3 pf_vec;

// Do stuff to vj_vec...

pf_vec = vrj::GetPfVec(vj_vec);</programlisting>

          <para>where <varname>vj_vec</varname> is passed by reference for
          efficiency. (<varname>pf_vec</varname> gets a copy of a
          <classname>pfVec3</classname>.) To convert a <classname>pfVec3</classname>
          to a <classname>gmtl::Vec3f</classname>, do the following:</para>

          <programlisting>pfVec3 pf_vec;
gmtl::Vec3f vj_vec;

// Do stuff to pf_vec...

vj_vec = vrj::GetVjVec(pf_vec);</programlisting>

          <para>Here again, <varname>pf_vec</varname> is passed by reference
          for efficiency, and <varname>vj_vec</varname> gets a copy of a
          <classname>gmtl::Vec3f</classname>. Both of these functions are
          found in the header <filename>vrj/Draw/Pf/PfUtil.h</filename>.</para>
        </section>

        <section>
          <title>Assignment</title>

          <indexterm>
            <primary>gmtl::Vec3f</primary>

            <secondary>assigning</secondary>
          </indexterm>

          <indexterm>
            <primary>gmtl::Vec4f</primary>

            <secondary>assigning</secondary>
          </indexterm>

          <para>We have already demonstrated vector assignment, though it was
          not pointed out explicitly. It works just as vector assignment in
          mathematics. The C++ code that does assignment is as follows:</para>

          <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2;

vec2 = vec1;</programlisting>

          <para>After the assignment, <varname>vec2</varname> has the value
          &#60;-1.0, -1.5, 1.0&#62;. Ta da! Note that this is a copy operation
          which is the case for all the types of assignments of GMTL vectors.</para>
        </section>

        <section>
          <title>Equality/Inequality Comparison</title>

          <indexterm>
            <primary>gmtl::Vec3f</primary>

            <secondary>equality comparison</secondary>
          </indexterm>

          <indexterm>
            <primary>gmtl::Vec4f</primary>

            <secondary>equality comparison</secondary>
          </indexterm>

          <para>To compare the equality of two vectors, there are three
          available methods (one is just the complement of the other, though):</para>

          <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0);

if ( gmtl::isEqual(vec1, vec2) )
{
   // Go here if vec1 and vec2 are equal.
}</programlisting>

          <para>or</para>

          <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0);

if ( vec1 == vec2 )
{
   // Go here if vec1 and vec2 are equal.
}</programlisting>

          <para>or</para>

          <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0);

if ( vec1 != vec2 )
{
   // Go here if vec1 and vec2 are not equal.
}</programlisting>

          <para>Choose whichever method is most convenient.</para>
        </section>

        <section>
          <title>Dot Product</title>

          <indexterm>
            <primary>gmtl::Vec3f</primary>

            <secondary>dot product</secondary>
          </indexterm>

          <indexterm>
            <primary>gmtl::Vec4f</primary>

            <secondary>dot product</secondary>
          </indexterm>

          <para>Given two vectors, finding the dot product is often needed.
          GMTL vectors provide a way to do this quickly so that programmers
          can save themselves the time of typing in the formula over and over.
          It works as follows:</para>

          <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0);
float dot_product;

dot_product = gmtl::dot(vec1, vec2);</programlisting>

          <para>Now, <varname>dot_product</varname> has the value 4.0.</para>
        </section>

        <section>
          <title>Cross Product</title>

          <indexterm>
            <primary>gmtl::Vec3f</primary>

            <secondary>cross product</secondary>
          </indexterm>

          <para>Besides the dot product of two vectors, the cross product is
          another commonly needed result. It is calculated thusly:</para>

          <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0), vec3;

vec3 = gmtl::cross(vec1, vec2);</programlisting>

          <para>The result is that <varname>vec3</varname> gets a copy of
          <varname>vec1</varname> cross <varname>vec2</varname>.</para>
        </section>

        <section>
          <title>Addition</title>

          <indexterm>
            <primary>gmtl::Vec3f</primary>

            <secondary>adding</secondary>
          </indexterm>

          <indexterm>
            <primary>gmtl::Vec4f</primary>

            <secondary>adding</secondary>
          </indexterm>

          <para>Adding two vectors can be done one of two ways. The first
          method returns a resulting vector, and the second method performs
          the addition and stores the result in the first vector.</para>

          <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0), vec3;

vec3 = vec1 + vec2;</programlisting>

          <para>Now, <varname>vec3</varname> has the value &#60;2.5, 2.5,
          -2.0&#62;.</para>

          <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0);

vec1 += vec2;</programlisting>

          <para>This time, <varname>vec1</varname> has the value &#60;2.5,
          2.5, -2.0&#62;.</para>
        </section>

        <section>
          <title>Subtraction</title>

          <indexterm>
            <primary>gmtl::Vec3f</primary>

            <secondary>subtracting</secondary>
          </indexterm>

          <indexterm>
            <primary>gmtl::Vec4f</primary>

            <secondary>subtracting</secondary>
          </indexterm>

          <para>Subtracting two vectors gives the same options as addition,
          and while the code is nearly identical, it is provided for the sake
          of clarity.</para>

          <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0), vec3;

vec3 = vec1 - vec2;</programlisting>

          <para>Now, <varname>vec3</varname> has the value &#60;-0.5, 0.5,
          0.0&#62;.</para>

          <programlisting>gmtl::Vec3f vec1(1.0, 1.5, -1.0), vec2(1.5, 1.0, -1.0);

vec1 -= vec2;</programlisting>

          <para>In this case, <varname>vec1</varname> has the value &#60;-0.5,
          0.5, 0.0&#62;.</para>
        </section>

        <section>
          <title>Full Transformation by a Matrix</title>

          <indexterm>
            <primary>gmtl::Vec3f</primary>

            <secondary>transforming by a matrix</secondary>

            <tertiary>full</tertiary>
          </indexterm>

          <indexterm>
            <primary>gmtl::Vec4f</primary>

            <secondary>transforming by a matrix</secondary>

            <tertiary>full</tertiary>
          </indexterm>

          <para>It is often helpful to apply a transformation to a vector.
          Transformations are represented by a matrix, so it is necessary to
          multiply a matrix and a vector. The function <function>gmtl::xform()</function>
          does this job. For the following example, assume that there is a
          <classname>gmtl::Matrix44f</classname> transformation matrix
          <varname>xform_mat</varname>:</para>

          <programlisting>gmtl::Vec3f vec(1.0, 1.0, 1.0), result_vec;

gmtl::xform(result_vec, xform_mat, vec1);</programlisting>

          <para>Depending on the transformations contained within
          <varname>xform_mat</varname>, <varname>result_vec</varname> will be
          transformed fully. The operation as a mathematical equation would
          be:</para>

          <informalequation>
            <mediaobject>
              <imageobject>
                <imagedata fileref="eq_v_eq_m_v.png" format="PNG" />
              </imageobject>

              <textobject>
                <phrase>V&#39; = M * V</phrase>
              </textobject>

              <textobject role="tex">
                <phrase>V^{\prime }=M*V</phrase>
              </textobject>
            </mediaobject>
          </informalequation>

          <para>where V and V&#39; are vectors and M is a 4×4 transformation
          matrix.</para>
        </section>

        <section>
          <title>The Gory Details</title>

          <indexterm>
            <primary>gmtl::Vec3f</primary>

            <secondary>details</secondary>
          </indexterm>

          <indexterm>
            <primary>gmtl::Vec4f</primary>

            <secondary>details</secondary>
          </indexterm>

          <para>The details behind <classname>gmtl::Vec3f</classname> and
          <classname>gmtl::Vec4f</classname> really are not all that gory.
          Internally, they are represented as three- and four-element arrays
          of <type>float</type>s respectively. Access to these arrays is
          provided through the member function <methodname>getData()</methodname>.
          For example, this access can be used in the following way:</para>

          <programlisting>gmtl::Vec3f pos(4.0, 1.0982, 10.1241);

glVertex3fv(pos.getData());</programlisting>

          <para>Granted, this particular example is rather silly and much
          slower than just listing the values as the individual arguments to
          <function>glVertex3f()</function>, but it should get the point
          across.</para>

          <para>In general, the <methodname>getData()</methodname> member
          function should be treated very carefully. Access to it is provided
          mainly so that operations similar to this example can be performed
          quickly. An example of abusing access to <methodname>getData()</methodname>
          follows:</para>

          <programlisting>gmtl::Vec4f my_vec;

my_vec.getData()[0] = 4.0;
my_vec.getData()[1] = 1.0982;
my_vec.getData()[2] = 10.1241;
my_vec.getData()[3] = 1.0;</programlisting>

          <para>Do not do this. It can be confusing to readers of the code who
          do not necessarily need to know the details of the internal
          representation. Instead, use one of the methods described above for
          creating vectors and assigning the elements values.</para>
        </section>
      </section>

      <section>
        <title>The <classname>gmtl::Matrix44f</classname> Helper Class</title>

        <indexterm>
          <primary>gmtl::Matrix44f</primary>
        </indexterm>

        <para>This section is intended to provide an introduction into how the
        helper class <classname>gmtl::Matrix44f</classname><indexterm><primary>classes</primary><secondary>gmtl::Matrix44f</secondary><seealso>gmtl::Matrix44f</seealso></indexterm>
        works and how it can be used in VR Juggler applications. It begins
        with a high-level description of the class, which forms the necessary
        basis for understanding it in detail. Then, examples of how to use all
        the available operations in the interfaces for the class are provided.
        It concludes with a description of the internal C++ details of
        <classname>gmtl::Matrix44f</classname>.</para>

        <section>
          <title>High-Level Description</title>

          <indexterm>
            <primary>gmtl::Matrix44f</primary>

            <secondary>description of</secondary>
          </indexterm>

          <para>Abstractly, <classname>gmtl::Matrix44f</classname><indexterm><primary>classes</primary><secondary>gmtl::Matrix44f</secondary><seealso>gmtl::Matrix44f</seealso></indexterm>
          represents a 4×4 matrix of single-precision floating-point values.
          The class includes implementations of the standard matrix operations
          such as transpose, scale, and multiply. More specifically, it is a
          mechanism to facilitate common matrix operations used in computer
          graphics, especially those associated with a <emphasis>transform</emphasis>
          matrix. On the surface, it is nearly identical to a 4×4 C++ array of
          <type>float</type>s, but there is one crucial difference: a
          <classname>gmtl::Matrix44f</classname> keeps its internal matrix in
          column-major order rather than in row-major order<indexterm><primary>gmtl::Matrix44f</primary><secondary>compared
          to C++ matrices</secondary></indexterm>. More detail on this is
          given below, but this is done because OpenGL maintains its internal
          matrices using the same memory layout. At the conceptual level, this
          does not matter—it is related only to the matrix representation in
          the computer&#39;s memory. Access to the elements is still in
          row-major order. In any case, understanding how C++ multidimensional
          arrays work means understanding 90% of what there is to know about
          <classname>gmtl::Matrix44f</classname>. The class provides a degree
          convenience not found with a normal C++ array, especially when
          programming with OpenGL. The complications surrounding the
          <classname>gmtl::Matrix44f</classname> class are identical to those
          with OpenGL matrix handling, and with an understanding of that, then
          all that is left to learn is the interface of
          <classname>gmtl::Matrix44f</classname>.</para>

          <para>As a representation of mathematical matrices,
          <classname>gmtl::Matrix44f</classname> implements several common
          operations performed on matrices to relieve the users of some
          tedious, repetitive effort. The general mathematical operations are:</para>

          <itemizedlist>
            <listitem>
              <para>Assignment</para>
            </listitem>

            <listitem>
              <para>Equality/inequality comparison</para>
            </listitem>

            <listitem>
              <para>Transposing</para>
            </listitem>

            <listitem>
              <para>Finding the inverse</para>
            </listitem>

            <listitem>
              <para>Addition</para>
            </listitem>

            <listitem>
              <para>Subtraction</para>
            </listitem>

            <listitem>
              <para>Multiplication</para>
            </listitem>

            <listitem>
              <para>Scaling by a scalar value</para>
            </listitem>
          </itemizedlist>

          <para>The operations well-suited for use with computer graphics are:</para>

          <itemizedlist>
            <listitem>
              <para>Creating an identity matrix quickly</para>
            </listitem>

            <listitem>
              <para>Zeroing a matrix in a single step</para>
            </listitem>

            <listitem>
              <para>Creating an XYZ, a ZYX, or a ZXY Euler rotation matrix</para>
            </listitem>

            <listitem>
              <para>Constraining rotation about a specific axis or axes</para>
            </listitem>

            <listitem>
              <para>Making a matrix using direction cosines</para>
            </listitem>

            <listitem>
              <para>Making a matrix from a quaternion</para>
            </listitem>

            <listitem>
              <para>Making a rotation transformation matrix about a single
              axis</para>
            </listitem>

            <listitem>
              <para>Making a translation transformation matrix</para>
            </listitem>

            <listitem>
              <para>Making a scale transformation matrix</para>
            </listitem>

            <listitem>
              <para>Extracting specific transformation information</para>
            </listitem>

            <listitem>
              <para>Converting to an OpenGL Performer matrix</para>
            </listitem>
          </itemizedlist>

          <para>What is presented here involves some complicated concepts that
          are far beyond the scope of this documentation. Without an
          understanding of matrix math (linear algebra) and an understanding
          of how transformation matrices work in OpenGL, this document will
          not be very useful. It is highly recommended that readers be
          familiar with these topics before proceeding. Otherwise, with this
          high-level description in mind, we now continue on to explain the
          <classname>gmtl::Matrix44f</classname> class at the C++ level.</para>
        </section>

        <section>
          <title>Using <classname>gmtl::Matrix44f</classname></title>

          <indexterm>
            <primary>classes</primary>

            <secondary>gmtl::Matrix44f</secondary>
          </indexterm>

          <para>Keeping the idea of a normal mathematical matrix in mind, we
          are now ready to look at the C++ use of the <classname>gmtl::Matrix44f</classname>
          class. Most of the interface is defined using methods, but there are
          a few cases where mathematical operators have been overloaded to
          make code easier to read. Before going any further, whenever using a
          <classname>gmtl::Matrix44f</classname>, make sure to include
          <filename>gmtl/Matrix.h</filename> first. The operations presented
          above are now described in detail in the order in which they were
          listed above. We begin with creating the objects and setting their
          values.</para>
        </section>

        <section>
          <title>Creating Matrices and Setting Their Values</title>

          <indexterm>
            <primary>gmtl::Matrix44f</primary>

            <secondary>creating</secondary>
          </indexterm>

          <para>Before doing anything with matrices, some must be created
          first. To create a <classname>gmtl::Matrix44f</classname>, the
          default constructor can be used. It initializes the matrix to be an
          identity matrix:</para>

          <programlisting>gmtl::Matrix44f mat1;</programlisting>

          <para>After creating this matrix <varname>mat1</varname>, its 16
          elements can be assigned values all at once as follows:</para>

          <programlisting>mat1.set(0.0, 1.0, 2.3, 4.1,
         8.3, 9.0, 2.2, 1.0,
         5.6, 9.9, 9.7, 8.2,
         3.8, 0.9, 2.1, 0.1);</programlisting>

          <para>or with a <type>float</type> array:</para>

          <programlisting>float mat_vals[16] =
{
   0.0, 8.3, 5.6, 3.8,
   1.0, 9.0, 9.9, 0.9,
   2.3, 2.2, 9.7, 2.1,
   4.1, 1.0, 1.0, 0.1
};

mat1.set(mat_vals);</programlisting>

          <para>Note that when explicitly listing the values with
          <methodname>set()</methodname>, they are specified in
          <emphasis>row-major</emphasis> order. When put into a 16-element
          array of <type>float</type>s, however, they must be ordered so that
          they can be copied into the <classname>gmtl::Matrix44f</classname>
          in <emphasis>column-major</emphasis> order. This is the one
          exception in the interface where access is column-major (which
          probably means that the interface has a bug).</para>

          <para>To set all the values of a new matrix in one step, they can be
          given as arguments when declaring the matrix:</para>

          <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1,
                     8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2,
                     3.8, 0.9, 2.1, 0.1);</programlisting>

          <para>All of the above code has exactly the same results but
          accomplishes those results in different ways.</para>

          <para>To read the elements in a <classname>gmtl::Matrix44f</classname>
          object, programmers can use either the overloaded [] operator or the
          overloaded () operator. The overloaded [] operator returns the
          specified row of the <classname>gmtl::Matrix44f</classname>, and an
          element in that row can then be read using [] again. The code looks
          exactly the same as with a normal C++ two-dimensional array:</para>

          <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1,
                     8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2,
                     3.8, 0.9, 2.1, 0.1);
float val;

val = mat1[3][0];</programlisting>

          <para>Here, <varname>val</varname> is assigned the value 3.8. Using
          the overloaded () operator results in code that looks similar to the
          way the matrix element would be referenced in mathematics:</para>

          <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1,
                     8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2,
                     3.8, 0.9, 2.1, 0.1);
float val;

val = mat1(3, 0);</programlisting>

          <para>Again, <varname>val</varname> is assigned the value 3.8. Both
          of these operations are row-major.</para>
        </section>

        <section>
          <title>Assignment</title>

          <indexterm>
            <primary>gmtl::Matrix44f</primary>

            <secondary>assigning</secondary>
          </indexterm>

          <para>Assigning one <classname>gmtl::Matrix44f</classname> to
          another happens using the normal = operator as follows:</para>

          <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat2;

mat2 = mat1;</programlisting>

          <para>This makes a <emphasis>copy</emphasis> of <varname>mat1</varname>
          in <varname>mat2</varname> which can be a slow operation.</para>
        </section>

        <section>
          <title>Equality/Inequality Comparison</title>

          <indexterm>
            <primary>gmtl::Matrix44f</primary>

            <secondary>equality comparison</secondary>
          </indexterm>

          <para>To compare the equality of two matrices, there are three
          available methods (one is just the complement of the other, though):</para>

          <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);

if ( gmtl::isEqual(mat1, mat2) )
{
   // Go here if mat1 and mat2 are equal.
}</programlisting>

          <para>or</para>

          <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);

if ( mat1 == mat2 )
{
   // Go here if mat1 and mat2 are equal.
}</programlisting>

          <para>or</para>

          <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);

if ( mat1 != mat2 )
{
   // Go here if mat1 and mat2 are not equal.
}</programlisting>

          <para>Choose whichever method is most convenient.</para>
        </section>

        <section>
          <title>Transposing</title>

          <indexterm>
            <primary>gmtl::Matrix44f</primary>

            <secondary>transposing</secondary>
          </indexterm>

          <para>The transpose operation works conceptually as
          <inlineequation><inlinemediaobject><imageobject><imagedata
          fileref="eq_m1_eq_tr_m2.png" format="PNG" /></imageobject><textobject><phrase>matrix1
          = transpose(matrix2)</phrase></textobject><textobject role="tex"><phrase>matrix_{1}=transpose\left(
          matrix_{2}\right)</phrase></textobject></inlinemediaobject></inlineequation>.
          The code is then:</para>

          <programlisting>gmtl::Matrix44f mat1;
gmtl::Matrix44f mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);

gmtl::transpose(mat1, mat2);</programlisting>

          <para>The result is stored in <varname>mat1</varname>.
          <varname>mat2</varname> is passed by reference for efficiency.</para>
        </section>

        <section>
          <title>Finding the Inverse</title>

          <indexterm>
            <primary>gmtl::Matrix44f</primary>

            <secondary>inverting</secondary>
          </indexterm>

          <para>The inverse operation works conceptually as
          <inlineequation><inlinemediaobject><imageobject><imagedata
          fileref="eq_m1_eq_inv_m2.png" format="PNG" /></imageobject><textobject><phrase>matrix1
          = inverse(matrix2)</phrase></textobject><textobject role="tex"><phrase>matrix_{1}=inverse\left(
          matrix_{2}\right)</phrase></textobject></inlinemediaobject></inlineequation>.
          The code is then:</para>

          <programlisting>gmtl::Matrix44f mat1;
gmtl::Matrix44f mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);

gmtl::invert(mat1, mat2);</programlisting>

          <para>The result is stored in <varname>mat1</varname>.
          <varname>mat2</varname> is passed by reference for efficiency.</para>
        </section>

        <section>
          <title>Addition</title>

          <indexterm>
            <primary>gmtl::Matrix44f</primary>

            <secondary>adding</secondary>
          </indexterm>

          <para>For the addition operation, the interface is defined so that
          the sum of two matrices is stored in a third. There are two ways to
          do addition with <classname>gmtl::Matrix44f</classname>: using the
          add() method or using the overloaded + operator. Use of the former
          is recommended, but the latter can be used if one prefers that style
          of programming. Examples of both methods follow. The first block of
          code only declares the <classname>gmtl::Matrix44f</classname>
          objects.</para>

          <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat3;</programlisting>

          <para>Using the <function>gmtl::add()</function> function:</para>

          <programlisting>gmtl::add(mat3, mat1, mat2);</programlisting>

          <para>Using the overloaded + operator:</para>

          <programlisting>mat3 = mat1 + mat2;</programlisting>

          <para>The result is stored (via a copy) in <varname>mat3</varname>.</para>
        </section>

        <section>
          <title>Subtraction</title>

          <indexterm>
            <primary>gmtl::Matrix44f</primary>

            <secondary>subtracting</secondary>
          </indexterm>

          <para>For the subtraction operation, the interface is defined so
          that the difference of two matrices is stored in a third. There are
          two ways to do subtraction with <classname>gmtl::Matrix44f</classname>:
          using the <methodname>sub()</methodname> method or using the
          overloaded - operator. It is recommended that developers use the
          former, but the latter can be used for stylistic purposes. Examples
          of both methods follow. The first block of code only declares the
          <classname>gmtl::Matrix44f</classname> objects.</para>

          <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat3;</programlisting>

          <para>Using the <methodname>gmtl::sub()</methodname> method:</para>

          <programlisting>gmtl::sub(mat3, mat1, mat2);</programlisting>

          <para>Using the overloaded - operator:</para>

          <programlisting>mat3 = mat1 - mat2;</programlisting>

          <para>The result is stored (via a copy) in <varname>mat3</varname>.</para>
        </section>

        <section>
          <title>Multiplication</title>

          <indexterm>
            <primary>gmtl::Matrix44f</primary>

            <secondary>multiplying</secondary>
          </indexterm>

          <para>As in the case of addition and subtraction, the multiplication
          interface is defined so that the product of two matrices is stored
          in a third. This is likely to be the operation used most often since
          transformation matrices are constructed through multiplication of
          different transforms. For normal matrix multiplication, there are
          two ways to do multiplication with <classname>gmtl::Matrix44f</classname>:
          using the <function>gmtl::mult()</function> function or using the
          overloaded * operator. We recommend the use of the
          <function>gmtl::mult()</function> function but the overloaded *
          operator can be used by those who prefer that style of programming.
          Examples of both methods follow. The first block of code only
          declares the <classname>gmtl::Matrix44f</classname> objects.</para>

          <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                    5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat3;</programlisting>

          <para>Using the <function>gmtl::mult()</function> function:</para>

          <programlisting>gmtl::mult(mat3, mat1, mat2);</programlisting>

          <para>Using the overloaded * operator:</para>

          <programlisting>mat3 = mat1 * mat2;</programlisting>

          <para>The result is stored (via a copy) in <varname>mat3</varname>.</para>

          <para>There are two more multiplication operations provided that
          help in handling the order of the matrices when they are multiplied.
          These two extra operations do post-multiplication and
          pre-multiplication of two matrices. An example of
          post-multiplication is:</para>

          <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);

gmtl::postMult(mat1, mat2);</programlisting>

          <para>Conceptually, the operation is
          <inlineequation><inlinemediaobject><imageobject><imagedata
          fileref="eq_m1_eq_m1_m2.png" format="PNG" /></imageobject><textobject><phrase>mat1
          = mat1 * mat2</phrase></textobject><textobject role="tex"><phrase>mat_{1}=mat_{1}*mat_{2}</phrase></textobject></inlinemediaobject></inlineequation>
          so that the second matrix (<varname>mat2</varname>) comes as the
          second factor. The same result can be achieved using the overloaded
          *= operator:</para>

          <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);

mat1 *= mat2;</programlisting>

          <para>An example of pre-multiplication is:</para>

          <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);
gmtl::Matrix44f mat2(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);

gmtl::preMult(mat1, mat2);</programlisting>

          <para>Here, the conceptual operation is
          <inlineequation><inlinemediaobject><imageobject><imagedata
          fileref="eq_m1_eq_m2_m1.png" format="PNG" /></imageobject><textobject><phrase>mat1
          = mat2 * mat1</phrase></textobject><textobject role="tex"><phrase>mat_{1}=mat_{2}*mat_{1}</phrase></textobject></inlinemediaobject></inlineequation>
          so that the second matrix (<varname>mat2</varname>) comes as the
          first factor. In both cases, the result of the multiplication is
          stored in <varname>mat1</varname>.</para>
        </section>

        <section>
          <title>Scaling by a Scalar Value</title>

          <indexterm>
            <primary>gmtl::Matrix44f</primary>

            <secondary>scaling</secondary>
          </indexterm>

          <para>Scaling the values of a matrix by a scalar value can be done
          using two different methods: the <methodname>setScale()</methodname>
          method or the overloaded * and / operators that take a single scalar
          value and returns a <classname>gmtl::Matrix44f</classname>. As with
          the preceding operations, we recommend the use of the former, but
          the latter is available for those who want it. Examples of both
          methods follow. First, using the <function>gmtl::setScale()</function>
          function works as:</para>

          <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);


gmtl::setScale(mat1, 3.0);</programlisting>
        </section>

        <section>
          <title>Making an Identity Matrix Quickly</title>

          <indexterm>
            <primary>gmtl::Matrix44f</primary>

            <secondary>making</secondary>

            <tertiary>identity</tertiary>
          </indexterm>

          <para>In computer graphics, an identity matrix is often needed when
          performing transformations. Because of this, <classname>gmtl::Matrix44f</classname>
          provides a method for converting a matrix into an identity matrix in
          a single step (at the user code level anyway):</para>

          <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);

gmtl::identity(mat1);</programlisting>

          <para>Of course, simply declaring <varname>mat1</varname> with no
          arguments would achieve the same result, but that is not such an
          interesting example.</para>
        </section>

        <section>
          <title>Zeroing a Matrix in a Single Step</title>

          <indexterm>
            <primary>gmtl::Matrix44f</primary>

            <secondary>zeroing</secondary>
          </indexterm>

          <para>Before using a matrix, it is often helpful to zero it out to
          ensure that there is no pollution from previous use. With a
          <classname>gmtl::Matrix44f</classname>, this can be done in one
          step:</para>

          <programlisting>gmtl::Matrix44f mat1(0.0, 1.0, 2.3, 4.1, 8.3, 9.0, 2.2, 1.0,
                     5.6, 9.9, 9.7, 8.2, 3.8, 0.9, 2.1, 0.1);

gmtl::zero(mat1);</programlisting>

          <para>The result is that all elements of <varname>mat1</varname> are
          now 0.0.</para>
        </section>

        <section>
          <title>Making an XYZ, a ZYX, or a ZXY Euler Rotation Matrix</title>

          <indexterm>
            <primary>gmtl::Matrix44f</primary>

            <secondary>making</secondary>

            <tertiary>Euler rotation</tertiary>
          </indexterm>

          <para>All the rotation information for a transform can be contained
          in a single matrix using the methods for making an XYZ, a ZYX, or a
          ZXY Euler matrix. Code for all three follows:</para>

          <programlisting>vrj::Matrix mat1;
float x_rot = 0.4, y_rot = 0.541, z_rot = 0.14221;

gmtl::setRot(mat1, gmtl::EulerAngleXYZf(x_rot, y_rot, z_rot));
gmtl::setRot(mat1, gmtl::EulerAngleZYXf(z_rot, y_rot, x_rot));
gmtl::setRot(mat1, gmtl::EulerAngleZXYf(z_rot, x_rot, y_rot));</programlisting>

          <para>In every case, the matrix is zeroed before the rotation
          transformation is stored. The result of the above code is that
          <varname>mat1</varname> is a ZXY Euler rotation matrix. The previous
          two operations are destroyed.</para>
        </section>

        <section>
          <title>Making a Translation Transformation Matrix</title>

          <indexterm>
            <primary>gmtl::Matrix44f</primary>

            <secondary>making</secondary>

            <tertiary>translation transformation</tertiary>
          </indexterm>

          <para>To make a translation matrix, there are two methods with each
          having two different types of arguments specifying the translation.
          The first makes a matrix with only the given translation (all other
          transformation information is destroyed):</para>

          <programlisting>gmtl::Matrix44f mat;
gmtl::Vec3f trans(4.0, -4.231, 1.0);

mat = gmtl::makeTrans&#60;gmtl::Matrix44f&#62;(trans);</programlisting>

          <para>To <emphasis>change</emphasis> the translation of a
          transformation matrix without completely obliterating all other
          transformations, use the following instead:</para>

          <programlisting>gmtl::Vec3f trans(4.0, -4.231, 1.0);

gmtl::setTrans(mat, trans);</programlisting>
        </section>

        <section>
          <title>Making a Scale Transformation Matrix</title>

          <indexterm>
            <primary>gmtl::Matrix44f</primary>

            <secondary>making</secondary>

            <tertiary>scale transformation</tertiary>
          </indexterm>

          <para>To make a transformation matrix that only scales, a simple
          method is provided. It works as follows:</para>

          <programlisting>gmtl::Matrix44f mat;
gmtl::Vec3f scale( 1.5, 1.5, 1.5 );

mat = gmtl::makeScale&#60;Matrix44f&#62;(scale);</programlisting>

          <para>The result is that mat is a transformation matrix that will
          perform a scale operation. In this specific case, the scaling
          happens uniformly for x, y, and z.</para>
        </section>

        <section>
          <title>Extracting Specific Transformation Information</title>

          <indexterm>
            <primary>gmtl::Matrix44f</primary>

            <secondary>extracting transformation information</secondary>
          </indexterm>

          <para>Finally, methods are provided for extracting transformations
          from a given matrix. The individual rotations and the translation
          can be read. For the following examples, assume that
          <varname>mat</varname> is a <classname>gmtl::Matrix44f</classname>
          object representing arbitrary translation, rotation, and scaling
          transformations. To get the Z-axis rotation information (an Euler
          angle), use the following:</para>

          <programlisting>float z_rot = (gmtl::makeRot&#60;gmtl::EulerAngleXYZf&#62;(mat))[2];</programlisting>

          <para>The value return is in radians. We can also get the X-axis
          rotation.</para>

          <programlisting>float x_rot = (gmtl::makeRot&#60;gmtl::EulerAngleXYZf&#62;(mat))[0];</programlisting>

          <para>Getting translations is even simpler because translations are
          collected into a single vector easily.</para>

          <programlisting>gmtl::Vec3f trans;
gmtl::setTrans(trans, mat);</programlisting>

          <para>After this, the translation in <varname>mat</varname> is
          stored in trans. The same can be done with a <classname>gmtl::Vec4f</classname>
          instead of the <classname>gmtl::Vec3f</classname>.</para>
        </section>

        <section>
          <title>Converting to an OpenGL Performer Matrix</title>

          <indexterm>
            <primary>gmtl::Matrix44f</primary>

            <secondary>converting to pfMatrix</secondary>
          </indexterm>

          <indexterm>
            <primary>pfMatrix</primary>

            <secondary>converting from gmtl::Matrix44f</secondary>

            <seealso>gmtl::Matrix44f</seealso>
          </indexterm>

          <para>SGI&#39;s OpenGL Performer likes to work with its own
          <classname>pfMatrix</classname> class, and to facilitate the use of
          it with <classname>gmtl::Matrix44f</classname>, two conversion
          functions are provided for making conversions. The first works as
          follows:</para>

          <programlisting>gmtl::Matrix44f vj_mat;
pfMatrix pf_mat;

// Perform operations on vj_mat...

pf_mat = vrj::GetPfMatrix(vj_mat);</programlisting>

          <para>where <varname>vj_mat</varname> is passed by reference for
          efficiency. (<varname>pf_mat</varname> gets a copy of a
          <classname>pfMatrix</classname> which is a slow operation.) To
          convert a <classname>pfMatrix</classname> to a
          <classname>gmtl::Matrix44f</classname>, do the following:</para>

          <programlisting>pfMatrix pf_mat;
gmtl::Matrix44f vj_mat;

// Perform operations on pf_mat...

vj_mat = vrj::GetVjMatrix(pf_mat);</programlisting>

          <para>Here again, <varname>pf_mat</varname> is passed by reference
          for efficiency, and <varname>vj_mat</varname> gets a copy of a
          <classname>gmtl::Matrix44f</classname>. Both of these functions are
          found in the header <filename>vrj/Draw/Pf/PfUtil.h</filename>.</para>
        </section>

        <section>
          <title>The Gory Details</title>

          <indexterm>
            <primary>gmtl::Matrix44f</primary>

            <secondary>details</secondary>
          </indexterm>

          <para>Now it is time for the really nasty part. Reading this could
          cause difficulty in understanding the overwhelming amount of
          information just presented. Do not read any further unless you
          absolutely have to or you just like to confuse yourself.</para>

          <para>C, C++, and mathematics use matrices in row-major order.
          Access indices are shown in <xref linkend="table.row-major.access" /></para>

          <table id="table.row-major.access">
            <title>Row-major access indices</title>

            <tgroup align="left" cols="5" colsep="1" rowsep="1">
              <tbody>
                <row>
                  <entry align="center">(0,0)</entry>

                  <entry align="center">(0,1)</entry>

                  <entry align="center">(0,2)</entry>

                  <entry align="center">(0,3)</entry>

                  <entry>&#60;--- Array</entry>
                </row>

                <row>
                  <entry align="center">(1,0)</entry>

                  <entry align="center">(1,1)</entry>

                  <entry align="center">(1,2)</entry>

                  <entry align="center">(1,3)</entry>

                  <entry>&#60;--- Array</entry>
                </row>

                <row>
                  <entry align="center">(2,0)</entry>

                  <entry align="center">(2,1)</entry>

                  <entry align="center">(2,2)</entry>

                  <entry align="center">(2,3)</entry>

                  <entry>&#60;--- Array</entry>
                </row>

                <row>
                  <entry align="center">(3,0)</entry>

                  <entry align="center">(3,1)</entry>

                  <entry align="center">(3,2)</entry>

                  <entry align="center">(3,3)</entry>

                  <entry>&#60;--- Array</entry>
                </row>
              </tbody>
            </tgroup>
          </table>

          <para>OpenGL ordering specifies that the matrix has to be
          column-major in memory. Thus, to provide programmers with a way to
          pass a transformation matrix to OpenGL in one step (via
          <function>glMultMatrixf()</function>), the <classname>gmtl::Matrix44f</classname>
          class maintains its internal matrix in column-major order. Note that
          in the following table, the given indices are what the cells have to
          be called in C/C++ notation because we are putting them back to
          back. This is illustrated in <xref
          linkend="table.column-major.access" />.</para>

          <table id="table.column-major.access">
            <title>Column-major access indices</title>

            <tgroup align="left" cols="4" colsep="1" rowsep="1">
              <tbody>
                <row>
                  <entry align="center">(0,0)</entry>

                  <entry align="center">(1,0)</entry>

                  <entry align="center">(2,0)</entry>

                  <entry align="center">(3,0)</entry>
                </row>

                <row>
                  <entry align="center">(0,1)</entry>

                  <entry align="center">(1,1)</entry>

                  <entry align="center">(2,1)</entry>

                  <entry align="center">(3,1)</entry>
                </row>

                <row>
                  <entry align="center">(0,2)</entry>

                  <entry align="center">(1,2)</entry>

                  <entry align="center">(2,2)</entry>

                  <entry align="center">(3,2)</entry>
                </row>

                <row>
                  <entry align="center">(0,3)</entry>

                  <entry align="center">(1,3)</entry>

                  <entry align="center">(2,3)</entry>

                  <entry align="center">(3,3)</entry>
                </row>

                <row>
                  <entry align="center">^</entry>

                  <entry align="center">^</entry>

                  <entry align="center">^</entry>

                  <entry align="center">^</entry>
                </row>

                <row>
                  <entry align="center">Array</entry>

                  <entry align="center">Array</entry>

                  <entry align="center">Array</entry>

                  <entry align="center">Array</entry>
                </row>
              </tbody>
            </tgroup>
          </table>

          <para>As mentioned, all of this is done so that a given
          <classname>gmtl::Matrix44f</classname> that acts as a full
          transformation matrix can be passed to OpenGL directly (more or
          less)<indexterm><primary>vrj::Matrix</primary><secondary>using with
          OpenGL</secondary></indexterm>. For example, with a given
          <classname>gmtl::Matrix44f</classname> object <varname>mat</varname>
          upon which painstaking transformations have been performed, the
          following can be done:</para>

          <programlisting>glMultMatrixf(mat.getData());</programlisting>

          <para>That could not be simpler. All the transformation efforts have
          culminated into one statement.</para>

          <para>For further information, the best possible source of
          information, especially for this class, is the header file. Read it;
          understand it; love it.</para>
        </section>
      </section>

      <section id="section.gadget.DeviceInterface">
        <title>The <classname>gadget::DeviceInterface&#60;T&#62;</classname>
        Helper Class</title>

        <indexterm>
          <primary>gadget::DeviceInterface&#60;T&#62;</primary>
        </indexterm>

        <para>The concept of device interfaces in VR Juggler applications is
        something that often causes confusion for new users. Two
        object-oriented design patterns are combined by
        <classname>gadget::DeviceInterface&#60;T&#62;</classname><indexterm><primary>classes</primary><secondary>gadget::DeviceInterface&#60;T&#62;</secondary><seealso>gadget::DeviceInterface&#60;T&#62;</seealso></indexterm>:
        smart pointers and proxies. Within this section, we aim to explain
        Gadgeteer device interfaces clearly and simply. We begin with a
        high-level description and then move right into using the class.</para>

        <section>
          <title>High-Level Description</title>

          <indexterm>
            <primary>gadget::DeviceInterface&#60;T&#62;</primary>

            <secondary>description of</secondary>
          </indexterm>

          <para>Physical devices are never accessed directly by VR Juggler
          applications<indexterm><primary>applications</primary><secondary>device
          access</secondary></indexterm>. Instead, the applications are
          granted access to the device through a <glossterm
          linkend="gloss.proxy">proxy</glossterm><indexterm><primary>proxy</primary><secondary>application-level
          access</secondary></indexterm>. A proxy is nothing more than an
          intermediary who forwards information between two parties<indexterm><primary>proxy</primary><secondary>definition
          of</secondary></indexterm>. In this case, the two parties are a VR
          Juggler application and an input device. The application makes
          requests on the input device through the proxy.</para>

          <para>The (template) class <classname>gadget::DeviceInterface&#60;T&#62;</classname>
          is designed to be a wrapper class around the proxies. Applications
          could use the proxy classes directly, but <classname>gadget::DeviceInterface&#60;T&#62;</classname>
          and its type-specific instances (<classname>gadget::PositionInterface</classname>,
          <classname>gadget::DigitalInterface</classname>, etc.) simplify use
          of the proxy object they contain. Thus, typical VR Juggler
          application objects will have one or more device interface member
          variables.</para>

          <note>
            <para>The class <classname>gadget::DeviceInterface&#60;T&#62;</classname>
            is a templated class based on the proxy type it wraps. Example
            instantiations of <classname>gadget::DeviceInterface&#60;T&#62;</classname>
            are <classname>gadget::DeviceInterface&#60;gadget::PositionProxy&#62;</classname>
            and <classname>gadget::DeviceInterface&#60;gadget::KeyboardProxy&#62;</classname>.
            Typedefs such as <classname>gadget::PositionInterface</classname>
            (another name for <classname>gadget::DeviceInterface&#60;gadget::PositionProxy&#62;</classname>)
            make the code more readable.</para>
          </note>

          <para>In the application object, a device interface member variable
          is used as a <glossterm linkend="gloss.smart.pointer">smart pointer</glossterm><indexterm><primary>smart
          pointer</primary></indexterm> to the proxy. In C++, a smart pointer
          is not usually an actual object pointer. Instead, the class acting
          as a smart pointer overloads the dereference operator -&#62; so that
          a special action can be taken when the <quote>pointer</quote> is
          dereferenced. The dereference operator is just another operator like
          the addition and subtraction operators, and overloading the
          deference operator allows some <quote>magic</quote> to occur behind
          the scenes. On the surface, the code looks exactly the same as a
          normal pointer dereference, and in most cases, people reading and
          writing the code can think of the smart pointer as a standard
          pointer. It may also be convenient to think of a smart pointer as a
          handle.</para>

          <para>With that background, we can move on to explain how
          <classname>gadget::DeviceInterface&#60;T&#62;</classname> uses these
          concepts. First, know that <classname>gadget::DeviceInterface&#60;T&#62;</classname>
          is a base class for all other device interface classes such as
          digital interfaces (wand buttons), position interfaces (wands, a
          tracked user&#39;s head), etc. In user code, there will be instances
          of objects such as <classname>gadget::DigitalInterface</classname><indexterm><primary>classes</primary><secondary>gadget::DigitalInterface</secondary></indexterm>,
          <classname>gadget::PositionInterface</classname><indexterm><primary>classes</primary><secondary>gadget::PositionInterface</secondary></indexterm>,
          <classname>gadget::KeyboardInterface</classname><indexterm><primary>classes</primary><secondary>gadget::KeyboardInterface</secondary></indexterm>,
          and the like. Once they are properly initialized, device interface
          objects (whatever their types may be) will act as smart pointers to
          the actual Gadgeteer device proxy objects they wrap.</para>

          <para>All the instances of <classname>gadget::DeviceInterface&#60;T&#62;</classname>
          encapsulate a pointer to a Gadgeteer device proxy object. (Remember
          that these proxy objects act as an intermediary between the
          application and an input device.) The subclasses also overload the
          dereference operator -&#62; which allows them to act as smart
          pointers. The dereference operator on a device interface object
          gives access to the object&#39;s hidden proxy pointer. With that
          access, the methods of the encapsulated proxy object can be invoked,
          usually to read data. The end result is that user applications get
          access to the proxy objects they need but through a simpler
          interface than using the proxies directly<indexterm><primary>device
          proxies</primary><secondary>access through device interfaces</secondary><seealso>gadget::DeviceInterface&#60;T&#62;</seealso></indexterm>.</para>

          <para>At this point, it is perfectly reasonable to wonder why
          Gadgeteer uses a concept that requires all sorts of documentation
          and explanation. The extra effort is worth it because it allows
          Gadgeteer to hide the actual type of the device being used. There is
          no need to know that some specific VR system uses a wireless mouse
          connected to a PC reading bytes from a PS/2 port that represent
          button presses. All that matters is knowing which buttons are
          pressed at a given instant. The class <classname>gadget::DigialInterface</classname>
          gives exactly that information, and it quietly hides the messiness
          of dealing with that crazy mouse, its ugly driver, and its overly
          complex protocol.</para>
        </section>

        <section>
          <title>Using <classname>gadget::DeviceInterface&#60;T&#62;</classname></title>

          <indexterm>
            <primary>classes</primary>

            <secondary>gadget::DeviceInterface&#60;T&#62;</secondary>
          </indexterm>

          <para>As noted above, VR Juggler applications do not usually use
          <classname>gadget::DeviceInterface&#60;T&#62;</classname> directly.
          Instead, the typedefs for specific instantiations of
          <classname>gadget::DeviceInterface&#60;T&#62;</classname> mentioned
          above will be used. Within this section, we will refer to
          instantiations of <classname>gadget::DeviceInterface&#60;T&#62;</classname>
          as <quote>device interfaces.</quote> The high-level description has
          already made use of this convention.</para>

          <para>Before using a device interface, some objects must be
          declared. Programmers must choose the type that is appropriate for
          the type of devices relevant to a given application. All device
          interface objects must be initialized in the application
          object&#39;s <methodname>init()</methodname> method<indexterm><primary>device
          interfaces</primary><secondary>initialization of</secondary></indexterm>.
          Each device interface type has a method called
          <methodname>init()</methodname>. This method takes a single string
          argument naming the proxy to which the interface will connect.
          Example names are <quote>VJHead</quote>, <quote>VJWand</quote>,
          <quote>VJButton0</quote>, and <quote>VJAccelerate</quote><indexterm><primary>device
          aliases</primary><secondary>examples of</secondary></indexterm>.
          These are all symbolic names specified in VR Juggler configuration
          files. This makes them easier to remember, and it also contributes
          to hiding the details about the physical device. With this system,
          no one needs to care how transformation information from the
          user&#39;s head is generated. Gadgeteer cares, but there is no need
          for it to tell anyone else. All developers care about is the head
          transformation matrix. An example of initializing a
          <classname>gadget::PositionInterface</classname> that connects with
          the user head proxy is:</para>

          <programlisting>gadget::PositionInterface head;

head.init(&#34;VJHead&#34;);</programlisting>

          <para>Remember that this is to be done in an application
          object&#39;s <methodname>init()</methodname> method. The actual
          object used would be a member variable of the application class.
          Note that here, the normal syntax for calling the method of a C++
          object is used rather than using the dereference operator. Until it
          is initialized, the device interface object cannot act as a smart
          pointer.</para>

          <para>Once device interface objects are all initialized and ready to
          use, it is time to start using them as smart pointers<indexterm><primary>device
          interfaces</primary><secondary>as smart pointers</secondary><seealso>smart
          pointer</seealso></indexterm>. This is best part! VR Juggler and
          Gadgeteer are already working hard in the background to update
          device proxies, and the application is free to access them. (It is
          usually best to reference them in the <methodname>preFrame()</methodname>
          method, but this may not necessarily be true for all proxies.)
          Continuing with our example of a <classname>gadget::PositionInterface</classname>
          to the user head proxy, the following code shows how to read the
          transformation matrix for the user&#39;s head:</para>

          <programlisting>gmtl::Matrix44f head_mat;

head_mat = head-&#62;getData();</programlisting>

          <para>But wait, that was easy! Believe it or not, the code really is
          that simple. Simply use the overloaded dereference operator to get
          access to the position proxy object hidden in
          <classname>gadget::PositionInterface</classname> to read data from
          the proxy. Of course, we have not explained the
          <methodname>getData()</methodname> method at all yet. That comes
          from the position proxy class, and that is documented elsewhere.</para>
        </section>

        <section>
          <title>The Gory Details</title>

          <indexterm>
            <primary>gadget::DeviceInterface&#60;T&#62;</primary>

            <secondary>details</secondary>
          </indexterm>

          <para>What is truly amazing about Gadgeteer device interfaces is,
          despite their seeming complexity, there is really nothing to them.
          Trying to trace through the source code is a little tricky, but
          conceptually, it is all about pointers. Keep in mind that all this
          documentation was written using nothing more than the Gadgeteer
          header files as a reference.</para>

          <para>As mentioned, the class <classname>gadget::DeviceInterface&#60;T&#62;</classname>
          is a base class for all the specific types of device interfaces such
          as positional interfaces, digital interfaces, and analog interfaces.
          This class maintains the name of the proxy and the proxy index, it
          provides the all-important <methodname>init()</methodname> method,
          and it overloads the dereference operator. C++ templates then handle
          the different type instantiations for the different Gadgeteer proxy
          types.</para>

          <para>Instantiations of <classname>gadget::DeviceInterface&#60;T&#62;</classname>
          are used to provide the wrapper to a specific type of proxy<indexterm><primary>gadget::DeviceInterface</primary><secondary>instantiations
          of</secondary></indexterm>. They each contain a pointer to a proxy
          object of the same conceptual type (positional, digital, and so on).
          Regardless of the specific instantiations of <classname>gadget::DeviceInterface&#60;T&#62;</classname>,
          they all return a pointer to their contained proxy so that user code
          can get the current data from the proxy.</para>

          <para>The beauty of it all is that the proxy object being pointed to
          by the device interface can be changed without affecting the
          execution of the user application. In other words, the proxies can
          be changed at run time to point to different <emphasis>physical</emphasis>
          devices. All the while, the user code is still using the smart
          pointer interface and getting data of some sort. This flexibility is
          one of the most important features of Gadgeteer, and it is important
          to understand.</para>
        </section>
      </section>

      <section id="section.gadget.Proxy">
        <title>The <classname>gadget::Proxy</classname> Helper Class</title>

        <indexterm>
          <primary>gadget::Proxy</primary>
        </indexterm>

        <para>This whole proxy scheme can be confusing. We admit that it makes
        the learning curve for VR Juggler a little steeper, but once you get
        it, you will know it all. An alternate title for this section is
        <quote>Horton Hears a Proxy.</quote> In this case, Horton is VR
        Juggler (it is rather elephant-like at times), and the complexity of
        dealing with these ethereal, ubiquitous proxies causes VR Juggler to
        take a lot of guff. This section presents the <classname>gadget::Proxy</classname><indexterm><primary>classes</primary><secondary>gadget::Proxy</secondary><seealso>gadget::Proxy</seealso></indexterm>
        class, the base class for the input proxies, making it the one that is
        used the most. It should be noted, however, that the concept is
        spreading to other parts of VR Juggler because it is so useful. While
        this is only the introduction, we will give you the moral of the story
        now: proxies are important concepts, and you should not step on them.</para>

        <section>
          <title>High-Level Description</title>

          <indexterm>
            <primary>gadget::Proxy</primary>

            <secondary>description of</secondary>
          </indexterm>

          <para>The class <classname>gadget::Proxy</classname> is the base
          class for all the proxies in the Gadgeteer Input Manager. A better
          name would be <classname>gadget::InputProxy</classname>, and it may
          help to think of it with that name. As a programmer of VR Juggler
          applications, knowledge of such proxies does not have to be terribly
          in-depth. The fact is, most VR Juggler programmers will probably
          never need to know more about a specific device proxy&#39;s
          interface than the return type of its <methodname>getData()</methodname>
          method. Most of the apparent complexity in the specific device proxy
          classes is only important to Gadgeteer&#39;s internal maintenance of
          the active proxies.</para>

          <para>That said, this section is relatively short. As a programmer,
          the important thing to know is that a proxy is a pointer to a
          physical device<indexterm><primary>gadget::Proxy</primary><secondary>as
          pointer to physical device</secondary></indexterm>. Application
          programmers use the higher level device interface as the mechanism
          to read data in some form from the device. The device interface
          encapsulates some type of proxy that in turn points to an input
          device. That device can be a wand, a keyboard, a light sensor, or a
          home-brewed device that reads some input and returns it to Gadgeteer
          in a meaningful way. That is a lot of indirection, but it makes the
          handling of physical devices by Gadgeteer incredibly powerful. Most
          importantly, it prevents VR Juggler applications from being tied to
          specific hardware devices.</para>
        </section>

        <section>
          <title>Using <classname>gadget::Proxy</classname></title>

          <indexterm>
            <primary>classes</primary>

            <secondary>gadget::Proxy</secondary>
          </indexterm>

          <para>To be blunt, application programmers do not use
          <classname>gadget::Proxy</classname>. Instead, access to a subclass
          of <classname>gadget::Proxy</classname> is given through a device
          interface acting as a smart pointer. The <methodname>getData()</methodname>
          method of that subclass is used<indexterm><primary>gadget::Proxy</primary><secondary>getData()
          method</secondary></indexterm>. That method is the window into the
          soul of an input device. The device interface allows calling
          <methodname>getData()</methodname> for the specific proxy object it
          encapsulates, and the current state of the device pointed to by the
          proxy is returned.</para>

          <para>Therefore, what must be known is the return type of the
          specific proxy to which access is granted through the device
          interface. The naming conventions for the proxies and their
          interfaces makes it relatively simple to determine which proxy
          object is being encapsulated by which device interface. For example,
          a <classname>gadget::DigitalInterface</classname><indexterm><primary>classes</primary><secondary>gadget::DigitalInterface</secondary></indexterm>
          holds a <classname>gadget::DigitalProxy</classname><indexterm><primary>classes</primary><secondary>gadget::DigitalProxy</secondary></indexterm>
          pointer. In that case, refer to the documentation for the
          <classname>gadget::DigitalProxy</classname> class and find the
          return type of <methodname>getData()</methodname> (<type>int</type>
          in this case). The proxy header files have the information, too.
          These are located in <filename>$GADGET_BASE_DIR/include/gadget/Type</filename>.
          Just search for the <methodname>getData()</methodname> methods
          therein.</para>
        </section>

        <section>
          <title>The Gory Details</title>

          <indexterm>
            <primary>gadget::Proxy</primary>

            <secondary>details</secondary>
          </indexterm>

          <para>The gory details of <classname>gadget::Proxy</classname> and
          its subclasses are not really relevant to this particular section.
          The subclasses look complicated, and they can be. It is important to
          note, however, that the complication is part of the interface used
          <emphasis>internally</emphasis> by Gadgeteer rather than the
          interface used by the application programmer. Because of that and
          because each device proxy class is different, those details will not
          be addressed here. It is sufficient to deal with
          <methodname>getData()</methodname> alone in applications. Leave the
          ugliness up to VR Juggler and Gadgeteer; they can handle it.</para>
        </section>
      </section>
    </chapter>
  </part>

  <part id="app.programming.part">
    <title>Application Programming</title>

    <chapter id="chapter.writing.apps">
      <title>Writing Applications</title>

      <indexterm>
        <primary>applications</primary>

        <secondary>writing</secondary>
      </indexterm>

      <para>This chapter alone comprises the bulk of information about
      application development. Each section outlines one area of interest for
      application developers. For example, there are sections that show how to
      get input from the system and others that show how to write applications
      for each of the currently supported graphics APIs. Please note that when
      writing an application, there will be overlap between these sections.
      For example, an application that needs input, sound, and OpenGL graphics
      will be based on concepts from each of the relevant sections.</para>

      <section>
        <title>Application Review</title>

        <para>Before getting into too much detail, we present this section as
        a review from earlier chapters. There is no new information here; it
        is simply a quick overview of the basics of VR Juggler applications.</para>

        <section>
          <title>Basic Application Information</title>

          <para>As described in previous chapters (see <xref
          linkend="chapter.getting.started" />, for example), all VR Juggler
          applications derive from a base application object class (<classname>vrj::App</classname><indexterm><primary>classes</primary><secondary>vrj::App</secondary></indexterm>).
          This class defines the basic interface that VR Juggler expects from
          all application objects. This means that when constructing an
          application, the user-defined application object must inherit from
          <classname>vrj::App</classname> or from a Draw Manager-specific
          application class that has <classname>vrj::App</classname> as a
          superclass. For example:</para>

          <programlisting>class userApp : public vrj::App
{
public:
   init();
   preFrame();
   postFrame();
}</programlisting>

          <para>This defines a new application class (<classname>userApp</classname>),
          instances of which can be used anywhere that VR Juggler expects an
          application object.</para>
        </section>

        <section>
          <title>Draw Manager-Specific Application Classes</title>

          <para>A user application does not have to (and in most cases does
          not) derive from <classname>vrj::App</classname><indexterm><primary>classes</primary><secondary>vrj::App</secondary></indexterm>
          directly. In almost all cases, an application class is derived from
          a Draw Manager-specific application class. For example:</para>

          <programlisting>class userGlApp : public vrj::GlApp
{
public:
   init();
   preFrame();
   postFrame();
   
   draw();
}</programlisting>

          <para>This is an example of an OpenGL application. The application
          class (<classname>userGlApp</classname>) has derived directly from
          the OpenGL Draw Manager-specific <classname>vrj::GlApp</classname><indexterm><primary>classes</primary><secondary>vrj::GlApp</secondary></indexterm>
          application base class. This class provides extra definitions in the
          interface that are custom for OpenGL applications.</para>
        </section>
      </section>

      <section id="section.get.input">
        <title>Getting Input</title>

        <indexterm zone="section.get.input">
          <primary>application programming</primary>

          <secondary>getting input</secondary>
        </indexterm>

        <para>There are many types of input devices that VR Juggler
        applications can use including positional, digital, and analog<indexterm><primary>input
        device types</primary></indexterm>. All applications share the same
        processes and concepts for acquiring input from devices. The main
        thing to remember about getting input in applications is that all VR
        Juggler applications receive input through device handles managed by
        <classname>gadget::DeviceInterface&#60;T&#62;</classname><indexterm><primary>classes</primary><secondary>gadget::DeviceInterface&#60;T&#62;</secondary></indexterm>
        instantiations. There are <classname>gadget::DeviceInterface&#60;T&#62;</classname>
        instantiations for each type of input data that Gadgeteer can handle.
        There is one for positional input, one for analog, and so on. They all
        have very similar interfaces and behave exactly the same. (Refer to
        <xref linkend="section.gadget.DeviceInterface" /> and <xref
        linkend="section.gadget.Proxy" /> for more information.)</para>

        <section>
          <title>How to Get Input</title>

          <para>While there has already been a brief presentation about
          getting input in an application, we need something more. Since all
          device interfaces look the same, we will focus on an example of
          getting positional input. All other types are very similar. We begin
          with a simple application object skeleton.</para>

          <programlisting>class myApp : public vrj::App
{
public:
   init();
   preFrame();
private:
   gadget::PositionInterface mWand;
}</programlisting>

          <para>Note the declaration of the variable <varname>mWand</varname>
          of type <classname>gadget::PositionInterface</classname>. This is
          the first addition to an application. Device interfaces are usually
          member variables of the user application class, as in this example.</para>

          <programlisting>myApp::init()
{
   mWand.init(&#34;NameOfPosDevInConfiguration&#34;);
}</programlisting>

          <para>The device interface has to be told about the device from
          which it will get data. This is done by calling the device interface
          object&#39;s <methodname>init()</methodname> method with the
          symbolic string name of the device. This device name comes from the
          active configuration. We are now ready to read from the device.</para>

          <programlisting>...
gmtl::Matrix44f wand_pos(mWand-&#62;getData());
...</programlisting>

          <para>The above code shows an example of using the positional device
          interface in an application. It shows some sample code where the
          application copies the positional information from a device
          interface. When it is dereferenced, the device interface figures out
          what device it points to and returns the data from that device.
          Again, refer to <xref linkend="section.gadget.DeviceInterface" />
          for more information about using <classname>gadget::DeviceInterface&#60;T&#62;</classname>.</para>
        </section>

        <section>
          <title>Where to Get Input</title>

          <indexterm>
            <primary>application programming</primary>

            <secondary>where to get device input</secondary>
          </indexterm>

          <para>In the previous section, we showed how to get input from
          devices, but we never said where to put the code. The location,
          surprisingly, is application dependent. There are some very good
          guidelines regarding where applications should process input. Before
          explaining them, however, we should review the VR Juggler kernel
          control loop, presented again in <xref
          linkend="figure.kernel.loop.sequence2" />.</para>

          <figure id="figure.kernel.loop.sequence2">
            <title>VR Juggler kernel control loop</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center"
                fileref="figures/Kernel_Loop_Call_Sequence.png" format="PNG"
                scalefit="1" />
              </imageobject>
            </mediaobject>
          </figure>

          <para>This diagram looks complicated, but the key here is the
          <methodname>updateAllData()</methodname> call near the bottom of the
          diagram. This is where the Gadgeteer Input Manager updates all the
          cached device data that will be used in drawing the next frame. This
          updated copy is used by all user references to device data until the
          next update and the end of the next frame of execution.</para>

          <para>This means two things:</para>

          <orderedlist>
            <listitem>
              <para>The device data is most fresh in <methodname>vrj::App::preFrame()</methodname>,
              and</para>
            </listitem>

            <listitem>
              <para>Any time spent in <methodname>vrj::App::preFrame()</methodname>
              increases the overall system latency.</para>
            </listitem>
          </orderedlist>

          <para>The first point is important because it means that the copy of
          the device data with the lowest latency is always available in the
          <methodname>preFrame()</methodname> member function. The second
          point is equally important because it says why user applications
          should not waste any time in <methodname>preFrame()</methodname>.
          Any time spent in <methodname>preFrame()</methodname> increases
          system latency and in turn decreases the perceived quality of the
          environment. Hence, it is crucial to avoid placing computations in
          <methodname>preFrame()</methodname>.</para>
        </section>

        <section>
          <title>Tutorial: Getting Input</title>

          <indexterm>
            <primary>tutorial</primary>

            <secondary>getting input</secondary>
          </indexterm>

          <table>
            <title>Tutorial Overview</title>

            <tgroup cols="2">
              <tbody>
                <row>
                  <entry>Description</entry>

                  <entry>Simple application that prints the location of the
                  head and the wand</entry>
                </row>

                <row>
                  <entry>Objective</entry>

                  <entry>Understand how to get positional and digital input in
                  a VR Juggler application</entry>
                </row>

                <row>
                  <entry>Member functions</entry>

                  <entry><itemizedlist><listitem><para><methodname>vrj::App::init()</methodname></para></listitem><listitem><para><methodname>vrj::App::preFrame()</methodname></para></listitem></itemizedlist></entry>
                </row>

                <row>
                  <entry>Directory</entry>

                  <entry><filename>$VJ_BASE_DIR/share/samples/OGL/simple/simpleInput</filename></entry>
                </row>

                <row>
                  <entry>Files</entry>

                  <entry><itemizedlist><listitem><para><filename>simpleInput.h</filename></para></listitem><listitem><para><filename>simpleInput.cpp</filename></para></listitem></itemizedlist></entry>
                </row>
              </tbody>
            </tgroup>
          </table>

          <section>
            <title>Class Declaration and Data Members</title>

            <para>In the following class declaration, note the data members (<varname>mWand</varname>,
            <varname>mHead</varname>, etc.). This application has four device
            interface member variables: two for positional input (<varname>mHead</varname>
            and <varname>mWand</varname>) and two for digital input (<varname>mButton0</varname>
            and <varname>mButton1</varname>). Each of these member variables
            will act as a handle to a <quote>real</quote> device from which we
            will read data in <methodname>preFrame()</methodname>.</para>

            <programlisting linenumbering="numbered">class simpleInput : public vrj::GlApp
{
public:
   virtual void init();
   virtual void preFrame();

public:
   gadget::PositionInterface mWand;     // Positional interface for Wand position
   gadget::PositionInterface mHead;     // Positional interface for Head position
   gadget::DigitalInterface  mButton0;  // Digital interface for button 0
   gadget::DigitalInterface  mButton1;  // Digital interface for button 1
};</programlisting>
          </section>

          <section>
            <title>Initializing the Device Interfaces:
            <methodname>vrj::App::init()</methodname></title>

            <para>The devices are initialized in the <methodname>init()</methodname>
            member function of the application. For each device interface
            member variable, the application calls the variable&#39;s own
            <methodname>init()</methodname> method. The argument passed is the
            symbolic name of the configured device from which data will be
            read. From this point on in the application, the member variables
            are <emphasis>handles</emphasis> to the named device.</para>

            <programlisting linenumbering="numbered">virtual void init()
{
   // Initialize devices
   mWand.init(&#34;VJWand&#34;);
   mHead.init(&#34;VJHead&#34;);
   mButton0.init(&#34;VJButton0&#34;);
   mButton1.init(&#34;VJButton1&#34;);
}</programlisting>
          </section>

          <section>
            <title>Examining the Device Data: <methodname>vrj::App::preFrame()</methodname></title>

            <para>The following member function implementation gives an
            example of how to examine the input data using the device
            interface member variables.</para>

            <programlistingco>
              <areaspec>
                <areaset coords="" id="button.reads">
                  <area coords="3" id="mButton0.read" />

                  <area coords="7" id="mButton1.read" />
                </areaset>

                <area coords="12" id="button.print" />

                <area coords="19" id="position.get" />
              </areaspec>

              <programlisting linenumbering="numbered">virtual void preFrame()
{
   if ( mButton0-&#62;getData() )
   {
      std::cout &#60;&#60; &#34;Button 0 pressed&#34; &#60;&#60; std::endl;
   }
   if( mButton1-&#62;getData() )
   {
      std::cout &#60;&#60; &#34;Button 1 pressed&#34; &#60;&#60; std::endl;
   }
 
   std::cout &#60;&#60; &#34;Wand Buttons:&#34;
             &#60;&#60; &#34; 0:&#34; &#60;&#60; mButton0-&#62;getData()
             &#60;&#60; &#34; 1:&#34; &#60;&#60; mButton1-&#62;getData()
             &#60;&#60; std::endl;
                 
   // -- Get Wand matrix --- //
   gmtl::Matrix44f wand_matrix(mWand-&#62;getData());
   std::cout &#60;&#60; &#34;Wand pos: \n&#34; &#60;&#60; wand_matrix &#60;&#60; std::endl;
}</programlisting>

              <calloutlist>
                <callout arearefs="button.reads">
                  <para>These statements check the status of the two digital
                  buttons and write out a line if the button has been pressed.</para>
                </callout>

                <callout arearefs="button.print">
                  <para>This writes out the current state of both buttons.</para>
                </callout>

                <callout arearefs="position.get">
                  <para>The final section prints out the current location of
                  the wand in the VR environment.</para>
                </callout>
              </calloutlist>
            </programlistingco>
          </section>
        </section>
      </section>

      <section id="section.opengl.apps">
        <title>OpenGL Applications</title>

        <indexterm>
          <primary>application programming</primary>

          <secondary>OpenGL</secondary>
        </indexterm>

        <para>We can now describe how to write OpenGL applications in VR
        Juggler. An OpenGL-based VR Juggler application must be derived from
        <classname>vrj::GlApp</classname><indexterm><primary>classes</primary><secondary>vrj::GlApp</secondary></indexterm>.
        This in turn is derived from <classname>vrj::App</classname><indexterm><primary>classes</primary><secondary>vrj::App</secondary></indexterm>.
        As was discussed in the application object section,
        <classname>vrj::App</classname> defines the base interface that VR
        Juggler expects of all applications. The <classname>vrj::GlApp</classname>
        class extends this interface by adding members that the VR Juggler
        OpenGL Draw Manager needs to render an OpenGL application correctly.</para>

        <figure id="figure.vrj.GlApp2">
          <title><classname>vrj::GlApp</classname> application class</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
              fileref="figures/userOglApp_hierarchy.png" format="PNG" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>In <xref linkend="figure.vrj.GlApp2" />, we see some of the
        methods added by the <classname>vrj::GlApp</classname> interface:
        <methodname>draw()</methodname>, <methodname>contextInit()</methodname>,
        and <methodname>contextPreDraw()</methodname><indexterm><primary>vrj::GlApp</primary><secondary>extensions
        to vrj::App</secondary></indexterm>. These methods deal with OpenGL
        drawing and managing <glossterm linkend="gloss.csdata">context-specific
        data</glossterm> (do not worry what context data is right now—we cover
        that in detail later). There are a few other member functions in the
        interface, but these cover 99% of the issues that most developers
        face. In the following sections, we will describe how to add OpenGL
        drawing to an application and how to handle context-specific data.
        There is a tutorial for each topic.</para>

        <section id="section.clear.buffers">
          <title>Clearing the Color and Depth Buffers</title>

          <indexterm>
            <primary>application programming</primary>

            <secondary>OpenGL</secondary>

            <tertiary>clearing color and depth buffers</tertiary>
          </indexterm>

          <indexterm>
            <primary>vrj::GlApp</primary>

            <secondary>bufferPreDraw() method</secondary>
          </indexterm>

          <para>Before describing how to render using OpenGL with VR Juggler,
          we must cover the more basic topic of clearing the color and depth
          buffers. We describe this part before explaining how to render
          graphics because these steps will be common to all VR Juggler
          applications based on OpenGL.</para>

          <para>In VR Juggler 1.1 and beyond, there is support for drawing
          multiple OpenGL viewports in a single VR Juggler display window.
          This feature is useful for tiled displays where each viewport
          renders a specific part of the scene. In order for an OpenGL-based
          application to work with multiple viewports, the color and depth
          buffers need to be cleared at the correct times.</para>

          <para>In a user application, the method <methodname>vrj::GlApp::bufferPreDraw()</methodname>
          is overridden so that it clears the color buffer. For example, the
          following code clears the color buffer using black:</para>

          <programlisting>void userApp::bufferPreDraw()
{
   glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
   glClear(GL_COLOR_BUFFER_BIT);
}</programlisting>

          <para>Now we need to clear the depth buffer. This must be done
          separately from the color buffer to ensure proper stereo rendering.
          The depth buffer must be cleared in the application object&#39;s
          <methodname>draw()</methodname> method, usually as the first step:</para>

          <programlisting>void userApp::draw()
{
   glClear(GL_DEPTH_BUFFER_BIT);

   // Rendering the scene ...
}</programlisting>
        </section>

        <section>
          <title>OpenGL Drawing: <methodname>vrj::GlApp::draw()</methodname></title>

          <indexterm>
            <primary>application programming</primary>

            <secondary>OpenGL</secondary>

            <tertiary>drawing</tertiary>
          </indexterm>

          <indexterm>
            <primary>vrj::GlApp</primary>

            <secondary>draw() method</secondary>
          </indexterm>

          <para>The most important (and visible) component of most OpenGL
          applications is the OpenGL drawing. The <classname>vrj::GlApp</classname><indexterm><primary>classes</primary><secondary>vrj::GlApp</secondary></indexterm>
          class interface defines a <methodname>draw()</methodname> member
          function to hold the code for drawing a virtual environment. Hence,
          any OpenGL drawing calls should be placed in the
          <methodname>vrj::GlApp::draw()</methodname> function of the user
          application object.</para>

          <para>Adding drawing code to an OpenGL-based VR Juggler application
          is straightforward. The <methodname>draw()</methodname> method is
          called whenever the OpenGL Draw Manager needs to render a view of
          the virtual world created by the user&#39;s application. It is
          called for each defined OpenGL context, and it may be called
          multiple times per frame in the case of multi-surface setups and/or
          stereo configurations. Applications should <emphasis>never</emphasis>
          rely upon the number of times this member function is called per
          frame.</para>

          <para>When the method is called, the OpenGL model view and
          projection matrices have been configured correctly to draw the
          scene. Input devices are guaranteed to be in the same state
          (position, value, etc.) for each call to the
          <methodname>draw()</methodname> method for a given frame.</para>

          <section>
            <title>Recommended Uses</title>

            <para>The only code that should execute in this function is calls
            to OpenGL drawing routines. It is permissible to read from input
            devices to determine what to draw, but application data members
            should not be updated in this function.</para>
          </section>

          <section>
            <title>Possible Misuses</title>

            <para>The <methodname>draw()</methodname> method should not be
            used to perform any time-consuming computations. Code in this
            member function should not change the state of any application
            variables.</para>
          </section>
        </section>

        <section id="section.simple.opengl.app">
          <title>Tutorial: Drawing a Cube with OpenGL</title>

          <indexterm>
            <primary>tutorial</primary>

            <secondary>drawing a cube with OpenGL</secondary>
          </indexterm>

          <table>
            <title>Tutorial Overview</title>

            <tgroup cols="2">
              <tbody>
                <row>
                  <entry>Description</entry>

                  <entry>Simple OpenGL application that draws a cube in the
                  environment</entry>
                </row>

                <row>
                  <entry>Objectives</entry>

                  <entry>Understand how the <methodname>draw()</methodname>
                  member function in <classname>vrj::GlApp</classname> works;
                  create basic OpenGL-based VR Juggler applications</entry>
                </row>

                <row>
                  <entry>Member functions</entry>

                  <entry><itemizedlist><listitem><para><methodname>vrj::App::init()</methodname></para></listitem><listitem><para><methodname>vrj::GlApp::draw()</methodname></para></listitem></itemizedlist></entry>
                </row>

                <row>
                  <entry>Directory</entry>

                  <entry><filename>$VJ_BASE_DIR/share/samples/OGL/simple/SimpleApp</filename></entry>
                </row>

                <row>
                  <entry>Files</entry>

                  <entry><itemizedlist><listitem><para><filename>simpleApp.h</filename></para></listitem><listitem><para><filename>simpleApp.cpp</filename></para></listitem></itemizedlist></entry>
                </row>
              </tbody>
            </tgroup>
          </table>

          <section>
            <title>Class Declaration</title>

            <para>The following application class is called
            <classname>simpleApp</classname>. It is derived from
            <classname>vrj::GlApp</classname> and has custom
            <methodname>init()</methodname> and <methodname>draw()</methodname>
            methods declared. Note that the application declares several
            device interface members that are used by the application for
            getting device data.</para>

            <programlisting linenumbering="numbered">using namespace vrj;
using namespace gadget;

class simpleApp : public GlApp
{
public:
   simpleApp();
   virtual void init();
   virtual void draw();

public:
   PositionInterface mWand;
   PositionInterface mHead;
   DigitalInterface mButton0;
   DigitalInterface mButton1;
};</programlisting>
          </section>

          <section>
            <title>The <methodname>draw()</methodname> Member Function</title>

            <para>The implementation of <methodname>draw()</methodname> is
            located in <filename>simpleApp.cpp</filename>. Its job is to draw
            the environment. A partial implementation follows.</para>

            <programlistingco>
              <areaspec>
                <area coords="5" id="box-offset.init" />

                <area coords="11" id="box-offset.push" />

                <area coords="13" id="draw.cube" />
              </areaspec>

              <programlisting linenumbering="numbered">using namespace gmtl;

void simpleApp::draw()
{
   ...
   // Create box offset matrix
   Matrix44f box_offset;		
   const EulerAngleXYZf euler_ang(Math::deg2Rad(-90.0f), Math::deg2Rad(0.0f),
                                  Math::deg2Rad(0.0f));
   box_offset = gmtl::makeRot&#60;Matrix44f&#62;(euler_ang);
   gmtl::setTrans(box_offset, Vec3f(0.0, 1.0f, 0.0f));
   ...
   glPushMatrix();
      // Push on offset
      glMultMatrixf(box_offset.getData());
      ...
      drawCube();
   glPopMatrix();
   ...
}</programlisting>

              <calloutlist>
                <callout arearefs="box-offset.init">
                  <para>This creates a <classname>gmtl::Matrix44f</classname>
                  object that defines the offset of the cube in the virtual
                  world.</para>
                </callout>

                <callout arearefs="box-offset.push">
                  <para>The new matrix is pushed onto the OpenGL modelview
                  matrix stack.</para>
                </callout>

                <callout arearefs="draw.cube">
                  <para>Finally, a cube is drawn.</para>
                </callout>
              </calloutlist>
            </programlistingco>

            <para>In the above, there is no projection code in the function.
            When the function is called by VR Juggler, the projection matrix
            has already been set up correctly for the system. All the user
            application must do is draw the environment; VR Juggler handles
            the rest. In this example, the <methodname>draw()</methodname>
            member function renders a cube at an offset location.</para>
          </section>

          <section>
            <title>Exercise</title>

            <para>Change the code so that the cube is drawn at the position of
            the wand instead of at the <varname>box_offset</varname> location.</para>
          </section>
        </section>

        <section id="section.csdata.intro">
          <title>Context-Specific Data</title>

          <indexterm>
            <primary>application programming</primary>

            <secondary>OpenGL</secondary>

            <tertiary>context-specific data</tertiary>
          </indexterm>

          <indexterm>
            <primary>context-specific data</primary>
          </indexterm>

          <para>Many readers may already be familiar with the specifics of
          OpenGL. In this section, we provide a very brief introduction to
          <glossterm linkend="gloss.csdata">context-specific data</glossterm>
          within OpenGL, and we proceed to explain how it is used by VR
          Juggler. Those who are already familiar with context-specific data
          may skip ahead to <xref linkend="section.need.for.csdata" /> or to
          <xref linkend="section.using.csdata" />.</para>

          <para>The OpenGL graphics API operates using a state machine that
          tracks the current settings and attributes set by the OpenGL code.
          Each window in which we render using OpenGL has a state machine
          associated with it. The state machines associated with these windows
          are referred to as <glossterm
          linkend="gloss.opengl.rendering.context">OpenGL rendering contexts</glossterm><indexterm><primary>OpenGL
          rendering contexts</primary></indexterm>.</para>

          <para>Each context stores the current state of an OpenGL renderer
          instance. The state includes the following:</para>

          <itemizedlist>
            <listitem>
              <para>Current color</para>
            </listitem>

            <listitem>
              <para>Current shading mode</para>
            </listitem>

            <listitem>
              <para>Current texture</para>
            </listitem>

            <listitem>
              <para>Display lists</para>
            </listitem>

            <listitem>
              <para>Texture objects</para>
            </listitem>
          </itemizedlist>

          <section id="section.need.for.csdata">
            <title>Why it is Needed</title>

            <para>As outlined in the VR Juggler architecture documentation, VR
            Juggler uses a single memory area for all application data. All
            threads can see the same memory area and thus share the same copy
            of all variables. This makes programming normal application code
            very easy because programmers never have to worry about which
            thread can see which variables. In the case of context-specific
            data, however, it presents a problem.</para>

            <para>To understand the problem, consider an environment where we
            use a single display list. That display list is created to draw
            some object in the scene. We would like to be able to call the
            display list in our <methodname>draw()</methodname> method and
            have it draw the primitives that were captured in it.</para>

            <para>The following class skeleton shows an outline of this idea.
            Do not worry for now that we do not show the code where we
            allocate the display list—that will be covered later. For now, we
            see that there is a variable that stores the display list ID (<varname>mDispListId</varname>),
            and we use it in the <methodname>draw()</methodname> method.</para>

            <programlisting>using namespace vrj;

class userApp : public GlApp
{
public:
  draw();
public:
  int mDispListId;
};

userApp::draw()
{
   glCallList(mDispListId);
}</programlisting>

            <para>Now, imagine that we have a VR system configured that needs
            more than one display window (a multi-wall projection system, for
            example). There is a thread for each display, and all the display
            threads call <methodname>draw()</methodname> in parallel.</para>

            <para>Since all threads share the same copy of the variables, they
            all use the same <varname>mDispListId</varname> when calling
            <function>glCallList()</function>. This is an error because we
            call draw from multiple windows (that is, multiple OpenGL
            rendering contexts). The display list ID is not the same in each
            context. What we need, then, is a way to use a different display
            list ID depending upon the OpenGL context within which we are
            currently rendering. Context-specific data comes to the rescue to
            address this problem.</para>

            <para>Context-specific data provides us with a way to get a
            separate copy of a variable for each OpenGL rendering context.
            This may sound daunting at first, but VR Juggler manages this
            special variable so that it appears just as a normal variable. The
            developer never has to deal with contexts directly. VR Juggler
            transparently ensures that the correct copy of the variable is
            being used.</para>
          </section>

          <section>
            <title>Context-Specific Variables in VR Juggler</title>

            <indexterm>
              <primary>context-specific variables</primary>
            </indexterm>

            <para>The following shows how a context-specific variable appears
            in a VR Juggler application:</para>

            <programlisting>using namespace vrj;

class userApp : public GlApp
{
public:
   draw();
public:
   GlContextData&#60;int&#62; mDispListId; // Context-specific variable
};

userApp::draw()
{
   glCallList(*mDispListId);
}</programlisting>

            <para>This code looks nearly the same as the previous example. In
            this case, <varname>mDispListId</varname> is treated as a pointer,
            and it has a special template-based type that tells VR Juggler it
            is context-specific data. When defining a context-specific data
            member, use the <classname>vrj::GlContextData&#60;T&#62;</classname><indexterm><primary>classes</primary><secondary>vrj::GlContextData&#60;T&#62;</secondary></indexterm>
            template class and pass the <quote>true</quote> type of the
            variable to the template definition. From then on, it can be
            treated as a normal pointer.</para>

            <note>
              <para>The types that are used for context-specific data must
              provide default constructors. The user cannot directly call the
              constructor for the data item because VR Juggler has to allocate
              new items on the fly as new contexts are created.</para>
            </note>
          </section>

          <section>
            <title>The Inner Workings of Context-Specific Variables</title>

            <para>Curious readers are probably wondering how all of this
            works. To satisfy any curiosity, we now provide a brief
            description.</para>

            <para>The context data items are allocated using a template-based
            smart pointer class (<classname>vrj::GlContextData&#60;T&#62;</classname><indexterm><primary>classes</primary><secondary>vrj::GlContextData&#60;T&#62;</secondary></indexterm>).
            Behind the scenes, VR Juggler keeps a list of currently allocated
            variables for each context. When the application wants to use a
            context data item, the smart pointer looks in the list and returns
            a reference to the correct copy for the current context.</para>

            <para>This is all done in a fairly light-weight manner. It all
            boils down to one memory lookup and a couple of pointer
            dereferences. Not bad for all the power that it gives.</para>
          </section>
        </section>

        <section id="section.using.csdata">
          <title>Using Context-Specific Data</title>

          <indexterm>
            <primary>context-specific data</primary>

            <secondary>use of</secondary>
          </indexterm>

          <para>The VR Juggler OpenGL graphics system is a complex,
          multi-headed beast. Luckily, developers do not have to understand
          how the system is working to use it correctly. As long as developers
          subscribe to several simple rules for allocating and using context
          data, everything will work fine. This section contains these rules,
          but it does not describe the rationale behind the rules. Those
          readers who are interested in the details of why these rules should
          be followed should please read the subsequent section. It contains
          much more (excruciating) detail.</para>

          <section>
            <title>The Rules</title>

            <para>With the background in how to make a context-specific data
            member and how to use it in a <methodname>draw()</methodname>
            member function, we can move on to how and where the
            context-specific data should be allocated. If we want to create a
            display list, we need to know where we should allocate it.</para>

            <section>
              <title>Rule 1: Do not allocate context data in
              <methodname>draw()</methodname></title>

              <para>This is straightforward: do not allocate context data in
              the <methodname>draw()</methodname> member function. There are
              many reasons for this, but the primary one is that allocation
              tests would be occurring too many times and at incorrect times.
              There are better places to allocate context data.</para>
            </section>

            <section>
              <title>Rule 2: Initialize static context data in
              <methodname>contextInit()</methodname></title>

              <para>The place to allocate static context-specific data is the
              <methodname>vrj::GlApp::contextInit()</methodname><indexterm><primary>vrj::GlApp</primary><secondary>contextInit()
              method</secondary></indexterm> member function. <quote>Static</quote>
              context data refers to context data that does not change during
              the application&#39;s execution. An example of static context
              data would be a display list to render an object model that is
              preloaded by the application and never changes. It is static
              because the display list only has to be generated once for each
              context, and the application can generate the display list as
              soon as it starts execution.</para>

              <para>The <methodname>contextInit()</methodname> member function
              is called immediately after creation of any
              <emphasis>new</emphasis> OpenGL contexts. In other words, it is
              called whenever new windows open. When it is called, the newly
              created context is active. This method is the perfect place to
              allocate static context data because it is only called when we
              have a new context that we need to prepare (and also because
              that is what it is designed for).</para>

              <para>The following code snippet shows a possible use of the
              application object&#39;s <methodname>contextInit()</methodname>
              method:</para>

              <example id="context.data.init.example">
                <title>Initializing context-specific data</title>

                <programlisting linenumbering="numbered">void userApp::contextInit()
{
   // Allocate context specific data
   (*mDispListId) = glGenLists(1);

   glNewList((*mDispListId), GL_COMPILE);
      glScalef(0.50f, 0.50f, 0.50f);
      // Call func that draws a cube in OpenGL
      drawCube();
   glEndList();
   ...
}</programlisting>
              </example>

              <para>This shows the normal way that display lists should be
              allocated in VR Juggler. Allocate the display list, store it to
              a context-specific data member, and then fill the display list.
              Texture objects and other types of context-specific data are
              created in exactly the same manner.</para>
            </section>

            <section>
              <title>Rule 3: Allocate and update dynamic context data in
              <methodname>contextPreDraw()</methodname></title>

              <para>The place to allocate dynamic context-specific data is the
              <methodname>contextPreDraw()</methodname><indexterm><primary>vrj::GlApp</primary><secondary>contextPreDraw()
              method</secondary></indexterm> member function. <quote>Dynamic</quote>
              context data differs from static context data in that dynamic
              data may change during the application&#39;s execution. An
              example of dynamic data would be a display list for rendering an
              object from a data set that changes as the applications
              executes. This requires dynamic context data because the display
              list has to be regenerated every time the application changes
              the data set.</para>

              <para>Consider also the following example. While running an
              application, the user requests to load a new model from a file.
              After the model data is loaded, it may be best to put the
              drawing functions into a fresh display list for rendering the
              model. In this case, <methodname>vrj::GlApp::contextInit()</methodname>
              cannot be used because it is only called when a new context is
              created. Here, all the windows have already been created. What
              we need, then, is a <glossterm linkend="gloss.callback">callback</glossterm>
              that is called once per existing context so that we can add and
              change the context-specific data. That is what
              <methodname>contextPreDraw()</methodname> does. It is called
              once per context for each VR Juggler frame with the current
              context active.</para>

              <para>Please notice, however, that since this method is called
              often and is called in performance-critical areas, you should
              not do much work in it. Any time taken by this method directly
              decreases the draw performance of the application. In most
              cases, we recommend trying to make the function have a very
              simple early exit clause such as in the following example. This
              makes the average cost only that of a single comparison
              operation.</para>

              <programlisting>userApp::contextInit()
{
   if (have work to do)
   {
     // Do it
   }
}</programlisting>
            </section>
          </section>
        </section>

        <section>
          <title>Context-Specific Data Details</title>

          <indexterm>
            <primary>context-specific data</primary>

            <secondary>details</secondary>
          </indexterm>

          <para>Within this section, we provide the details of
          context-specific data in VR Juggler and justify the rules presented
          in the previous section.</para>

          <figure id="figure.vrj.opengl.system">
            <title>VR Juggler OpenGL system</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center"
                fileref="figures/JugglerOGLSystemChart.png" format="PNG"
                scalefit="1" />
              </imageobject>
            </mediaobject>
          </figure>

          <section>
            <title>Do Not Allocate Context-Specific Data in
            <methodname>draw()</methodname></title>

            <para>Rule 1 says that context-specific data should not be
            allocated in an application object&#39;s <methodname>draw()</methodname>
            method. We have already stated that the main reason is that
            <methodname>draw()</methodname> is called too many times, and it
            is called at the wrong time for allocation of context-specific
            data. To be more specific, the <methodname>draw()</methodname>
            method is called for each surface, or for each eye, every frame.
            Static context-specific data only needs to be allocated when a new
            window is opened. (Dynamic context-specific data is handled
            separately.)</para>
          </section>
        </section>

        <section>
          <title>Tutorial: Drawing a Cube using OpenGL Display Lists</title>

          <indexterm>
            <primary>tutorial</primary>

            <secondary>drawing a cube using display lists</secondary>
          </indexterm>

          <table>
            <title>Tutorial Overview</title>

            <tgroup cols="2">
              <tbody>
                <row>
                  <entry>Description</entry>

                  <entry>Drawing a cube using a display list in the
                  <methodname>draw()</methodname> member function</entry>
                </row>

                <row>
                  <entry>Objectives</entry>

                  <entry>Understand how to use context-specific data in an
                  application</entry>
                </row>

                <row>
                  <entry>Member functions</entry>

                  <entry><itemizedlist><listitem><para><methodname>vrj::App::init()</methodname></para></listitem><listitem><para><methodname>vrj::GlApp::contextInit()</methodname></para></listitem><listitem><para><methodname>vrj::GlApp::draw()</methodname></para></listitem></itemizedlist></entry>
                </row>

                <row>
                  <entry>Directory</entry>

                  <entry><filename>$VJ_BASE_DIR/share/samples/OGL/simple/contextApp</filename></entry>
                </row>

                <row>
                  <entry>Files</entry>

                  <entry><itemizedlist><listitem><para><filename>contextApp.h</filename></para></listitem><listitem><para><filename>contextApp.cpp</filename></para></listitem></itemizedlist></entry>
                </row>
              </tbody>
            </tgroup>
          </table>

          <section>
            <title>Class Declaration and Data Members</title>

            <para>The following code example shows the basics of declaring the
            class interface and data members for an application that will use
            context-specific data. This is an extension of the simple OpenGL
            application presented in <xref linkend="section.simple.opengl.app" />.
            Note the addition of the <methodname>contextInit()</methodname>
            declaration and the use of the context-specific data member
            <varname>mCubeDlId</varname>.</para>

            <programlisting linenumbering="numbered">using namespace vrj;

class contextApp : public GlApp
{
public:
   contextApp() {;}
   virtual void init();
   virtual void contextInit();
   virtual void draw();
    ...
public:
   // Id of the cube display list
   GlContextData&#60;GLuint&#62; mCubeDlId;
   ...
};</programlisting>
          </section>

          <section>
            <title>The <methodname>contextInit()</methodname> Member Function</title>

            <para>We now show the implementation of <methodname>contextApp::contextInit()</methodname>.
            Here the display list is created and stored using context-specific
            data. Recall <xref linkend="context.data.init.example" />,
            presented in <xref linkend="section.using.csdata" />. That example
            was based on this tutorial application.</para>

            <programlisting linenumbering="numbered">void contextApp::contextInit()
{
   // Allocate context specific data
   (*mCubeDlId) = glGenLists(1);

   glNewList((*mCubeDlId), GL_COMPILE);
      glScalef(0.50f, 0.50f, 0.50f);
      drawCube();
   glEndList();
   ...
}</programlisting>
          </section>

          <section>
            <title>The <methodname>draw()</methodname> Member Function</title>

            <para>Now that we have a display list ID in context-specific data,
            we can use it in the <methodname>draw()</methodname> member
            function. We render the display list by dereferencing the
            context-specific display list ID.</para>

            <programlisting linenumbering="numbered">using namespace gmtl;

void contextApp::draw()
{
   // Get Wand matrix
   gmtl::Matrix44f wand_matrix(mWand-&#62;getData());
   ...
   glPushMatrix();
      glPushMatrix();
         glMultMatrixf(wand_mat.getData());    
         glCallList(*mCubeDlId);
      glPopMatrix();
      ...
   glPopMatrix();
}</programlisting>
          </section>

          <section>
            <title>Exercise</title>

            <para>In the tutorial application code, replace the call to
            <methodname>drawAxis()</methodname> with a display list call.</para>
          </section>
        </section>
      </section>

      <section id="section.pf.apps">
        <title>OpenGL Performer Applications</title>

        <indexterm>
          <primary>application programming</primary>

          <secondary>OpenGL Performer</secondary>
        </indexterm>

        <para>Programmers familiar with the use of scene graphs may prefer to
        use that data structure rather than writing OpenGL manually. While VR
        Juggler does not provide a scene graph of its own, its design allows
        the use of existing scene graph software. In VR Juggler 1.1 and
        beyond, the supported scene graphs are OpenGL Performer from SGI,
        OpenSG, and Open Scene Graph. This section explains how to use OpenGL
        Performer to write VR Juggler applications.</para>

        <para>A Performer-based VR Juggler application must derive from
        <classname>vrj::PfApp</classname><indexterm><primary>classes</primary><secondary>vrj::PfApp</secondary></indexterm>.
        Similar to <classname>vrj::GlApp</classname> presented in the previous
        section, <classname>vrj::PfApp</classname> derives from
        <classname>vrj::App</classname>. <classname>vrj::PfApp</classname>
        extends <classname>vrj::App</classname> by adding methods that deal
        with scene graph initialization and access. <xref
        linkend="figure.vrj.PfApp2" /> shows how <classname>vrj::PfApp</classname>
        fits into the class hierarchy of a Performer-based VR Juggler
        application.</para>

        <figure id="figure.vrj.PfApp2">
          <title><classname>vrj::PfApp</classname> application class</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
              fileref="figures/userPfApp_hierarchy.png" format="PNG" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>Two of the methods added to the application interface by
        <classname>vrj::PfApp</classname> are <methodname>initScene()</methodname>
        and <methodname>getScene()</methodname><indexterm><primary>vrj::PfApp</primary><secondary>extensions
        to vrj::App</secondary></indexterm>. These are called by the Performer
        Draw Manager to initialize the application scene graph and to get the
        root of the scene graph respectively. They must be implemented by the
        application (they are pure virtual methods within
        <classname>vrj::PfApp</classname>). Additional methods will be
        discussed in this section, but in many cases the default
        implementations of these other methods may be used. A simple tutorial
        application will be provided to illustrate the concepts presented.</para>

        <section>
          <title>Scene Graph Initialization: <methodname>vrj::PfApp::initScene()</methodname></title>

          <indexterm>
            <primary>vrj::PfApp</primary>

            <secondary>initScene() method</secondary>
          </indexterm>

          <indexterm>
            <primary>application programming</primary>

            <secondary>OpenGL Performer</secondary>

            <tertiary>scene graph initialization</tertiary>
          </indexterm>

          <para>In an application using OpenGL Performer, the scene graph must
          be initialized before it can be used. The method
          <methodname>vrj::PfApp::initScene()</methodname> is provided for
          that purpose. Within this method, the root of the application scene
          graph should be created, and any required models should be loaded
          and attached to the root in some way. The exact mechanisms for
          accomplishing this will vary depending on what the application will
          do.</para>

          <para>During the initialization of OpenGL Performer by VR Juggler,
          <methodname>vrj::PfApp::initScene()</methodname> is invoked after
          the Performer functions <function>pfInit()</function> and
          <function>pfConfig()</function> but before <methodname>vrj::App::apiInit()</methodname>.</para>
        </section>

        <section>
          <title>Scene Graph Access: <methodname>vrj::PfApp::getScene()</methodname></title>

          <indexterm>
            <primary>vrj::PfApp</primary>

            <secondary>getScene() method</secondary>
          </indexterm>

          <indexterm>
            <primary>application programming</primary>

            <secondary>OpenGL Performer</secondary>

            <tertiary>scene graph access</tertiary>
          </indexterm>

          <para>In order for Performer to render the application scene graph,
          it must get access to the scene graph root. The method
          <methodname>vrj::PfApp::getScene()</methodname> will be called by
          the Performer Draw Manager so that it can give the scene graph root
          node to Performer. Since the job of <methodname>getScene()</methodname>
          is straightforward, its implementation can be very simple. A typical
          implementation will have a single statement that returns a member
          variable that holds a pointer to the application scene graph root
          node.</para>

          <note>
            <para>Make sure that the node returned is <emphasis>not</emphasis>
            a <classname>pfScene</classname> object. If it is, then lighting
            will not work.</para>
          </note>

          <section>
            <title>Possible Misuses</title>

            <para>Do not load any models in this member function. This sort of
            operation should be done within <methodname>initScene()</methodname>.</para>
          </section>
        </section>

        <section>
          <title>Tutorial: Loading a Model with OpenGL Performer</title>

          <indexterm>
            <primary>tutorial</primary>

            <secondary>loading a model with OpenGL Performer</secondary>
          </indexterm>

          <table>
            <title>Tutorial Overview</title>

            <tgroup cols="2">
              <tbody>
                <row>
                  <entry>Description</entry>

                  <entry>Simple OpenGL Performer application that loads a
                  model</entry>
                </row>

                <row>
                  <entry>Objectives</entry>

                  <entry>Understand how to load a model, add it to a scene
                  graph, and return the root to VR Juggler</entry>
                </row>

                <row>
                  <entry>Member functions</entry>

                  <entry><itemizedlist><listitem><para><methodname>vrj::PfApp::initScene()</methodname></para></listitem><listitem><para><methodname>vrj::PfApp::getScene()</methodname></para></listitem></itemizedlist></entry>
                </row>

                <row>
                  <entry>Directory</entry>

                  <entry><filename>$VJ_BASE_DIR/share/samples/Pf/simple/simplePf</filename></entry>
                </row>

                <row>
                  <entry>Files</entry>

                  <entry><itemizedlist><listitem><para><filename>simplePfApp.h</filename></para></listitem><listitem><para><filename>simplePfApp.cpp</filename></para></listitem></itemizedlist></entry>
                </row>
              </tbody>
            </tgroup>
          </table>

          <section>
            <title>Class Declaration</title>

            <para>The following application class is called
            <classname>simplePfApp</classname>. It is derived from
            <classname>vrj::PfApp</classname> and has custom
            <methodname>initScene()</methodname> and <methodname>getScene()</methodname>
            methods declared. Note that this application uses
            <methodname>preForkInit()</methodname> which will be discussed
            later. Refer to <filename>simplePfApp.h</filename> for the
            implementations of <methodname>preForkInit()</methodname> and
            <methodname>setModel()</methodname>.</para>

            <programlisting linenumbering="numbered">class simplePfApp : public vrj::PfApp
{
public:
   simplePfApp();
   virtual ~simplePfApp();

   virtual void preForkInit();
   virtual void initScene();
   virtual pfGroup* getScene();
   void setModel(std::string modelFile);

public:
   std::string    mModelFileName;

   pfGroup*       mLightGroup;
   pfLightSource* mSun;
   pfGroup*       mRootNode;
   pfNode*        mModelRoot;
};</programlisting>
          </section>

          <section>
            <title>The <methodname>initScene()</methodname> Member Function</title>

            <para>The implementation of <methodname>initScene()</methodname>
            is in <filename>simplePfApp.cpp</filename>. Within this method, we
            create the scene graph root node, the lighting node, and load a
            user-specified model. The implementation follows:</para>

            <programlistingco>
              <areaspec>
                <area coords="4" id="rootnode.create" />

                <area coords="7" id="light.source.create" />

                <area coords="17" id="model.load" />

                <areaset coords="" id="scenegraph.add.all">
                  <area coords="20" id="scenegraph.add.model" />

                  <area coords="21" id="scenegraph.add.light" />
                </areaset>
              </areaspec>

              <programlisting linenumbering="numbered">void simplePfApp::initScene ()
{
   // Allocate all the nodes needed
   mRootNode = new pfGroup;

   // Create the SUN light source
   mLightGroup = new pfGroup;
   mSun = new pfLightSource;
   mLightGroup-&#62;addChild(mSun);
   mSun-&#62;setPos(0.3f, 0.0f, 0.3f, 0.0f);
   mSun-&#62;setColor(PFLT_DIFFUSE, 1.0f, 1.0f, 1.0f);
   mSun-&#62;setColor(PFLT_AMBIENT, 0.3f, 0.3f, 0.3f);
   mSun-&#62;setColor(PFLT_SPECULAR, 1.0f, 1.0f, 1.0f);
   mSun-&#62;on();

   // --- LOAD THE MODEL -- //
   mModelRoot = pfdLoadFile(mModelFileName.c_str());

   // -- CONSTRUCT STATIC STRUCTURE OF SCENE GRAPH -- //
   mRootNode-&#62;addChild(mModelRoot);
   mRootNode-&#62;addChild(mLightGroup);
}</programlisting>

              <calloutlist>
                <callout arearefs="rootnode.create">
                  <para>First, the root node is constructed as a
                  <classname>pfGroup</classname> object.</para>
                </callout>

                <callout arearefs="light.source.create">
                  <para>Next, some steps are taken to create a light source
                  for the application.</para>
                </callout>

                <callout arearefs="model.load">
                  <para>Finally, the model is loaded using
                  <function>pfdLoadFile()</function>, and the model scene
                  graph root node is stored in <varname>mModelRoot</varname>.
                  (The model loader must be initialized prior to calling
                  <function>pfdLoadFile()</function>. This is done in
                  <methodname>preForkInit()</methodname>.)</para>
                </callout>

                <callout arearefs="scenegraph.add.all">
                  <para>Finally, the model and the light source nodes are
                  added as children of the root.</para>
                </callout>
              </calloutlist>
            </programlistingco>
          </section>

          <section>
            <title>The <methodname>getScene()</methodname> Member Function</title>

            <para>The Performer Draw Manager will call the application&#39;s
            <methodname>getScene()</methodname> method to get the root of the
            scene graph. The implementation of this method can be found in
            <filename>simplePfApp.h</filename>. The code is as follows:</para>

            <programlisting>pfGroup* simplePfApp::getScene ()
{
   return mRootNode;
}</programlisting>

            <para>The simplicity of this method implementation is not limited
            to the simple tutorial from which it is taken. All Performer-based
            VR Juggler applications can take advantage of this idiom where the
            root node is a member variable returned in
            <methodname>getScene()</methodname>.</para>
          </section>
        </section>

        <section>
          <title>Other <classname>vrj::PfApp</classname> Methods</title>

          <para>Besides the two methods discussed so far, there are several
          other methods in <classname>vrj::PfApp</classname> that extend the
          basic <classname>vrj::App</classname> interface. Each is discussed
          in this section.</para>

          <section>
            <title><methodname>preForkInit()</methodname></title>

            <indexterm>
              <primary>vrj::PfApp</primary>

              <secondary>preForkInit() method</secondary>
            </indexterm>

            <para>Prototype: <methodsynopsis><modifier>public</modifier><type>void</type><methodname>preForkInit</methodname><void /></methodsynopsis></para>

            <para>This member function allows the user application to do any
            processing that needs to happen before Performer forks its
            processes but after <function>pfInit()</function> is called. In
            other words, it is invoked after <function>pfInit()</function> but
            before <function>pfConfig()</function>.</para>
          </section>

          <section>
            <title><methodname>appChanFunc()</methodname></title>

            <indexterm>
              <primary>vrj::PfApp</primary>

              <secondary>appChanFunc() method</secondary>
            </indexterm>

            <para>Prototype: <methodsynopsis><modifier>public</modifier><type>void</type><methodname>appChanFunc</methodname><methodparam><type>pfChannel*</type><parameter>chan</parameter></methodparam></methodsynopsis></para>

            <para>This method is called every frame in the application process
            for each active channel. It is called immediately before rendering
            (<function>pfFrame()</function>).</para>
          </section>

          <section>
            <title><methodname>configPWin()</methodname></title>

            <indexterm>
              <primary>vrj::PfApp</primary>

              <secondary>configPWin() method</secondary>
            </indexterm>

            <para>Prototype: <methodsynopsis><modifier>public</modifier><type>void</type><methodname>configPWin</methodname><methodparam><type>pfPipeWindow*</type><parameter>pWin</parameter></methodparam></methodsynopsis></para>

            <para>This method is used to initialize a pipe window. It is
            called as soon as the pipe window is opened.</para>
          </section>

          <section>
            <title><methodname>getFrameBufferAttrs()</methodname></title>

            <indexterm>
              <primary>vrj::PfApp</primary>

              <secondary>getFrameBufferAttrs() method</secondary>
            </indexterm>

            <para>Prototype: <methodsynopsis><modifier>public</modifier><type>std::vector&#60;int&#62;</type><methodname>getFrameBufferAttrs</methodname><void /></methodsynopsis></para>

            <para>This method returns the needed parameters for the Performer
            frame buffer. Stereo, double buffering, depth buffering, and RGBA
            are all requested by default.</para>
          </section>

          <section>
            <title><methodname>drawChan()</methodname></title>

            <indexterm>
              <primary>vrj::PfApp</primary>

              <secondary>drawChan() method</secondary>
            </indexterm>

            <para>Prototype: <methodsynopsis><modifier>public</modifier><void /><methodname>drawChan</methodname><methodparam><type>pfChannel*</type><parameter>chan</parameter></methodparam><methodparam><type>void*</type><parameter>chandata</parameter></methodparam></methodsynopsis></para>

            <para>This is the method called in the channel draw function to do
            the actual rendering. For most programs, the default behavior of
            this function is correct. It makes the following calls:</para>

            <programlisting>chan-&#62;clear();
pfDraw();</programlisting>

            <para>Advanced users may want to override this behavior for
            complex rendering effects such as overlays or multi-pass
            rendering. (See the OpenGL Performer manual pages about overriding
            the draw traversal function.) This function is the draw traversal
            function but with the projections set correctly for the given
            displays and eye. Prior to the invocation of this method,
            <varname>chan</varname> is ready to draw.</para>
          </section>

          <section>
            <title><methodname>preDrawChan()</methodname></title>

            <indexterm>
              <primary>vrj::PfApp</primary>

              <secondary>preDrawChan() method</secondary>
            </indexterm>

            <para>Prototype: <methodsynopsis><modifier>public</modifier><type>void</type><methodname>preDrawChan</methodname><methodparam><type>pfChannel*</type><parameter>chan</parameter></methodparam><methodparam><type>void*</type><parameter>chandata</parameter></methodparam></methodsynopsis></para>

            <para>This is the function called by the <emphasis>default</emphasis>
            <methodname>drawChan()</methodname> member function before
            clearing the channel and drawing the next frame (<function>pfFrame()</function>).</para>
          </section>

          <section>
            <title><methodname>postDrawChan()</methodname></title>

            <indexterm>
              <primary>vrj::PfApp</primary>

              <secondary>postDrawChan() method</secondary>
            </indexterm>

            <para>Prototype: <methodsynopsis><modifier>public</modifier><void /><methodname>postDrawChan</methodname><methodparam><type>pfChannel*</type><parameter>chan</parameter></methodparam><methodparam><type>void*</type><parameter>chandata</parameter></methodparam></methodsynopsis></para>

            <para>This is the function called by the <emphasis>default</emphasis>
            <methodname>drawChan()</methodname> member function after clearing
            the channel and drawing the next frame (<function>pfFrame()</function>).</para>
          </section>
        </section>
      </section>

      <section id="section.opensg.apps">
        <title>OpenSG Applications</title>

        <indexterm>
          <primary>application programming</primary>

          <secondary>OpenSG</secondary>
        </indexterm>

        <para>This section explains how to use the OpenSG scene graph in a VR
        Juggler application. OpenSG is an open source scene graph that is
        available at <ulink url="http://www.opensg.org/">www.opensg.org</ulink>.</para>

        <para>An OpenSG-based VR Juggler application must derive from
        <classname>vrj::OpenSGApp</classname><indexterm><primary>classes</primary><secondary>vrj::OpenSGApp</secondary></indexterm>.
        The <classname>vrj::OpenSGApp</classname> class is derived from the
        <classname>vrj::GlApp</classname> presented previously, which in turn
        derives from <classname>vrj::App</classname>. <classname>vrj::OpenSGApp</classname>
        extends <classname>vrj::GlApp</classname> by adding methods that deal
        with scene graph initialization and access. <xref
        linkend="figure.class.vrj.OpenSGApp" /> shows how
        <classname>vrj::OpenSGApp</classname> fits into the class hierarchy of
        an OpenSG-based VR Juggler application.</para>

        <figure id="figure.class.vrj.OpenSGApp">
          <title><classname>vrj::OpenSGApp</classname> application class</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
              fileref="figures/userOpenSGApp_hierarchy.png" format="PNG" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>The two main application methods for <classname>vrj::OpenSGApp</classname>
        VR Juggler applications are <methodname>initScene()</methodname> and
        <methodname>getSceneRoot()</methodname><indexterm><primary>vrj::OpenSGApp</primary><secondary>extensions
        to vrj::GlApp</secondary></indexterm>. These are called by the OpenSG
        application class wrapper to initialize the application scene graph
        and to get the root of the scene graph respectively. They must be
        implemented by the application (they are pure virtual methods within
        <classname>vrj::OpenSGApp</classname>). The rest of this section gives
        a more detailed description of these methods and some sample code to
        illustrate the concepts presented.</para>

        <section>
          <title>Scene Graph Initialization: <methodname>vrj::OpenSGApp::initScene()</methodname></title>

          <indexterm>
            <primary>vrj::OpenSGApp</primary>

            <secondary>initScene() method</secondary>
          </indexterm>

          <indexterm>
            <primary>application programming</primary>

            <secondary>OpenSG</secondary>

            <tertiary>scene graph initialization</tertiary>
          </indexterm>

          <para>In an application using OpenSG, the scene graph must be
          initialized before it can be used. The method
          <methodname>vrj::OpenSGApp::initScene()</methodname> is provided for
          that purpose. Within this method, the root of the application scene
          graph should be created, and any required models should be loaded
          and attached to the root in some way. The exact mechanisms for
          accomplishing this will vary depending on what the application will
          do.</para>

          <para>During the API initialization, <methodname>vrj::OpenSGApp::initScene()</methodname>
          is invoked. This happens after <methodname>OSG::osgInit()</methodname>
          has been called, so OpenSG should be fully initialized and ready to
          be used.</para>
        </section>

        <section>
          <title>Scene Graph Access: <methodname>vrj::OpenSGApp::getSceneRoot()</methodname></title>

          <indexterm>
            <primary>vrj::OpenSGApp</primary>

            <secondary>getSceneRoot() method</secondary>
          </indexterm>

          <indexterm>
            <primary>application programming</primary>

            <secondary>OpenSG</secondary>

            <tertiary>scene graph access</tertiary>
          </indexterm>

          <para>In order for OpenSG to render the application scene graph, it
          must get access to the scene graph root. The method
          <methodname>vrj::OpenSGApp::getSceneRoot()</methodname> will be
          called by the OpenSG application class wrapper so that it can get
          access to the currently active scene graph whenever the wrapper
          needs to use it (ex. rendering, updating). Since the job of
          <methodname>getSceneRoot()</methodname> is straightforward, its
          implementation can be very simple. A typical implementation will
          have a single statement that returns a member variable that holds a
          pointer to the current scene graph root node.</para>

          <section>
            <title>Possible Misuses</title>

            <para>Do not do any CPU-heavy processing in this method. Because
            this method is called frequently, it should only do the minimum
            amount of processing necessary to return the root scene graph
            node. In most cases this method should only be one line of code.
            See the following code for an example.</para>

            <programlisting>virtual OSG::NodePtr getSceneRoot()
{
   return mSceneRoot;  // Return the root of the graph
}</programlisting>

            <para>If you need to update the scene graph, you should use either
            <methodname>preFrame()</methodname>, <methodname>intraFrame()</methodname>,
            or <methodname>postFrame()</methodname>.</para>
          </section>
        </section>

        <section>
          <title>Tutorial: Loading a Model with OpenSG</title>

          <indexterm>
            <primary>tutorial</primary>

            <secondary>loading a model with OpenSG</secondary>
          </indexterm>

          <table>
            <title>Tutorial Overview</title>

            <tgroup cols="2">
              <tbody>
                <row>
                  <entry>Description</entry>

                  <entry>Simple OpenSG application that loads a model</entry>
                </row>

                <row>
                  <entry>Objectives</entry>

                  <entry>Understand how to load a model, add it to a scene
                  graph, and return the root to VR Juggler</entry>
                </row>

                <row>
                  <entry>Member functions</entry>

                  <entry><itemizedlist><listitem><para><methodname>vrj::OpenSGApp::initScene()</methodname></para></listitem><listitem><para><methodname>vrj::OpenSGApp::getScene()</methodname></para></listitem></itemizedlist></entry>
                </row>

                <row>
                  <entry>Directory</entry>

                  <entry><filename>$VJ_BASE_DIR/share/vrjuggler/samples/OpenSG/simple/OpenSGNav</filename></entry>
                </row>

                <row>
                  <entry>Files</entry>

                  <entry><itemizedlist><listitem><para><filename>OpenSGNav.h</filename></para></listitem><listitem><para><filename>OpenSGNav.cpp</filename></para></listitem></itemizedlist></entry>
                </row>
              </tbody>
            </tgroup>
          </table>

          <section>
            <title>Class Declaration</title>

            <para>The following application class is called
            <classname>OpenSGNav</classname>. It is derived from
            <classname>vrj::OpenSGApp</classname> and has custom
            <methodname>initScene()</methodname>, <methodname>getSceneRoot()</methodname>,
            <methodname>init()</methodname>, <methodname>contextInit()</methodname>,
            and <methodname>preFrame()</methodname> methods declared. Refer to
            <filename>OpenSGNav.h</filename> for the implementation of
            <methodname>setModelFileName()</methodname>.</para>

            <programlisting linenumbering="numbered">class OpenSGNav : public vrj::OpenSGApp
{
public:
   OpenSGNav(vrj::Kernel* kern);
   virtual ~OpenSGNav();

   virtual void init();
   virtual void contextInit();
   virtual void preFrame();

   virtual void initScene();
   virtual OSG::NodePtr getSceneRoot();

   void setModelFileName(std::string filename);

private:
   void initGLState();

private:
   std::string mFileToLoad;

   OSG::NodePtr        mRootNode;
   OSG::TransformPtr   mSceneScale;
   OSG::NodePtr        mSceneRoot;
   OSG::TransformPtr   mSceneTransform;
   OSG::NodePtr        mModelRoot;

   OSG::NodePtr  mLightNode;
   OSG::NodePtr  mLightBeacon;

public:
   gadget::PositionInterface  mWandPos;
   gadget::DigitalInterface   mButton0;
   gadget::DigitalInterface   mButton1;
   gadget::DigitalInterface   mButton2;
   float  velocity;
};
</programlisting>
          </section>

          <section>
            <title>The <methodname>initScene()</methodname> Member Function</title>

            <para>The implementation of <methodname>initScene()</methodname>
            is in <filename>OpenSGNav.cpp</filename>. Within this method, we
            create the scene graph root node, the lighting node, and load a
            user-specified model. The implementation follows:</para>

            <programlisting linenumbering="numbered">void OpenSGNav::initScene()
{
   // Load the model to use
   if (mFileToLoad ==  std::string(&#34;none&#34;))                               <co
id="OpenSGNav.load.model.co" linkends="OpenSGNav.load.model.desc" />
   {
      mModelRoot = OSG::makeTorus(.5, 2, 16, 16);      
   }
   else
   {
      mModelRoot =
         OSG::SceneFileHandler::the().read(mFileToLoad.c_str());
   }

   // --- Light setup --- //
   // - Add directional light for scene
   // - Create a beacon for it and connect to that beacon
   mLightNode   = OSG::Node::create();                                    <co
id="OpenSGNav.create.light.co" linkends="OpenSGNav.load.model.desc" />
   mLightBeacon = OSG::Node::create();
   OSG::DirectionalLightPtr light_core = OSG::DirectionalLight::create();
   OSG::TransformPtr light_beacon_core = OSG::Transform::create();

   // Setup light beacon
   OSG::Matrix light_pos;
   light_pos.setTransform(osg::Vec3f( 2.0f, 5.0f, 4.0f));

   OSG::beginEditCP(light_beacon_core, OSG::Transform::MatrixFieldMask);
      light_beacon_core-&#62;setMatrix(light_pos);
   OSG::endEditCP(light_beacon_core, OSG::Transform::MatrixFieldMask);

   OSG::beginEditCP(mLightBeacon);
      mLightBeacon-&#62;setCore(light_beacon_core);
   OSG::endEditCP(mLightBeacon);

   // Setup light node
   OSG::addRefCP(mLightNode);
   OSG::beginEditCP(mLightNode);
      mLightNode-&#62;setCore(light_core);
      mLightNode-&#62;addChild(mLightBeacon);
   OSG::endEditCP(mLightNode);

   OSG::beginEditCP(light_core);
      light_core-&#62;setAmbient   (.9, .8, .8, 1);
      light_core-&#62;setDiffuse   ( 0.6,  0.6,  0.6, 1);
      light_core-&#62;setSpecular  ( 1,  1,  1, 1);
      light_core-&#62;setDirection ( 0,  0,  1);
      light_core-&#62;setBeacon    (mLightNode);
   OSG::endEditCP(light_core);

   // --- Setup Scene -- //
   // add the loaded scene to the light node, so that it is lit by the light
   OSG::addRefCP(mModelRoot);
   OSG::beginEditCP(mLightNode);                                          <co
id="OpenSGNav.model.add.co" linkends="OpenSGNav.model.add.desc" />
      mLightNode-&#62;addChild(mModelRoot);
   OSG::endEditCP(mLightNode);

   // create the root part of the scene
   mRootNode = OSG::Node::create();                                       <co
id="OpenSGNav.root.create.co" linkends="OpenSGNav.root.create.desc" />
   mSceneScale = OSG::Transform::create();
   mSceneRoot = OSG::Node::create();                                      <co
id="OpenSGNav.scene.root.create.co"
linkends="OpenSGNav.scene.root.create.desc" />
   mSceneTransform = OSG::Transform::create();

   // Set the root node
   OSG::beginEditCP(mRootNode);
      mRootNode-&#62;setCore(mSceneScale);
      mRootNode-&#62;addChild(mSceneRoot);                                    <co
id="OpenSGNav.add.scene.root.co" linkends="OpenSGNav.add.scene.root.desc" />
   OSG::endEditCP(mRootNode);

   OSG::beginEditCP(mSceneRoot);
      mSceneRoot-&#62;setCore(mSceneTransform);
      mSceneRoot-&#62;addChild(mLightNode);                                   <co
id="OpenSGNav.add.light.co" linkends="OpenSGNav.add.light.desc" />
   OSG::endEditCP(mSceneRoot);
}</programlisting>

            <calloutlist>
              <callout arearefs="OpenSGNav.load.model.co"
              id="OpenSGNav.load.model.desc">
                <para>We begin by loading the file set in
                <methodname>OpenSGNav::setModelFileName()</methodname>. If no
                file name was set, we default to using a simple torus model.
                The model object is <varname>mModelRoot</varname>.</para>
              </callout>

              <callout arearefs="OpenSGNav.create.light.co"
              id="OpenSGNav.create.light.desc">
                <para>Next, we create a node for the light, which we define as
                a beacon light.</para>
              </callout>

              <callout arearefs="OpenSGNav.model.add.co"
              id="OpenSGNav.model.add.desc">
                <para>The model is added under the light in the scene graph so
                that it gets lit.</para>
              </callout>

              <callout arearefs="OpenSGNav.root.create.co"
              id="OpenSGNav.root.create.desc">
                <para>Then, the root note for the scene graph is created. This
                is what will be returned to OpenSG for rendering by
                <methodname>OpenSGNav::getSceneRoot()</methodname>.</para>
              </callout>

              <callout arearefs="OpenSGNav.scene.root.create.co"
              id="OpenSGNav.scene.root.create.desc">
                <para>We also create a root node for the scene. We do this so
                that we can give it a transformation object without affecting
                the root of the scene graph.</para>
              </callout>

              <callout arearefs="OpenSGNav.add.scene.root.co"
              id="OpenSGNav.add.scene.root.desc">
                <para>The scene root is added as a child of the root node.</para>
              </callout>

              <callout arearefs="OpenSGNav.add.light.co"
              id="OpenSGNav.add.light.desc">
                <para>Finally, we add the light node as a child of the scene
                root. Remember that the light node already has the loaded
                model as a child.</para>
              </callout>
            </calloutlist>
          </section>

          <section>
            <title>The <methodname>getSceneRoot()</methodname> Member Function</title>

            <para>The Performer Draw Manager will call the application&#39;s
            <methodname>getSceneRoot()</methodname> method to get the root of
            the scene graph. The implementation of this method can be found in
            <filename>OpenSGNav.h</filename>. The code is as follows:</para>

            <programlisting>OSG::NodePtr OpenSGNav::getSceneRoot()
{
   return mRootNode;
}</programlisting>

            <para>The simplicity of this method implementation is not limited
            to the simple tutorial from which it is taken. All OpenSG-based VR
            Juggler applications can take advantage of this idiom where the
            root node is a member variable returned in
            <methodname>getSceneRoot()</methodname>.</para>
          </section>
        </section>
      </section>

      <section>
        <title>VTK Applications</title>

        <indexterm>
          <primary>application programming</primary>

          <secondary>VTK</secondary>
        </indexterm>

        <para></para>
      </section>
    </chapter>

    <chapter id="chapter.porting.CAVElib">
      <title>Porting to VR Juggler from the <trademark>CAVElib</trademark></title>

      <indexterm>
        <primary>porting applications from</primary>

        <secondary><trademark>CAVElib</trademark></secondary>
      </indexterm>

      <indexterm>
        <primary><trademark>CAVElib</trademark></primary>

        <secondary>porting to VR Juggler</secondary>
      </indexterm>

      <para>In this chapter, we give some methods for porting an application
      written with the <trademark>CAVElib</trademark> software to VR Juggler.
      We explain the process for an OpenGL application. Throughout, we compare
      and contrast the techniques used by VR Juggler and the
      <trademark>CAVElib</trademark> software, and we translate concepts
      familiar to <trademark>CAVElib</trademark> programmers into VR Juggler
      terms.</para>

      <section>
        <title>The Initialize, Draw, and Frame Routines</title>

        <para>In the <trademark>CAVElib</trademark>, the initialize, draw, and
        frame routines are known as <glossterm linkend="gloss.callback">callbacks</glossterm>
        implemented with C function pointers. In VR juggler, the equivalent
        routines are <quote>called back</quote> using an application object.
        An application object is a C++ class that defines methods to
        encapsulate the functionality of the application within a single C++
        object.</para>

        <section>
          <title>In <trademark>CAVElib</trademark></title>

          <para>The following lists the draw, frame, and initialize routines
          used in the <trademark>CAVElib</trademark> software.</para>

          <itemizedlist>
            <listitem>
              <para>Draw: An application&#39;s display callback function is
              defined by passing a function pointer to <function>CAVEDisplay()</function></para>
            </listitem>

            <listitem>
              <para>Frame: The frame function is defined with
              <function>CAVEFrameFunction()</function></para>
            </listitem>

            <listitem>
              <para>Init: The initialization callback is defined using
              <function>CAVEInitApplication()</function></para>
            </listitem>
          </itemizedlist>
        </section>

        <section>
          <title>In VR Juggler</title>

          <para>With VR Juggler, no C function pointers are necessary, but a
          pointer to an application object must be given to the VR Juggler
          kernel. As described in earlier sections of this chapter, the first
          step is to derive a new application class from
          <classname>vrj::GlApp</classname>. For more information on
          application objects, it may be helpful to review <xref
          linkend="chapter.app.basics" />. Briefly, the application class
          definition would appear similar to the following:</para>

          <programlisting>class MyApplication : public vrj::GlApp
{
   ...
};</programlisting>

          <para>The draw, frame, and initialize routine concepts in VR Juggler
          are presented in the following list.</para>

          <itemizedlist>
            <listitem>
              <para>Draw: An application&#39;s display <quote>callback</quote>
              function is defined by a member function called
              <methodname>draw()</methodname> in the derived class. This is
              where OpenGL rendering commands such as <function>glBegin()</function>,
              <function>glVertex()</function>, etc. are placed.</para>
            </listitem>

            <listitem>
              <para>Frame: Calculations such as navigation, collision,
              physics, artificial intelligence, etc. are often placed in the
              frame function. The frame function is split across three member
              functions:</para>

              <orderedlist>
                <listitem>
                  <para><methodname>MyApplication::preFrame()</methodname>,
                  called before <methodname>draw()</methodname></para>
                </listitem>

                <listitem>
                  <para><methodname>MyApplication::intraFrame()</methodname>,
                  called during <methodname>draw()</methodname></para>
                </listitem>

                <listitem>
                  <para><methodname>MyApplication::postFrame()</methodname>,
                  called after <methodname>draw()</methodname></para>
                </listitem>
              </orderedlist>
            </listitem>

            <listitem>
              <para>Init: There is an initialization member function for data
              and an initialization member function for creating
              context-specific data (display lists, texture objects). The
              latter is called for each <glossterm
              linkend="gloss.display.context">display context</glossterm> in
              the system. These two member functions are:</para>

              <orderedlist>
                <listitem>
                  <para><methodname>MyApplication::init()</methodname>, called
                  once per application startup</para>
                </listitem>

                <listitem>
                  <para><methodname>MyApplication::contextInit()</methodname>,
                  called once per display context <emphasis>creation</emphasis></para>
                </listitem>
              </orderedlist>
            </listitem>
          </itemizedlist>

          <para>Readers who find some of these concepts unfamiliar are
          encouraged to read <xref linkend="section.opengl.apps" />. For
          information about context-specific data, refer to <xref
          linkend="section.csdata.intro" />.</para>
        </section>
      </section>

      <section>
        <title>Getting Input from Devices</title>

        <para>Getting input from the hardware devices is conceptually the
        same, but the implementations are quite different between the
        <trademark>CAVElib</trademark> software and VR Juggler.</para>

        <section>
          <title>In <trademark>CAVElib</trademark></title>

          <para>To get tracking information, the following functions are used:</para>

          <itemizedlist>
            <listitem>
              <para><function>CAVEGetPosition(id, pos)</function></para>
            </listitem>

            <listitem>
              <para><function>CAVEGetOrientation(id, orient)</function></para>
            </listitem>

            <listitem>
              <para><function>CAVEGetVector(id, vec)</function></para>
            </listitem>

            <listitem>
              <para><function>CAVEGetSensorPosition(sensor, coords, pos)</function></para>
            </listitem>

            <listitem>
              <para><function>CAVEGetSensorOrientation(sensor, coords, orient)</function></para>
            </listitem>

            <listitem>
              <para><function>CAVEGetSensorVector(sensor, id, vec)</function></para>
            </listitem>
          </itemizedlist>

          <para>For button input, the following macros are used:</para>

          <itemizedlist>
            <listitem>
              <para><constant>CAVEBUTTON1</constant>, <constant>CAVEBUTTON2</constant>,
              <constant>CAVEBUTTON3</constant>, <constant>CAVEBUTTON4</constant>,
              <constant>CAVE_JOYSTICK_X</constant>, and <constant>CAVE_JOYSTICK_Y</constant></para>
            </listitem>

            <listitem>
              <para><function>CAVEButtonChange()</function></para>
            </listitem>
          </itemizedlist>
        </section>

        <section>
          <title>In VR Juggler</title>

          <para>To get device input, use the classes derived from
          <classname>gadget::DeviceInterface</classname>. They include the
          following:</para>

          <itemizedlist>
            <listitem>
              <para><classname>gadget::PositionInterface</classname> (for
              trackers and other positional devices)</para>
            </listitem>

            <listitem>
              <para><classname>gadget::DigitalInterface</classname> (for
              buttons and other on/off devices)</para>
            </listitem>

            <listitem>
              <para><classname>gadget::AnalogInterface</classname> (for
              potentiometers and other multi-range data devices)</para>
            </listitem>
          </itemizedlist>

          <para>For more information about the VR Juggler device interfaces,
          refer to <xref linkend="chapter.helper.classes" />. A tutorial on
          getting device input in VR Juggler applications can be found in
          <xref linkend="section.get.input" />.</para>
        </section>
      </section>

      <section>
        <title>Configuration</title>

        <para>Configuration of VR Juggler and the <trademark>CAVElib</trademark>
        software is very different. The differences are too numerous to list
        here, but we give a brief overview and a pointer to the documentation
        that explains configuration of VR Juggler.</para>

        <section>
          <title>In <trademark>CAVElib</trademark></title>

          <para>All configurable parameters go in a single file called
          <filename>.caverc</filename>. The configuration mechanism is
          proprietary and not usable by external VR system software. In
          particular, VR Juggler cannot get its configuration information from
          an existing <filename>.caverc</filename> file.</para>
        </section>

        <section>
          <title>In VR Juggler</title>

          <para>Configuration of VR Juggler is much more powerful and flexible
          than what is used by the <trademark>CAVElib</trademark> software. As
          a result, it is also more complex. All configurable parameters could
          be in one or more files with any names desired. VR Juggler comes
          with example configuration files that may be found in the directory
          <filename>$VJ_BASE_DIR/share/vrjuggler/data/configFiles</filename>.</para>

          <para>The VR Juggler configuration system is completely extensible
          and could be used outside of VR Juggler. Indeed, it could be used
          outside of any VR paradigm altogether. Refer to the Configuration
          Guide for more information on configuring VR Juggler.</para>
        </section>
      </section>

      <section>
        <title>Important Notes</title>

        <para>Finally, before we get to the source code, there are some
        important notes about programming VR Juggler applications in general.
        Please read these carefully and refer to the indicated chapters for
        more information as necessary.</para>

        <section>
          <title>Shared Memory</title>

          <para>Unlike the <trademark>CAVElib</trademark> software, VR Juggler
          does not have to manage shared memory with other VR Juggler
          instances. Thus, when writing a VR Juggler application, memory can
          be created as in a normal, single-threaded C or C++ application.</para>
        </section>

        <section>
          <title>OpenGL Context-Specific Data</title>

          <para>As a result of the shared memory model described above, VR
          Juggler has different requirements for context-specific data than
          the <trademark>CAVElib</trademark> software. Information such as
          display lists and texture objects must be managed using
          context-specific data. A <glossterm linkend="gloss.display.context">display
          context</glossterm> is the location to which OpenGL rendering
          commands draw. Compiled OpenGL commands such as display lists do not
          get shared across multiple contexts (or windows), and thus, they
          must be initialized once per display context. In a VR Juggler
          application, these OpenGL initializations must be placed in
          <methodname>vrj::GlApp::contextInit()</methodname>. It is called
          once per display context after each context has become active. For a
          more detailed description of these concepts and a tutorial on how to
          use them, please refer to <xref linkend="section.csdata.intro" />.</para>
        </section>
      </section>

      <section>
        <title>Source Code</title>

        <para>This final section is the heart of the porting discussion. We
        present some source code as a means to illustrate how
        <trademark>CAVElib</trademark> concepts map to VR Juggler.</para>

        <section>
          <title>The Form of a Basic <trademark>CAVElib</trademark> Program</title>

          <programlisting linenumbering="numbered">void app_shared_init();
void app_compute_init();
void app_init_gl();
void app_draw();
void app_compute();

void main(int argc, char **argv)
{
   CAVEConfigure(&#38;argc,argv,NULL);
   app_shared_init(argc,argv);
   CAVEInit();
   CAVEInitApplication(app_init_gl,0);
   CAVEDisplay(app_draw,0);
   app_compute_init(argc,argv);
   while (!getbutton(ESCKEY))
   {
       app_compute();
   }
   CAVEExit();
}</programlisting>
        </section>

        <section>
          <title>The Form of a Basic VR Juggler Program</title>

          <programlisting linenumbering="numbered">class MyApplication : public vrj::GlApp
{
public:
// Data callbacks  (Do not put OpenGL code here)
   virtual void init();
   virtual void preFrame();
   virtual void intraFrame();
   virtual void postFrame();
      
// OpenGL callbacks (put only OpenGL code here)
   virtual void contextInit();
   virtual void draw();
};

int main(int argc, char* argv[]) 
{
   // configure kernel with *.config files
   vrj::Kernel* kernel = vrj::Kernel::instance(); // Get the kernel
   for(int i=1; i&#60;argc; i++)
   {
      // loading config file passed on command line...
      kernel-&#62;loadConfigFile(argv[i]);
   }

   // start the kernel
   kernel-&#62;start();

   // set the application for the kernel to run
   MyApplication* application = new MyApplication();
   kernel-&#62;setApplication(application);

   // Block until the kernel exits.
   kernel-&#62;waitForKernelStop();

   return 0;
}</programlisting>
        </section>
      </section>
    </chapter>

    <chapter>
      <title>Porting to VR Juggler from GLUT</title>

      <indexterm>
        <primary>porting applications from</primary>

        <secondary>GLUT</secondary>
      </indexterm>

      <indexterm>
        <primary>GLUT</primary>

        <secondary>porting to VR Juggler</secondary>
      </indexterm>

      <para>In this chapter, we give some methods for porting an application
      written with GLUT to VR Juggler. Throughout, we compare and contrast the
      techniques used by VR Juggler and GLUT, and we translate concepts
      familiar to GLUT programmers into VR Juggler terms.</para>

      <section>
        <title>Window Creation and Management</title>

        <para>In VR Juggler, window creation is done behind the scenes based
        on configuration file settings. There are two display types: Surface
        and Simulator. A Surface Display can be put into three modes: stereo,
        right eye, or left eye. Most interesting is the stereo mode. Stereo
        mode requires special hardware to display stereo, and it creates the
        most immersive experience. A Simulator Display is special because it
        emulates an active VR system. It can show the all active user head
        positions and orientation, any active devices such as gloves or wands,
        and any Surface Displays. The simulator window is nice for debugging
        tracking systems and for visualizing configured Surface Displays.</para>
      </section>

      <section>
        <title>The Initialize, Draw, and Frame Routines</title>

        <section>
          <title>In GLUT</title>

          <para>In GLUT, the initialize, draw, and frame routines are known as
          <glossterm linkend="gloss.callback">callbacks</glossterm>
          implemented with C function pointers. In VR juggler, the equivalent
          routines are <firstterm>called back</firstterm> using an application
          object. An application object is a C++ class that defines methods to
          encapsulate the functionality of the application within a single C++
          object.</para>

          <itemizedlist>
            <listitem>
              <para>Draw: OpenGL commands are placed in the draw routine. The
              callback function is defined by passing a function pointer to
              <function>glutDisplayFunc()</function>.</para>
            </listitem>

            <listitem>
              <para>Frame: Operations on application data are done within the
              frame routine. No OpenGL commands are allowed here because the
              display window is undefined at this point. The frame function is
              defined with <function>glutIdleFunc()</function>. This function
              generally does a <function>glutPostRedisplay()</function> to
              cause the display callback to be executed.</para>
            </listitem>

            <listitem>
              <para>Init: There is no callback for initialization. Data
              initialization is done usually before the application starts.
              Context initialization is done during the first run of the
              function set with <function>glutDisplayFunc()</function> (once
              for each window opened).</para>
            </listitem>
          </itemizedlist>
        </section>

        <section>
          <title>In VR Juggler</title>

          <para>With VR Juggler, no C function pointers are necessary, but a
          pointer to an application object must be given to the VR Juggler
          kernel. As described in earlier sections of this chapter, the first
          step is to derive a new application class from
          <classname>vrj::GlApp</classname>. For more information on
          application objects, it may be helpful to review <xref
          linkend="chapter.app.basics" />. Briefly, the application class
          definition would appear similar to the following:</para>

          <programlisting>class MyApplication : public vrj::GlApp
{
   ...
};</programlisting>

          <para>The draw, frame, and initialize routine concepts in VR Juggler
          are presented in the following list.</para>

          <itemizedlist>
            <listitem>
              <para>Draw: An application&#39;s display <quote>callback</quote>
              function is defined by a new member function called
              <methodname>draw()</methodname> in the derived class. This is
              where OpenGL rendering commands such as <function>glBegin()</function>,
              <function>glVertex()</function>, etc. are placed.</para>
            </listitem>

            <listitem>
              <para>Frame: Calculations such as navigation, collision,
              physics, artificial intelligence, etc. are often placed in the
              frame function. The frame function is split across three member
              functions:</para>

              <orderedlist>
                <listitem>
                  <para><methodname>MyApplication::preFrame()</methodname>,
                  called before <methodname>draw()</methodname></para>
                </listitem>

                <listitem>
                  <para><methodname>MyApplication::intraFrame()</methodname>,
                  called during <methodname>draw()</methodname></para>
                </listitem>

                <listitem>
                  <para><methodname>MyApplication::postFrame()</methodname>,
                  called after <methodname>draw()</methodname></para>
                </listitem>
              </orderedlist>
            </listitem>

            <listitem>
              <para>Init: There is an initialization member function for data
              and an initialization member function for creating
              context-specific data (display lists, texture objects). The
              latter is called for each display context in the system. These
              two member functions are:</para>

              <orderedlist>
                <listitem>
                  <para><methodname>MyApplication::init()</methodname>, called
                  once per application startup</para>
                </listitem>

                <listitem>
                  <para><methodname>MyApplication::contextInit()</methodname>,
                  called once per display context creation</para>
                </listitem>
              </orderedlist>
            </listitem>
          </itemizedlist>

          <para>Readers who find some of these concepts unfamiliar are
          encouraged to read <xref linkend="section.opengl.apps" />. For
          information about context-specific data, refer to <xref
          linkend="section.csdata.intro" />.</para>
        </section>
      </section>

      <section>
        <title>Getting Input from Devices</title>

        <section>
          <title>In GLUT</title>

          <para>For keyboard input, the following functions are used:</para>

          <itemizedlist>
            <listitem>
              <para><function>glutKeyboardFunc(OnKeyboardDown)</function></para>
            </listitem>

            <listitem>
              <para><function>glutKeyboardUpFunc(OnKeyboardUp)</function></para>
            </listitem>

            <listitem>
              <para><function>glutSpecialFunc(OnSpecialKeyboardDown)</function></para>
            </listitem>

            <listitem>
              <para><function>glutSpecialUpFunc(OnSpecialKeyboardUp)</function></para>
            </listitem>
          </itemizedlist>

          <para>For mouse input, the following functions are used:</para>

          <itemizedlist>
            <listitem>
              <para><function>glutMouseFunc(OnMouseButton)</function></para>
            </listitem>

            <listitem>
              <para><function>glutMotionFunc(OnMousePosition)</function></para>
            </listitem>

            <listitem>
              <para><function>glutPassiveMotionFunc(OnMousePosition)</function></para>
            </listitem>
          </itemizedlist>
        </section>

        <section>
          <title>In VR Juggler</title>

          <para>To get device input, use the classes derived from
          <classname>gadget::DeviceInterface</classname>. They include the
          following:</para>

          <itemizedlist>
            <listitem>
              <para><classname>gadget::PositionInterface</classname> (for
              trackers and other positional devices)</para>
            </listitem>

            <listitem>
              <para><classname>gadget::DigitalInterface</classname> (for
              buttons and other on/off devices)</para>
            </listitem>

            <listitem>
              <para><classname>gadget::AnalogInterface</classname> (for
              potentiometers and other multi-range data devices)</para>
            </listitem>
          </itemizedlist>

          <para>For more information about the VR Juggler device interfaces,
          refer to <xref linkend="chapter.helper.classes" />. A tutorial on
          getting device input in VR Juggler applications can be found in
          <xref linkend="section.get.input" />.</para>
        </section>
      </section>

      <section>
        <title>Configuration</title>

        <para>Configuration of GLUT applications is quite different than
        configuration of VR Juggler applications. In particular, VR Juggler is
        much more dynamic because configurations are maintained as files
        separate from the application. In GLUT, the configuration must be
        written into the application somehow. This can lead to very static,
        hard-coded configurations.</para>

        <section>
          <title>In GLUT</title>

          <para>There is no built-in configuration system. All system settings
          are coded using the GLUT API.</para>
        </section>

        <section>
          <title>In VR Juggler</title>

          <para>VR Juggler has a powerful and flexible configuration system.
          As a result, it is also complex. All configurable parameters could
          be in one or more files with any names desired. VR Juggler comes
          with example configuration files that may be found in the directory
          <filename>$VJ_BASE_DIR/share/vrjuggler/data/configFiles</filename>.</para>

          <para>The VR Juggler configuration system is completely extensible
          and could be used outside of VR Juggler. Indeed, it could be used
          outside of any VR paradigm altogether. Refer to the
          <emphasis>VRJConfig Guide</emphasis> for more information on
          configuring VR Juggler.</para>
        </section>
      </section>

      <section>
        <title>Important Notes</title>

        <para>Finally, before we get to the source code, there are some
        important notes about programming VR Juggler applications in general.
        Please read these carefully and refer to the indicated chapters for
        more information as necessary.</para>

        <section>
          <title>Shared Memory</title>

          <para>VR Juggler is multi-threaded, and it uses a shared memory
          model across all threads. Thus, when writing a VR Juggler
          application, memory can be created as in a normal, single-threaded C
          or C++ application. VR Juggler is written entirely in C++, and as
          such, new and delete must be used instead of <function>malloc()</function>
          and <function>free()</function>.</para>
        </section>

        <section>
          <title>OpenGL Context-Specific Data</title>

          <para>As a result of the shared memory model described above, VR
          Juggler has different requirements for context-specific data than
          GLUT. Information such as display lists and texture objects must be
          managed using context-specific data. A <glossterm
          linkend="gloss.callback">display context</glossterm> is the location
          to which OpenGL rendering commands draw. Compiled OpenGL commands
          such as display lists do not get shared across multiple contexts (or
          windows), and thus, they must be initialized once per display
          context. In a VR Juggler application, these OpenGL initializations
          must be placed in <methodname>vrj::GlApp::contextInit()</methodname>.
          It is called once per display context after each context has become
          active. For a more detailed description of these concepts and a
          tutorial on how to use them, please refer to <xref
          linkend="section.csdata.intro" />.</para>
        </section>
      </section>

      <section>
        <title>Source Code</title>

        <para>This final section is the heart of the porting discussion. We
        present some source code as a means to illustrate how GLUT concepts
        map to VR Juggler.</para>

        <section>
          <title>The Form of a Basic GLUT Program</title>

          <programlisting linenumbering="numbered">void main(int argc, char* argv[])
{
   /* initialize the application data here */
   OnApplicationInit();

   /* create a window to render graphics in
    * In VR Juggler, window creation is done for you based on your configuration file
    * settings.
    */
   glutInitWindowSize( 640, 480 );
   glutInit( &#38;argc, argv );
   glutInitDisplayMode( GLUT_RGBA | GLUT_DEPTH | GLUT_DOUBLE );
   glutCreateWindow( &#34;GLUT application&#34; );

   /* display callbacks.
    * NOTE: the first time OnIdle is called is when you should 
    *       initialize the display context for each window
    *       (doing this is analogous to VR Juggler&#39;s 
    *       vrj::GlApp::contextInit() function)
    */
   glutReshapeFunc( OnReshape );
   glutIdleFunc( OnIdle );
   glutDisplayFunc( OnIdle );

   /* tell glut to not call the keyboard callback repeatedly 
    * when holding down a key. (uses edge triggering, like the mouse does)
    */
   glutIgnoreKeyRepeat( 1 );

   /* keyboard callback functions. */
   glutKeyboardFunc( OnKeyboardDown );
   glutKeyboardUpFunc( OnKeyboardUp );
   glutSpecialFunc( OnSpecialKeyboardDown );
   glutSpecialUpFunc( OnSpecialKeyboardUp );

   /* mouse callback functions... */
   glutMouseFunc( OnMouseClick );
   glutMotionFunc( OnMousePos );
   glutPassiveMotionFunc( OnMousePos );

   /* start the application loop, your callbacks will now be called
    * time for glut to sit and spin.  In Juggler this is the same as the while(1)
    * (see below)
    */
   glutMainLoop();
}</programlisting>
        </section>

        <section>
          <title>The Form of a Basic VR Juggler Program</title>

          <programlisting linenumbering="numbered">class MyApplication : public vrj::GlApp
{
public:
// Data callbacks  (Do not put OpenGL code here)
   virtual void init();
   virtual void preFrame();
   virtual void intraFrame();
   virtual void postFrame();
      
// OpenGL callbacks (put only OpenGL code here)
   virtual void contextInit();
   virtual void draw();
};

int main(int argc, char* argv[]) 
{
   // configure kernel with *.config files
   vrj::Kernel* kernel = vrj::Kernel::instance(); // Get the kernel
   for(int i=1; i&#60;argc; i++)
   {
      // loading config file passed on command line...
      kernel-&#62;loadConfigFile(argv[i]);
   }

   // start the kernel
   kernel-&#62;start();

   // set the application for the kernel to run
   MyApplication* application = new MyApplication();
   kernel-&#62;setApplication(application);

   // Block until the kernel exits.
   kernel-&#62;waitForKernelStop();

   return 0;
}</programlisting>
        </section>
      </section>
    </chapter>
  </part>

  <part id="part.advanced.topics">
    <title>Advanced Topics</title>

    <chapter id="chapter.system.interaction">
      <title>System Interaction</title>

      <para>In this part of the book, we present information for advanced
      users who want to create applications that take advantage of VR Juggler
      features such as threading and run-time reconfiguration. While we do
      recommend that all programmers be familiar with these topics, readers
      who are not familiar with the basic concepts of multi-threaded
      programming, for example, may find these chapters difficult to
      understand.</para>
    </chapter>

    <chapter id="chapter.multi-threading">
      <title>Multi-threading</title>

      <indexterm>
        <primary>multi-threading</primary>
      </indexterm>

      <para>In this chapter, we present how to use multi-threading within VR
      Juggler applications. Readers who are not familiar with the basic
      concepts of multi-threaded programming may find the following sections
      difficult to understand. This chapter is written with the assumption
      that readers already know the necessary background material and want to
      learn about how VR Juggler implements the concepts.</para>

      <section id="section.multi-threading">
        <title>Techniques</title>

        <indexterm>
          <primary>multi-threading</primary>

          <secondary>techniques</secondary>
        </indexterm>

        <para>VR Juggler is a multi-threaded software system. We have built up
        a cross-platform abstraction for threads and synchronization
        primitives as part of making VR Juggler more portable. This
        abstraction is available to application developers. In addition, the
        basic VR Juggler application object interface provides a mechanism for
        inherent parallel programming in applications. In this section, we
        provide a more detailed description of these techniques and how to put
        them into use.</para>

        <para>To begin the discussion on multi-threaded programming with VR
        Juggler, we describe the techniques available to application
        programmers. There are three options from which programmers may
        choose:</para>

        <orderedlist>
          <listitem>
            <para>Use the <methodname>vrj::App::intraFrame()</methodname>
            application object member function</para>
          </listitem>

          <listitem>
            <para>Use triple-buffered data with <methodname>vrj::App::intraFrame()</methodname></para>
          </listitem>

          <listitem>
            <para>Use triple-buffered data with separate threads</para>
          </listitem>
        </orderedlist>
      </section>

      <section id="section.tutorial.intraFrame">
        <title>Tutorial: Perform Computations Asynchronously to Rendering with
        <methodname>intraFrame()</methodname></title>

        <indexterm>
          <primary>tutorial</primary>

          <secondary>rendering and computing asynchronously using intraFrame()</secondary>
        </indexterm>

        <table>
          <title>Tutorial Overview</title>

          <tgroup cols="2">
            <tbody>
              <row>
                <entry>Description</entry>

                <entry>Performing the computations to animate a mesh
                asynchronously to rendering the mesh</entry>
              </row>

              <row>
                <entry>Objectives</entry>

                <entry>Understand how to use multi-threading techniques in an
                application</entry>
              </row>

              <row>
                <entry>Member functions</entry>

                <entry><itemizedlist><listitem><para><methodname>vrj::App::init()</methodname></para></listitem><listitem><para><methodname>vrj::App::preFrame()</methodname></para></listitem><listitem><para><methodname>vrj::App::intraFrame()</methodname></para></listitem><listitem><para><methodname>vrj::GlApp::draw()</methodname></para></listitem></itemizedlist></entry>
              </row>

              <row>
                <entry>Directory</entry>

                <entry><filename>$VJ_BASE_DIR/share/samples/OGL/simple/MPApp</filename></entry>
              </row>

              <row>
                <entry>Files</entry>

                <entry><itemizedlist><listitem><para><filename>MPApp.h</filename></para></listitem><listitem><para><filename>MPApp.cpp</filename></para></listitem><listitem><para><filename>Mesh.h</filename></para></listitem></itemizedlist></entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <section>
          <title>Class Declaration and Data Members</title>

          <para>The following code example shows the basics of declaring the
          class interface and data members for an application that will use
          context-specific data. This is an extension of the simple OpenGL
          application presented in <xref linkend="section.simple.opengl.app" />.
          Note the addition of the <methodname>contextInit()</methodname>
          declaration and the use of the context-specific data member
          <varname>mCubeDlId</varname>.</para>

          <programlisting linenumbering="numbered">using namespace vrj;

class MPApp : public GlApp
{
public:
   MPApp() {;}
   virtual void init();
   virtual void preFrame();
   virtual void draw();
   virtual void intraFrame();
    ...
public:
   // The Mesh object used for computing and rendering.
   Mesh mMesh;
   ...
};</programlisting>
        </section>

        <section>
          <title>The <methodname>preFrame()</methodname> Member Function</title>

          <para>We now show the implementation of <methodname>MPApp::preFrame()</methodname>.
          In the initial version of the application, the computation for the
          mesh animation is done here.</para>

          <programlisting linenumbering="numbered">void MPApp::preFrame()
{
   mCurTime += 0.005;
   mMesh.compute(mCurTime);

   // Other once-per-frame operations follow ...
}</programlisting>

          <note>
            <para>Note that in this example, the animation is based on the
            frame rate. It is much better to use a time-based animation
            scheme. For this example, however, we will keep things simple.</para>
          </note>
        </section>

        <section>
          <title>The <methodname>draw()</methodname> Member Function</title>

          <para>When we enter <methodname>draw()</methodname>, the
          computations for this frame&#39;s animation are complete. Thus, we
          can call the <methodname>render()</methodname> method to display the
          new calculations.</para>

          <programlisting linenumbering="numbered">using namespace gmtl;

void MPApp::draw()
{
   glClear(GL_DEPTH_BUFFER_BIT);

   // --- Setup for drawing --- //
   glMatrixMode(GL_MODELVIEW);

   glColor3f(0.0f, 0.5f, 0.75f);
   glPushMatrix();
      glScalef(15.0f,15.0f,15.0f);
      glRotatef(-90.0f,1.0,0.0,0.0);
      mMesh.render();                // Render the mesh
   glPopMatrix();
}</programlisting>
        </section>

        <section>
          <title>Exercise</title>

          <para>In the tutorial application code, perform the computations
          asynchronously to the rendering process by using
          <methodname>intraFrame()</methodname>. Recall from <xref
          linkend="section.app.intraFrame" /> (in <xref
          linkend="section.app.frame.functions" />) that
          <methodname>intraFrame()</methodname> is invoked in parallel to the
          execution of <methodname>draw()</methodname>.</para>
        </section>
      </section>

      <section id="section.multi-threading.classes">
        <title>Helper Classes</title>

        <indexterm zone="section.multi-threading.classes">
          <primary>multi-threading</primary>

          <secondary>helper classes</secondary>
        </indexterm>

        <para>All the techniques presented in the previous section require
        some form of synchronization to protect the data accessed by multiple
        threads. Developers who choose the third option and use separate
        threads must learn the VR Juggler Portable Runtime (VPR) thread API. A
        full description of this API is beyond the scope of this book. In this
        section, we will describe at a high level the important classes. For
        more detailed information, refer to the <emphasis>VR Juggler Portable
        Runtime Programmer&#39;s Guide</emphasis>.</para>

        <section id="section.using.vprThread">
          <title><classname>vpr::Thread</classname></title>

          <indexterm zone="section.using.vprThread">
            <primary>multi-threading</primary>

            <secondary>vpr::Thread</secondary>
          </indexterm>

          <indexterm zone="section.using.vprThread">
            <primary>vpr::Thread</primary>
          </indexterm>

          <para>When considering multi-threaded programming, it is important
          to know that with great power comes great responsibility. The power
          is being able to provide multiple threads of control in a single
          application. The responsibility is making sure those threads get
          along with each other and do not step on each other&#39;s data. VR
          Juggler is a multi-threaded library which makes it very powerful and
          very complex.</para>

          <para>As a cross-platform framework, VR Juggler uses an internal
          threading abstraction that provides a uniform interface to
          platform-specific threading implementations. That cross-platform
          interface is available to programmers to make applications
          multi-threaded without tying them to a specific operating
          system&#39;s threading implementation.</para>

          <para>The threading interface in VPR is modeled after the POSIX
          thread specification of POSIX.1b (formerly POSIX.4). The main
          difference is that VPR&#39;s interface is object-oriented while
          POSIX threads (pthreads) are procedural. The basic principles are
          exactly the same, however. A function (or class method) is provided
          to the <classname>vpr::Thread</classname> class, and that function
          is executed in a thread of control that is independent of the
          creating thread.</para>

          <para>Threads are spawned (initialized and begin execution) when the
          <classname>vpr::Thread</classname> constructor is called. That is,
          when instantiating a <classname>vpr::Thread</classname> object, a
          new thread of execution is created. The semantics of threads says
          that a thread can begin execution at any time after being created,
          and this is true with <classname>vpr::Thread</classname>s. Do not
          make any assumptions about when the thread will begin running. It
          may happen before or after the constructor returns the
          <classname>vpr::Thread</classname> object.</para>

          <para>To pass arguments to threads, the common mechanism of
          encapsulating them in a C++ <type>struct</type> must be used. The
          function executed by the thread takes only a single argument of type
          <type>void*</type>. An argument is not required, of course, but to
          pass more than one argument to a thread, the best way to do this is
          to create a structure and pass a pointer to it to the
          <classname>vpr::Thread</classname> constructor.</para>

          <para>Once a <classname>vpr::Thread</classname> object is created,
          it acts as an interface into controlling the thread it encapsulates.
          Thread signals can be sent, priority changes can be made, execution
          can be suspended, etc. This interface is the focus of this section.</para>
        </section>

        <section>
          <title><classname>vpr::BaseThreadFunctor</classname></title>

          <indexterm>
            <primary>vpr::BaseThreadFunctor</primary>

            <seealso>vpr::ThreadMemberFunctor, vpr::ThreadNonMemberFunctor</seealso>
          </indexterm>

          <para>In this section, we explain the concept and use of functors.
          As with much of VR Juggler, a functor is a high-level concept that
          encapsulates something quite simple. A functor is defined as
          <quote>something that performs an operation or a function.</quote>
          While this is not very detailed, it is clear and concise. In VPR,
          functors can be used as the code executed by a thread.</para>

          <para>In VPR, a functor is simply another object type that happens
          to encapsulate a user-defined function. The details on how this is
          done are not important here, but they are provided later for those
          who are interested. What is important to know is that a functor can
          be thought of as a normal function. When using them, programmers
          simply implement a function and then pass the function pointer (and
          the function&#39;s optional argument) to the functor&#39;s
          constructor. The object does the rest.</para>

          <para>Observant readers may have noticed the parenthetical phrase in
          the previous paragraph mentioning a function&#39;s optional
          argument. Note that <quote>argument</quote> is singular meaning that
          only one parameter can be passed to the function that will be run by
          the created thread. The type of that argument is the wonderfully
          vague <type>void*</type>, an artifact of basing the threading
          subsystem on C libraries. As discussed in the section on using
          <classname>vpr::Thread</classname>s, if there is a need to pass
          multiple arguments, they must be encapsulated in a struct or a
          comparable object.</para>

          <para>Once a functor object exists, it is passed to the
          <classname>vpr::Thread</classname> constructor, and the new thread
          will execute the functor (which knows about the function). The end
          result is the same as using a normal C/C++ function or a static
          class member function, but there is one special benefit: with
          functors, non-static class member functions can be passed. In many
          cases, there arises a need to run a member function in a separate
          thread, but making it static is infeasible or awkward. Thus, it
          would be best to pass a non-static member function to the created
          thread. To get access to the non-static data members, however, the
          C++ <varname>this</varname> pointer must be available to the thread.
          By using a VPR functor, that is all handled behind the scenes so
          that passing a non-static member function is straightforward.</para>
        </section>

        <section>
          <title>Using the <classname>vpr::Semaphore</classname> Interface</title>

          <indexterm>
            <primary>vpr::Semaphore</primary>
          </indexterm>

          <para>The most important part of multi-threaded programming is
          proper thread synchronization so that access to shared data is
          controlled. Doing so results in consistency among all threads.
          Semaphores are a very common synchronization mechanism and have been
          used widely in concurrent systems. This short section describes the
          cross-platform semaphore interface provided with and used by VPR. It
          does not explain what semaphores are or how to use them—it is
          assumed that readers are already familiar with the topic lest they
          probably would not be reading this chapter on advanced classes at
          all.</para>

          <para>As with threads, a cross-platform abstraction layer has been
          written into VPR to provide a consistent way to use semaphores on
          all supported platforms. The primary goal behind the interface
          design is to provide the common <emphasis>P</emphasis> (acquire) and
          <emphasis>V</emphasis> (release) operations. A given semaphore
          controls access to <emphasis>n</emphasis> resources. Thus, n threads
          can acquire a semaphore without blocking, but the
          <emphasis>n</emphasis> + 1 attempt to acquire the semaphore will
          block until a resource release occurs. The interface does include
          methods for read/write semaphores, but as of this writing, that part
          of the interface is not complete.</para>
        </section>

        <section id="section.using.vprMutex">
          <title>Using the <classname>vpr::Mutex</classname> Interface</title>

          <indexterm>
            <primary>vpr::Mutex</primary>
          </indexterm>

          <para>In addition to cross-platform semaphores, VPR provides an
          abstraction for cross-platform mutexes. Mutexes are a special type
          of semaphore known as a binary semaphore. Exactly one thread can
          hold the lock at any time. This very short section, however, is not
          about mutexes but rather about the <classname>vpr::Mutex</classname>
          interface provided with VPR and used by VR Juggler.</para>

          <para>The cross-platform mutex abstraction in VPR is critical for
          synchronizing access to shared data. Those who have read the section
          on <classname>vpr::Semaphore</classname><indexterm><primary>classes</primary><secondary>vpr::Semaphore</secondary></indexterm>
          will find this section very, very familiar. The interface for
          <classname>vpr::Mutex</classname> is a subset of that for
          <classname>vpr::Semaphore</classname> since mutexes are binary
          semaphores. In other words, they control access to exactly one
          resource. They can be locked and unlocked. That is all there is to
          know. The <classname>vpr::Mutex</classname> interface does include
          some methods for read/write mutexes, but this implementation is
          incomplete and is not documented here for that reason. When the
          implementation is finished, this documentation will be expanded.</para>
        </section>
      </section>

      <section>
        <title>Using Data Buffering</title>

        <para>In the reader exercise from <xref
        linkend="section.tutorial.intraFrame" />, we do not suggest the use of
        mutexes to protect access to the data modified in
        <methodname>intraFrame()</methodname> and rendered in
        <methodname>draw()</methodname>. When the mesh is rendered, some
        tearing will almost certainly be seen. This happens as a result of
        data changing during the rendering of the data. In other words, access
        to a <glossterm linkend="gloss.critical.section">critical section</glossterm>
        of code not being controlled. To prevent tearing, we need to protect
        the internal mesh data. However, using a mutex to control access to
        the mesh will result in the computation and rendering being
        serialized. In so doing, we lose the value of parallelizing the
        computation and rendering.</para>

        <section id="section.triple.buffering">
          <title>Triple Buffering</title>

          <indexterm zone="section.triple.buffering">
            <primary>triple buffering</primary>

            <secondary>definition</secondary>
          </indexterm>

          <para>To work around this, we can use multiple buffers. More
          specifically, we will use three buffers: one for reading, one for
          writing, and one as temporary storage of the most recently completed
          write(s). This is called <glossterm linkend="gloss.triple.buffering">triple
          buffering</glossterm>, and it allows us to perform computation and
          rendering in parallel without causing one process to wait on the
          other. The rendering buffer can be accessed without locking, as can
          the computation buffer. The only time a lock must be held is when
          the latest computations are copied into the temporary storage buffer
          or when the contents of the temporary storage buffer are copied into
          the rendering buffer. Thus, the key to triple buffering is the
          temporary storage buffer.</para>

          <para>Implementing triple buffering is relatively straightforward,
          once the basic idea is understood. For this discussion we will refer
          to the buffers as follows:</para>

          <orderedlist>
            <listitem>
              <para><firstterm>Stable</firstterm>: The buffer from which the
              most recent data will be read</para>
            </listitem>

            <listitem>
              <para><firstterm>Working</firstterm>: The buffer into which the
              current data will be written</para>
            </listitem>

            <listitem>
              <para><firstterm>Working Copy</firstterm>: The buffer used to
              store the last completed write results temporarily</para>
            </listitem>
          </orderedlist>

          <para>Of the three, Working Copy is the only one that is shared
          between the threads, and thus, only one mutex must be used. The
          mutex must be locked when swapping the contents of Stable and
          Working Copy and when swapping the contents of Working and Working
          Copy. No lock must be held when reading from Stable or when writing
          to Working. This is where the major benefit of triple buffering is
          realized.</para>

          <para>In the thread that will write to Working, the implementation
          will follow this basic structure:</para>

          <programlisting>while ( KeepWriting )
{
   Write to Working

   Lock Working Copy mutex
      Swap Working and Working Copy
   Unlock Working Copy mutex
}</programlisting>

          <para>In the thread that will read from Stable, the implementation
          is (roughly) the reverse:</para>

          <programlisting>while ( KeepReading )
{
   Lock Working Copy mutex
      Swap Stable and Working Copy
   Unlock Working Copy mutex

   Read from Stable
}</programlisting>
        </section>

        <section id="section.optimize.tribuffer">
          <title>Optimizing Triple Buffering</title>

          <indexterm zone="section.optimize.tribuffer">
            <primary>triple buffering</primary>

            <secondary>optimization of</secondary>
          </indexterm>

          <para>It is possible to optimize triple buffering to reduce the
          amount of time spent in the locked section. Instead of swapping the
          buffers, we can swap the pointers to the buffers. The result is that
          we only have to swap (up to) eight bytes of memory, regardless of
          the size of the actual data.</para>

          <para>A very simple way to implement this is to use a three-element
          array to hold the buffers and three variables to use as the indices
          into the array. The variables can be named <varname>stable</varname>,
          <varname>working</varname>, and <varname>working_copy</varname>, for
          example. All accesses into the array of buffers use one of those
          three values. In other words, the thread reading from Stable will
          use <varname>buffer[stable]</varname> to get its buffer. Similarly,
          the thread writing to Working will use <varname>buffer[working]</varname>.
          Swapping the buffers simply involves changing the values of
          <varname>stable</varname> and <varname>working_copy</varname> or
          <varname>working</varname> and <varname>working_copy</varname>.</para>

          <para>In the thread that will perform the writing, the pseudo-code
          for swapping is as follows:</para>

          <programlisting>Lock Working Copy mutex
   temp = working
   working = working_copy
   working_copy = working
Unlock Working Copy Mutex</programlisting>

          <para>Similarly, in the thread that will perform the reading, the
          pseudo-code for swapping is as follows:</para>

          <programlisting>Lock Working Copy mutex
   temp = stable
   stable = working_copy
   working_copy = stable
Unlock Working Copy Mutex</programlisting>

          <para>In these examples, it takes three memory copies to swap the
          two values. Use of the temporary storage is required (at the C/C++
          level), and thus, swapping the memory cannot be done any faster,
          regardless of the size of the data buffers.</para>
        </section>

        <section id="section.app.tribuffer">
          <title>Using Triple Buffering in an Application</title>

          <indexterm zone="section.app.tribuffer">
            <primary>triple buffering</primary>

            <secondary>using in an application</secondary>
          </indexterm>

          <para>Triple buffering can be used in VR Juggler applications in two
          ways: in <methodname>intraFrame()</methodname> or in a separate
          thread. In both cases, the operations will happen asynchronously to
          the <methodname>draw()</methodname> thread, so the uses are
          <emphasis>roughly</emphasis> equivalent. Using
          <methodname>intraFrame()</methodname> is easier than creating a
          separate thread because the parallel processing comes
          <quote>for free</quote> with <methodname>intraFrame()</methodname>.
          No special actions must be taken on the part of the application
          developer. Programmers must keep in mind, however, that if the
          computations will take longer than the rendering, the application
          frame rate will drop. This is because the next frame cannot start
          until after <methodname>intraFrame()</methodname> completes. Thus,
          using a thread will increase the complexity of the application code
          somewhat, but it will ensure that the frame rate will not be
          adversely affected.</para>
        </section>

        <section>
          <title>Tutorial: Perform Computations Using Triple Buffering</title>

          <indexterm>
            <primary>tutorial</primary>

            <secondary>rendering and computing using triple buffering</secondary>
          </indexterm>

          <para>In this tutorial, we will use MPApp again to do parallel
          computation and rendering. This time, however, we will use
          triple-buffered, protected data instead of simply writing in
          <methodname>intraFrame()</methodname> and reading (simultaneously)
          in <methodname>draw()</methodname>. It will be best to begin with an
          unmodified version of MPApp to ensure that no changes made for the
          previous tutorial affect this exercise.</para>

          <para>Using the information presented earlier in this section, the
          exercise is to extend the <classname>Mesh</classname> class (found
          in <filename>Mesh.h</filename>) so that it uses triple buffering for
          computation and rendering. It is up to the reader to decide whether
          to use threads (refer to the documentation for
          <classname>vpr::Thread</classname> in <xref
          linkend="section.using.vprThread" /> and in the online
          <emphasis>Programmer Reference</emphasis>) or to use
          <methodname>intraFrame()</methodname>. Either way, a single
          <classname>vpr::Mutex</classname> instance will be needed, so it may
          be helpful to review <xref linkend="section.using.vprMutex" /> as
          well.</para>
        </section>
      </section>
    </chapter>

    <chapter id="chapter.runtime.reconfig">
      <title>Run-Time Reconfiguration</title>

      <indexterm>
        <primary>run-time reconfiguration</primary>
      </indexterm>

      <para>In this chapter, we introduce run-time reconfiguration, one of the
      most powerful features of VR Juggler. We will give an overview of how it
      works before proceeding into how to use it. The idea here is to
      introduce the concepts, justify the value of run-time reconfiguration,
      and then present its use so that developers can take full advantage of
      this feature.</para>

      <section>
        <title>How Run-Time Reconfiguration Works</title>

        <para></para>
      </section>

      <section>
        <title>Reasons to Use Run-Time Reconfiguration</title>

        <para></para>
      </section>

      <section>
        <title>Using Run-Time Reconfiguration in an Application</title>

        <indexterm>
          <primary>run-time reconfiguration</primary>

          <secondary>use in application</secondary>
        </indexterm>

        <para>There are four steps involved in adding run-time reconfiguration
        to a VR Juggler application. We describe each of them in detail here
        in the following subsections.</para>

        <section>
          <title>Create Application-Specific Configuration Definitions</title>

          <para>The first step in adding dynamic reconfiguration capabilities
          to an application is to decide what aspects of the application
          should be configurable. Naturally, this is very
          application-specific, but some of the following choices are common:</para>

          <itemizedlist>
            <listitem>
              <para>Initial parameters (position, color, etc.) of objects in
              the environment</para>
            </listitem>

            <listitem>
              <para>Navigational position</para>
            </listitem>

            <listitem>
              <para>Global settings such as difficulty level of a game, or
              network settings for a distributed application</para>
            </listitem>
          </itemizedlist>

          <para>Once decisions are made regarding configuration information,
          it is time to define the kinds of configuration elements that will
          contain it. This essentially means creating a file containing one or
          more configuration definitions. To understand this better, consider
          the following example. One might define an <quote>Object</quote>
          definition in an application. The definition would have properties
          that include the name and type of an object, its color and size, and
          so forth.</para>

          <para>There are several ways to ensure that custom configuration
          definitions are read by the application. One way is to load the
          definition file explicitly (described below), but the simplest way
          is to include the custom definition file from one of the
          configuration files the application loads at startup. Instructions
          for editing configuration definition files and creating new kinds of
          definitions are included in the <emphasis>VRJConfig User&#39;s Guide</emphasis>.</para>
        </section>

        <section>
          <title>Implement the Dynamic Reconfiguration Interface</title>

          <para>The next step is to implement the dynamic reconfiguration
          interface for the application object. This interface is defined by
          the <classname>jccl::ConfigChunkHandler</classname><indexterm><primary>classes</primary><secondary>jccl::ConfigChunkHandler</secondary></indexterm>
          class and consists of three methods:</para>

          <orderedlist>
            <listitem>
              <methodsynopsis>
                <modifier>virtual</modifier>

                <type>bool</type>

                <methodname>configCanHandle</methodname>

                <methodparam>
                  <type>jccl::ConfigChunkPtr</type>

                  <parameter>element</parameter>
                </methodparam>
              </methodsynopsis>

              <indexterm>
                <primary>vrj::App</primary>

                <secondary>configCanHandle() method</secondary>
              </indexterm>

              <para>This function should simply return a Boolean (true or
              false) depending on whether this object knows how to deal with
              the configuration element passed to it. If this element uses an
              application-custom definition, this should return
              <constant>true</constant>. For example:</para>

              <programlisting>std::string s = element-&#62;getType();

if ( !jccl::strcasecmp(s, &#34;my_custom_element_type&#34;) )
{
   return true;
}</programlisting>
            </listitem>

            <listitem>
              <methodsynopsis>
                <modifier>virtual</modifier>

                <type>bool</type>

                <methodname>configAdd</methodname>

                <methodparam>
                  <type>jccl::ConfigChunkPtr</type>

                  <parameter>element</parameter>
                </methodparam>
              </methodsynopsis>

              <indexterm>
                <primary>vrj::App</primary>

                <secondary>configAdd() method</secondary>
              </indexterm>

              <para>This method is called whenever an element is added to the
              application, whether by loading a configuration file or through
              a dynamic reconfiguration event. Prior to this, the element will
              have been passed through the application object&#39;s
              <methodname>configCanHandle()</methodname> method. Thus, when
              <methodname>configAdd()</methodname> is called, the element is
              destined for the application object.</para>

              <para>When <methodname>configAdd()</methodname> is called, the
              application should look at the element passed to it and decide
              what to do. This might involve creating a new object, changing
              the configuration of an extant object, changing the values of
              certain variables, or any number of other possibilities. This
              flexibility is part of the power of dynamic reconfiguration with
              VR Juggler.</para>
            </listitem>

            <listitem>
              <methodsynopsis>
                <modifier>virtual</modifier>

                <type>bool</type>

                <methodname>configRemove</methodname>

                <methodparam>
                  <type>jccl::ConfigChunkPtr</type>

                  <parameter>element</parameter>
                </methodparam>
              </methodsynopsis>

              <indexterm>
                <primary>vrj::App</primary>

                <secondary>configRemove() method</secondary>
              </indexterm>

              <para>This method is analogous to <methodname>configAdd()</methodname>.
              It is called when VR Juggler receives a command to remove a
              particular configuration element. If the element refers to a
              specific object in the application, the most obvious behavior
              would be to remove that particular object. If the element refers
              to some other properties of the application, there are several
              choices for the correct behavior. For example, one might choose
              to reset those properties to their default values. In some
              cases, it may be desirable or necessary to ignore the remove
              request.</para>
            </listitem>
          </orderedlist>
        </section>

        <section>
          <title>Procesing Configuration Elements</title>

          <para>When an application receives a configuration element to
          process via <methodname>configAdd()</methodname> or
          <methodname>configRemove()</methodname>, it needs to retrieve the
          data in that element in order to decide what to do. Configuration
          elements can be very complex, but the interface has been designed to
          be as simple as possible. We now describe a few of the most
          important methods in the <classname>jccl::ConfigChunk</classname>
          API.</para>

          <itemizedlist>
            <listitem>
              <methodsynopsis>
                <type>std::string</type>

                <methodname>jccl::ConfigChunk::getDescToken</methodname>

                <void />

                <modifier>const</modifier>
              </methodsynopsis>

              <indexterm>
                <primary>jccl::ConfigChunk</primary>

                <secondary>getDescToken() method</secondary>
              </indexterm>

              <para>This method returns the token of the configuration
              definition which describes this element. This is useful if an
              application uses several kinds of custom element types. With
              this method, it is possible to distinguish one from another.</para>
            </listitem>

            <listitem>
              <methodsynopsis>
                <type>T</type>

                <methodname>jccl::ConfigChunk::getProperty&#60;T&#62;</methodname>

                <methodparam>
                  <type>std::string&#38;</type>

                  <parameter>propertyToken</parameter>
                </methodparam>

                <methodparam>
                  <type>int</type>

                  <parameter>num</parameter>
                </methodparam>
              </methodsynopsis>

              <indexterm>
                <primary>jccl::ConfigChunk</primary>

                <secondary>getProperty&#60;T&#62;() method</secondary>
              </indexterm>

              <para>This is the key method for getting the information
              contained in a configuration element. Its arguments are the
              token associated with a property and a numeric index. For
              example, a property might store a coordinate with three values,
              each of which can be accessed separately by using the numbers 0,
              1, or 2 for the <varname>num</varname> parameter.</para>

              <para>The return value and the template parameter for this
              method need some explanation. Basically, the return value of
              <methodname>getProperty()</methodname> is cast to whichever type
              the caller expects to receive. This type is named using the
              template paramter. (It is assumed that the caller knows the
              types of values stored in a given property.) The use of the
              template paramter allows any type to be used through the
              type-specific specialization performed by the C++ compiler. The
              following code fragment gives a few examples of this usage:</para>

              <programlisting>std::string s1 = element-&#62;getProperty&#60;std::string&#62;(&#34;name&#34;, 0);

bool b = element-&#62;getProperty&#60;bool&#62;(&#34;enabled&#34;);
std::string s3 = element-&#62;getProperty&#60;std::string&#62;(&#34;enabled&#34;);
// s3 will be one of the strings &#34;0&#34; or &#34;1&#34;

jccl::ConfigChunkPtr ch = element-&#62;getProperty&#60;jccl::ConfigChunkPtr&#62;(&#34;embedded_element&#34;, 2);</programlisting>
            </listitem>

            <listitem>
              <methodsynopsis>
                <type>int</type>

                <methodname>jccl::ConfigChunk::getNum</methodname>

                <methodparam>
                  <modifier>const</modifier>

                  <type>std::string&#38;</type>

                  <parameter>propertyToken</parameter>
                </methodparam>

                <modifier>const</modifier>
              </methodsynopsis>

              <indexterm>
                <primary>jccl::ConfigChunk</primary>

                <secondary>getNum() method</secondary>
              </indexterm>

              <para>Sometimes properties of a configuration element can have a
              variable number of values. A good example is a property that
              lists a set of files to be loaded. The <methodname>getNum()</methodname>
              method returns the actual number of values of the named
              property.</para>
            </listitem>
          </itemizedlist>

          <para>For definitive information about the <classname>jccl::ConfigChunk</classname>
          API, refer to the JCCL <emphasis>Programmer&#39;s Reference</emphasis>.</para>
        </section>

        <section>
          <title>Loading and Saving Configurations</title>

          <para></para>
        </section>
      </section>

      <section id="section.app.specific.config">
        <title>Tutorial: Using Application-Specific Configurations</title>

        <indexterm>
          <primary>tutorial</primary>

          <secondary>using application-specific configurations</secondary>
        </indexterm>

        <table>
          <title>Tutorial Overview</title>

          <tgroup cols="2">
            <tbody>
              <row>
                <entry>Description</entry>

                <entry>Simple OpenGL application that draws a cube in the
                environment</entry>
              </row>

              <row>
                <entry>Objectives</entry>

                <entry>Understand how the <methodname>configCanHandle()</methodname>
                and <methodname>configAdd()</methodname> member functions in
                <classname>jccl::ConfigChunkHandler</classname> work; create
                application-specific configurations using JCCL</entry>
              </row>

              <row>
                <entry>Member functions</entry>

                <entry><itemizedlist><listitem><para><methodname>jccl::ConfigChunkHandler::configCanHandle()</methodname></para></listitem><listitem><para><methodname>jccl::ConfigChunkHandler::configAdd()</methodname></para></listitem><listitem><para><methodname>vrj::GlApp::draw()</methodname></para></listitem></itemizedlist></entry>
              </row>

              <row>
                <entry>Directory</entry>

                <entry><filename>$VJ_BASE_DIR/share/samples/OGL/simple/ConfigApp</filename></entry>
              </row>

              <row>
                <entry>Files</entry>

                <entry><itemizedlist><listitem><para><filename>ConfigApp.desc</filename></para></listitem><listitem><para><filename>ConfigApp.config</filename></para></listitem><listitem><para><filename>ConfigApp.h</filename></para></listitem><listitem><para><filename>ConfigApp.cpp</filename></para></listitem></itemizedlist></entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <section>
          <title>Class Declaration</title>

          <para>The following application class is called
          <classname>ConfigApp</classname>. It is derived from
          <classname>vrj::GlApp</classname> and has custom
          <methodname>configCanHandle()</methodname>,
          <methodname>configAdd()</methodname>, <methodname>init()</methodname>,
          and <methodname>draw()</methodname> methods declared. Note that the
          application declares several device interface members that are used
          by the application for getting device data.</para>

          <programlisting linenumbering="numbered">using namespace vrj;
using namespace gadget;

class simpleApp : public GlApp
{
public:
   simpleApp();
   virtual bool configCanHandle(jccl::ConfigChunkPtr element);
   virtual bool configAdd(jccl::ConfigChunkPtr element);
   virtual void init();
   virtual void draw();

public:
   PositionInterface mWand;
   DigitalInterface mButtons[3];

   GLfloat mSurfaceColor_ll[3];
   GLfloat mSurfaceColor_lr[3];
   GLfloat mSurfaceColor_ur[3];
   GLfloat mSurfaceColor_ul[3];
};</programlisting>
        </section>

        <section>
          <title>Application Configuration</title>

          <note>
            <para>Readers unfamiliar with the JCCL terminology should refer to
            the JCCL documentation. We will not attempt to give a full
            explanation of how JCCL works here.</para>
          </note>

          <para>In the example application ConfigApp, we will see how to
          configure the color of the ground in the 3D scene using JCCL. The
          configuration is based on a configuration element definition that
          defines four properties, each with three values. The ground is
          defined as a rectangular polygon, and each property corresponds to
          one of the corners of the rectangle. The values of the property are
          the red, green, and blue values for the color of the corresponding
          corner vertex.</para>

          <para>In <xref linkend="example.ConfigApp.desc" />, we show one part
          of <filename>ConfigApp.desc</filename>. This contains many key
          pieces of information. The <quote>token</quote> defines the type of
          the configuration element(s) that will appear in a configuration
          file. In our case, our element type is <quote>ConfigApp.</quote>
          Next, the category for our configuration element is defined to be
          <quote>Application.</quote> This is done to indicate that this is an
          application-specific configuration definition. Finally, we see the
          property description for the lower-left corner, which has three
          floating-point values. The values have defaults of 1.0 for red, 0.0
          for green, and 0.0 for blue. As such, the lower left corner vertex
          color defaults to red. The property descriptions for the other three
          corners are similar.</para>

          <example id="example.ConfigApp.desc">
            <title>Partial listing of <filename>ConfigApp.desc</filename></title>

            <programlisting>&#60;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&#62;
&#60;?org-vrjuggler-jccl-settings desc.db.version=&#34;2.1&#34;?&#62;
&#60;ChunkDescDB&#62;
  &#60;ChunkDesc token=&#34;ConfigApp&#34; name=&#34;ConfigApp&#34;&#62;
    &#60;category&#62;Application&#60;/category&#62;
    &#60;PropertyDesc name=&#34;Lower left corner color&#34; token=&#34;lowerLeftColor&#34; type=&#34;float&#34; variable=&#34;0&#34;&#62;
      &#60;item label=&#34;Red value&#34; defaultvalue=&#34;1.0&#34; /&#62;
      &#60;item label=&#34;Green value&#34; defaultvalue=&#34;0.0&#34; /&#62;
      &#60;item label=&#34;Blue value&#34; defaultvalue=&#34;0.0&#34; /&#62;
      &#60;help&#62;Specifies the RGB values for the lower left corner color.&#60;/help&#62;
    &#60;/PropertyDesc&#62;
   &#60;!-- Property definitions for the remaining three corners follow. --&#62;
&#60;/ChunkDesc&#62;</programlisting>
          </example>

          <para>Using this configuration definition, we can create an instance
          of our configuration type in a configuration file. An example
          instance is shown in <xref linkend="example.ConfigApp.config" />.
          Here, we see the configuration for all four corners of the
          rectangular ground polygon. Note also that the definition file
          <filename>ConfigApp.desc</filename> is included using an XML
          processing instruction on line 3. This is done so that the JCCL
          runtime will know how to handle our custom configuration element
          type.</para>

          <example id="example.ConfigApp.config">
            <title><filename>ConfigApp.config</filename></title>

            <programlisting>&#60;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&#62;
&#60;?org-vrjuggler-jccl-settings config.db.version=&#34;2.1&#34;?&#62;
&#60;?org-vrjuggler-jccl-includedesc file=&#34;ConfigApp.desc&#34;?&#62;
&#60;ConfigChunkDB&#62;
  &#60;ConfigApp name=&#34;Config App Example&#34;&#62;
    &#60;lowerLeftColor&#62;1.0&#60;/lowerLeftColor&#62;
    &#60;lowerLeftColor&#62;0.0&#60;/lowerLeftColor&#62;
    &#60;lowerLeftColor&#62;0.0&#60;/lowerLeftColor&#62;
    &#60;lowerRightColor&#62;1.0&#60;/lowerRightColor&#62;
    &#60;lowerRightColor&#62;1.0&#60;/lowerRightColor&#62;
    &#60;lowerRightColor&#62;0.0&#60;/lowerRightColor&#62;
    &#60;upperRightColor&#62;0.0&#60;/upperRightColor&#62;
    &#60;upperRightColor&#62;1.0&#60;/upperRightColor&#62;
    &#60;upperRightColor&#62;0.0&#60;/upperRightColor&#62;
    &#60;upperLeftColor&#62;0.0&#60;/upperLeftColor&#62;
    &#60;upperLeftColor&#62;0.0&#60;/upperLeftColor&#62;
    &#60;upperLeftColor&#62;1.0&#60;/upperLeftColor&#62;
  &#60;/ConfigApp&#62;
&#60;/ConfigChunkDB&#62;
</programlisting>
          </example>
        </section>

        <section>
          <title>The <methodname>configCanHandle()</methodname> Member
          Function</title>

          <para>The implementation of <methodname>configCanHandle()</methodname>
          is located in <filename>ConfigApp.cpp</filename>. It will be invoked
          whenever a new configuration element is found, and its job is to
          tell the JCCL Configuration Manager if it can be handled or not. The
          full implementation is as follows:</para>

          <programlisting>bool ConfigApp::configCanHandle(ConfigChunkPtr element)
{
   const std::string my_type(&#34;ConfigApp&#34;);

   return (my_type == element-&#62;getDescToken());
}
</programlisting>

          <para>We define the element type that the application knows how to
          handle (named <quote>ConfigApp</quote>, as shown above), and we
          return <constant>true</constant> if that type matches the type of
          the newly loaded configuration element.</para>
        </section>

        <section>
          <title>The <methodname>configAdd()</methodname> Member Function</title>

          <para>When a configuration element matching our type is loaded, the
          method <methodname>configAdd()</methodname> is invoked. The
          parameter passed in is the full configuration element that was
          loaded. The job of <methodname>configAdd()</methodname> is to read
          the information from the configuration element and configure the
          application based on what is read. In this specific case, we will
          read color information used for coloring the ground polygon in the
          scene. A partial implementation of <methodname>ConfigApp::configAdd()</methodname>
          follows:</para>

          <programlisting>bool ConfigApp::configAdd(jccl::ConfigChunkPtr element)
{
   const std::string ll_color(&#34;lowerLeftColor&#34;);

   // Get the color settings for the lower left corner (ll).
   for ( int i = 0; i &#60; element-&#62;getNum(ll_color); ++i )
   {
      mSurfaceColor_ll[i] = element-&#62;getProperty&#60;float&#62;(ll_color, i);
   }

   // Get the color settings for the other three corners ...
}</programlisting>

          <para>Note that we are reading the values from the property named
          <quote>lowerLeftCorner.</quote> While we know that there are three
          (3) values to read, we ask the configuration how many values it has
          just to be safe.</para>
        </section>

        <section>
          <title>The <methodname>draw()</methodname> Member Function</title>

          <para>For this application, the draw() member function is not
          terribly interesting. It renders the ground, and the colors for the
          four vertices are set using the member variables. Of course, the
          values for these member variables are set using the configuration
          file, and that is the interesting aspect.</para>
        </section>

        <section>
          <title>Exercise</title>

          <para></para>
        </section>
      </section>
    </chapter>

    <chapter id="chapter.add.device.driver">
      <title>Adding Device Drivers</title>

      <indexterm>
        <primary>device drivers</primary>

        <secondary>adding</secondary>
      </indexterm>

      <para>Please refer to the Gadgeteer <emphasis>Device Driver Authoring
      Guide</emphasis> for a comprehensive description of how to write device
      drivers for use with VR Juggler applications.</para>
    </chapter>
  </part>

  <glossary>
    <title>Glossary of Terms</title>

    <glossdiv>
      <title>A</title>

      <glossentry id="gloss.app.object">
        <glossterm>application object</glossterm>

        <glossdef>
          <para>An instance of a C++ class that is given to the VR Juggler
          kernel for execution. Such objects contain the visuals and the
          interactions that make up a virtual world.</para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>C</title>

      <glossentry id="gloss.callback">
        <glossterm>callback</glossterm>

        <glossdef>
          <para>In the C programming language, a function pointer that is
          invoked to <quote>call back</quote> to some other code. Usually, a
          function pointer is passed as an argument to some function that
          stores the pointer for later use.</para>
        </glossdef>
      </glossentry>

      <glossentry id="gloss.csdata">
        <glossterm>context-specific data</glossterm>

        <glossdef>
          <para>In OpenGL terms, some information that is associated with a
          specific OpenGL context.</para>
        </glossdef>
      </glossentry>

      <glossentry id="gloss.critical.section">
        <glossterm>critical section</glossterm>

        <glossdef>
          <para>In multi-threaded programming, a block of code that reads from
          or writes to data that is shared across multiple threads.</para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>D</title>

      <glossentry id="gloss.daemon">
        <glossterm>daemon</glossterm>

        <glossdef>
          <para>In UNIX-based operating systems, a background process that
          performs some job continuously while the computer is running. For
          example, a web server runs a daemon (often called
          <command>httpd</command>) that manages incoming HTTP requests.</para>
        </glossdef>
      </glossentry>

      <glossentry id="gloss.display.context">
        <glossterm>display context</glossterm>

        <glossdef>
          <para>The location to which OpenGL rendering commands draw.</para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>F</title>

      <glossentry id="gloss.frame">
        <glossterm>frame</glossterm>

        <glossdef>
          <para>In computer graphics terms, one iteration of a rendering loop.
          In VR Juggler, a frame is one complete pass through an application
          object&#39;s methods, beginning with <methodname>vrj::App::preFrame()</methodname>
          and ending with <methodname>vrj::App::postFrame()</methodname>.
          Methods called in between include <methodname>vrj::App::intraFrame()</methodname>
          and methods that are specific to a given graphics API.</para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>I</title>

      <glossentry id="gloss.interface">
        <glossterm>interface</glossterm>

        <glossdef>
          <para>An interface is a collection of operations used to specify a
          service of a class or a component.</para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>O</title>

      <glossentry id="gloss.opengl.rendering.context">
        <glossterm>OpenGL rendering context</glossterm>

        <glossdef>
          <para>An OpenGL state machine associated with a display window.</para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>P</title>

      <glossentry id="gloss.proxy">
        <glossterm>proxy</glossterm>

        <glossdef>
          <para>An intermediary that passes information between two parties.</para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>S</title>

      <glossentry id="gloss.smart.pointer">
        <glossterm>smart pointer</glossterm>

        <glossdef>
          <para>In C++ terminology, a smart pointer is a pointer-like object
          where the pointer dereference operators (-&#62; and *) are
          overloaded to perform special functionality. This takes advantage of
          C++ operator overloading to hide extra processing steps behind a
          familiar syntax.</para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>T</title>

      <glossentry id="gloss.thread.of.control">
        <glossterm>thread of control</glossterm>

        <glossdef>
          <para>In a multi-threaded application, a single sequence of
          execution. Each thread in a multi-threaded application has its own
          thread of control that can execute in parallel with the other
          threads of control.</para>
        </glossdef>
      </glossentry>

      <glossentry id="gloss.triple.buffering">
        <glossterm>triple buffering</glossterm>

        <glossdef>
          <para>An extension to double buffering that uses three data buffers
          instead of two. Triple buffering minimizes the time that two threads
          have to wait to access shared data. At most, one thread will wait
          while another thread copies no more than four bytes of data. That
          is, regardless of the size of a single data buffer, the amount of
          memory copied to swap buffers is no more than four bytes (the size
          of a 32-bit memory address).</para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>V</title>

      <glossentry id="gloss.virtual.platform">
        <glossterm>virtual platform</glossterm>

        <glossdef>
          <para>An abstraction of the operating system and hardware (both the
          computer architecture and the input devices) that comprise a VR
          system. A virtual platform provides a cross-platform and cross-VR
          system layer upon which portable VR applications can be written.</para>
        </glossdef>
      </glossentry>
    </glossdiv>
  </glossary>

  <index></index>
</book>
